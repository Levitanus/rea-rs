# ! [doc = r" This file is automatically generated by executing `cargo build --features generate`."] # ! [doc = r""] # ! [doc = r" **Make adjustments in `build.rs`, not in this file!**"] # ! [allow (clippy :: many_single_char_names)] # ! [allow (clippy :: too_many_arguments)] # ! [allow (clippy :: type_complexity)] # ! [allow (non_upper_case_globals)] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [allow (unused_unsafe)] use crate :: { bindings :: root , PluginContext } ; # [doc = r" This is the low-level API access point to all SWELL functions."] # [doc = r""] # [doc = r" SWELL is the Simple Windows Emulation Layer and is exposed by REAPER for Linux"] # [doc = r" and Mac OS X."] # [doc = r""] # [doc = r" See [`Reaper`] for details how to use this struct (it's very similar)."] # [doc = r""] # [doc = r" [`Reaper`]: struct.Reaper.html"] # [derive (Copy , Clone , Debug , Default)] pub struct Swell { pub (crate) pointers : SwellFunctionPointers , pub (crate) plugin_context : Option < PluginContext > , } impl Swell { # [doc = r" Loads all available SWELL functions from the given plug-in context."] # [doc = r""] # [doc = r" Returns a `Swell` instance which allows you to call these functions."] # [doc = r""] # [doc = r" On Windows, this function will not load any function pointers because"] # [doc = r" the methods in this struct delegate to the corresponding Windows functions."] # [doc = r""] # [doc = r" # Panics"] # [doc = r""] # [doc = r" If this is Linux and the SWELL function provider is not available, this"] # [doc = r" function panics."] pub fn load (plugin_context : PluginContext) -> Swell { # [cfg (target_family = "windows")] { Swell { pointers : Default :: default () , plugin_context : Some (plugin_context) } } # [cfg (target_family = "unix")] { let mut loaded_count = 0 ; let get_func = plugin_context . swell_function_provider () . expect ("SWELL function provider not available") ; let mut pointers = unsafe { SwellFunctionPointers { loaded_count : 0 , lstrcpyn : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (lstrcpyn)) . as_ptr ())) , MulDiv : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (MulDiv)) . as_ptr ())) , Sleep : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (Sleep)) . as_ptr ())) , GetTickCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetTickCount)) . as_ptr ())) , GetFileTime : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetFileTime)) . as_ptr ())) , WritePrivateProfileString : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WritePrivateProfileString)) . as_ptr ())) , GetPrivateProfileString : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetPrivateProfileString)) . as_ptr ())) , GetPrivateProfileInt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetPrivateProfileInt)) . as_ptr ())) , GetPrivateProfileStruct : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetPrivateProfileStruct)) . as_ptr ())) , WritePrivateProfileStruct : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WritePrivateProfileStruct)) . as_ptr ())) , WritePrivateProfileSection : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WritePrivateProfileSection)) . as_ptr ())) , GetPrivateProfileSection : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetPrivateProfileSection)) . as_ptr ())) , GetModuleFileName : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetModuleFileName)) . as_ptr ())) , SWELL_PtInRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_PtInRect)) . as_ptr ())) , ShellExecute : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ShellExecute)) . as_ptr ())) , MessageBox : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (MessageBox)) . as_ptr ())) , BrowseForFiles : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (BrowseForFiles)) . as_ptr ())) , BrowseForSaveFile : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (BrowseForSaveFile)) . as_ptr ())) , BrowseForDirectory : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (BrowseForDirectory)) . as_ptr ())) , BrowseFile_SetTemplate : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (BrowseFile_SetTemplate)) . as_ptr ())) , GetDlgItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetDlgItem)) . as_ptr ())) , ShowWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ShowWindow)) . as_ptr ())) , DestroyWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DestroyWindow)) . as_ptr ())) , SWELL_GetGestureInfo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetGestureInfo)) . as_ptr ())) , SWELL_HideApp : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_HideApp)) . as_ptr ())) , SetDlgItemText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetDlgItemText)) . as_ptr ())) , SetDlgItemInt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetDlgItemInt)) . as_ptr ())) , GetDlgItemInt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetDlgItemInt)) . as_ptr ())) , GetDlgItemText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetDlgItemText)) . as_ptr ())) , GetWindowTextLength : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetWindowTextLength)) . as_ptr ())) , CheckDlgButton : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CheckDlgButton)) . as_ptr ())) , IsDlgButtonChecked : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (IsDlgButtonChecked)) . as_ptr ())) , EnableWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnableWindow)) . as_ptr ())) , SetFocus : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetFocus)) . as_ptr ())) , GetFocus : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetFocus)) . as_ptr ())) , SetForegroundWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetForegroundWindow)) . as_ptr ())) , GetForegroundWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetForegroundWindow)) . as_ptr ())) , SetCapture : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetCapture)) . as_ptr ())) , GetCapture : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetCapture)) . as_ptr ())) , ReleaseCapture : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ReleaseCapture)) . as_ptr ())) , IsChild : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (IsChild)) . as_ptr ())) , GetParent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetParent)) . as_ptr ())) , SetParent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetParent)) . as_ptr ())) , GetWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetWindow)) . as_ptr ())) , EnumWindows : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnumWindows)) . as_ptr ())) , FindWindowEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (FindWindowEx)) . as_ptr ())) , ClientToScreen : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ClientToScreen)) . as_ptr ())) , ScreenToClient : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ScreenToClient)) . as_ptr ())) , GetWindowRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetWindowRect)) . as_ptr ())) , GetWindowContentViewRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetWindowContentViewRect)) . as_ptr ())) , GetClientRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetClientRect)) . as_ptr ())) , WindowFromPoint : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WindowFromPoint)) . as_ptr ())) , WinOffsetRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WinOffsetRect)) . as_ptr ())) , WinSetRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WinSetRect)) . as_ptr ())) , WinUnionRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WinUnionRect)) . as_ptr ())) , WinIntersectRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WinIntersectRect)) . as_ptr ())) , SetWindowPos : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetWindowPos)) . as_ptr ())) , SWELL_SetWindowLevel : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetWindowLevel)) . as_ptr ())) , InvalidateRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (InvalidateRect)) . as_ptr ())) , UpdateWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (UpdateWindow)) . as_ptr ())) , GetWindowLong : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetWindowLong)) . as_ptr ())) , SetWindowLong : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetWindowLong)) . as_ptr ())) , ScrollWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ScrollWindow)) . as_ptr ())) , EnumPropsEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnumPropsEx)) . as_ptr ())) , GetProp : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetProp)) . as_ptr ())) , SetProp : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetProp)) . as_ptr ())) , RemoveProp : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (RemoveProp)) . as_ptr ())) , IsWindowVisible : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (IsWindowVisible)) . as_ptr ())) , IsWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (IsWindow)) . as_ptr ())) , SetTimer : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetTimer)) . as_ptr ())) , KillTimer : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (KillTimer)) . as_ptr ())) , ListView_SetExtendedListViewStyleEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetExtendedListViewStyleEx)) . as_ptr ())) , ListView_InsertColumn : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_InsertColumn)) . as_ptr ())) , ListView_DeleteColumn : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_DeleteColumn)) . as_ptr ())) , ListView_SetColumn : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetColumn)) . as_ptr ())) , ListView_GetColumnWidth : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetColumnWidth)) . as_ptr ())) , ListView_InsertItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_InsertItem)) . as_ptr ())) , ListView_SetItemText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetItemText)) . as_ptr ())) , ListView_SetItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetItem)) . as_ptr ())) , ListView_GetNextItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetNextItem)) . as_ptr ())) , ListView_GetItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetItem)) . as_ptr ())) , ListView_GetItemState : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetItemState)) . as_ptr ())) , ListView_DeleteItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_DeleteItem)) . as_ptr ())) , ListView_DeleteAllItems : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_DeleteAllItems)) . as_ptr ())) , ListView_GetSelectedCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetSelectedCount)) . as_ptr ())) , ListView_GetItemCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetItemCount)) . as_ptr ())) , ListView_GetSelectionMark : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetSelectionMark)) . as_ptr ())) , ListView_SetColumnWidth : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetColumnWidth)) . as_ptr ())) , ListView_SetItemState : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetItemState)) . as_ptr ())) , ListView_RedrawItems : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_RedrawItems)) . as_ptr ())) , ListView_SetItemCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetItemCount)) . as_ptr ())) , ListView_EnsureVisible : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_EnsureVisible)) . as_ptr ())) , ListView_SetImageList : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetImageList)) . as_ptr ())) , ListView_SubItemHitTest : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SubItemHitTest)) . as_ptr ())) , ListView_GetItemText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetItemText)) . as_ptr ())) , ListView_SortItems : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SortItems)) . as_ptr ())) , ListView_Scroll : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_Scroll)) . as_ptr ())) , ListView_GetTopIndex : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetTopIndex)) . as_ptr ())) , ListView_GetCountPerPage : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetCountPerPage)) . as_ptr ())) , ListView_SetColumnOrderArray : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetColumnOrderArray)) . as_ptr ())) , ListView_GetColumnOrderArray : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetColumnOrderArray)) . as_ptr ())) , ListView_GetHeader : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetHeader)) . as_ptr ())) , Header_GetItemCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (Header_GetItemCount)) . as_ptr ())) , Header_GetItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (Header_GetItem)) . as_ptr ())) , Header_SetItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (Header_SetItem)) . as_ptr ())) , ListView_GetItemRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetItemRect)) . as_ptr ())) , ListView_GetSubItemRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_GetSubItemRect)) . as_ptr ())) , ListView_HitTest : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_HitTest)) . as_ptr ())) , SWELL_GetListViewHeaderHeight : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetListViewHeaderHeight)) . as_ptr ())) , ImageList_CreateEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ImageList_CreateEx)) . as_ptr ())) , ImageList_Remove : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ImageList_Remove)) . as_ptr ())) , ImageList_ReplaceIcon : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ImageList_ReplaceIcon)) . as_ptr ())) , ImageList_Add : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ImageList_Add)) . as_ptr ())) , ImageList_Destroy : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ImageList_Destroy)) . as_ptr ())) , TabCtrl_GetItemCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TabCtrl_GetItemCount)) . as_ptr ())) , TabCtrl_DeleteItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TabCtrl_DeleteItem)) . as_ptr ())) , TabCtrl_InsertItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TabCtrl_InsertItem)) . as_ptr ())) , TabCtrl_SetCurSel : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TabCtrl_SetCurSel)) . as_ptr ())) , TabCtrl_GetCurSel : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TabCtrl_GetCurSel)) . as_ptr ())) , TabCtrl_AdjustRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TabCtrl_AdjustRect)) . as_ptr ())) , TreeView_InsertItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_InsertItem)) . as_ptr ())) , TreeView_Expand : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_Expand)) . as_ptr ())) , TreeView_GetSelection : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_GetSelection)) . as_ptr ())) , TreeView_DeleteItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_DeleteItem)) . as_ptr ())) , TreeView_DeleteAllItems : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_DeleteAllItems)) . as_ptr ())) , TreeView_SelectItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_SelectItem)) . as_ptr ())) , TreeView_EnsureVisible : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_EnsureVisible)) . as_ptr ())) , TreeView_GetItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_GetItem)) . as_ptr ())) , TreeView_SetItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_SetItem)) . as_ptr ())) , TreeView_HitTest : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_HitTest)) . as_ptr ())) , TreeView_SetIndent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_SetIndent)) . as_ptr ())) , TreeView_GetParent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_GetParent)) . as_ptr ())) , TreeView_GetChild : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_GetChild)) . as_ptr ())) , TreeView_GetNextSibling : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_GetNextSibling)) . as_ptr ())) , TreeView_GetRoot : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_GetRoot)) . as_ptr ())) , TreeView_SetBkColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_SetBkColor)) . as_ptr ())) , TreeView_SetTextColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TreeView_SetTextColor)) . as_ptr ())) , ListView_SetBkColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetBkColor)) . as_ptr ())) , ListView_SetTextBkColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetTextBkColor)) . as_ptr ())) , ListView_SetTextColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetTextColor)) . as_ptr ())) , ListView_SetGridColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetGridColor)) . as_ptr ())) , ListView_SetSelColors : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ListView_SetSelColors)) . as_ptr ())) , SWELL_ModalWindowStart : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ModalWindowStart)) . as_ptr ())) , SWELL_ModalWindowRun : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ModalWindowRun)) . as_ptr ())) , SWELL_ModalWindowEnd : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ModalWindowEnd)) . as_ptr ())) , SWELL_CloseWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CloseWindow)) . as_ptr ())) , CreatePopupMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreatePopupMenu)) . as_ptr ())) , CreatePopupMenuEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreatePopupMenuEx)) . as_ptr ())) , DestroyMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DestroyMenu)) . as_ptr ())) , AddMenuItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (AddMenuItem)) . as_ptr ())) , GetSubMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetSubMenu)) . as_ptr ())) , GetMenuItemCount : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetMenuItemCount)) . as_ptr ())) , GetMenuItemID : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetMenuItemID)) . as_ptr ())) , SetMenuItemModifier : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetMenuItemModifier)) . as_ptr ())) , SetMenuItemText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetMenuItemText)) . as_ptr ())) , EnableMenuItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnableMenuItem)) . as_ptr ())) , DeleteMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DeleteMenu)) . as_ptr ())) , CheckMenuItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CheckMenuItem)) . as_ptr ())) , InsertMenuItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (InsertMenuItem)) . as_ptr ())) , SWELL_InsertMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_InsertMenu)) . as_ptr ())) , GetMenuItemInfo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetMenuItemInfo)) . as_ptr ())) , SetMenuItemInfo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetMenuItemInfo)) . as_ptr ())) , DrawMenuBar : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DrawMenuBar)) . as_ptr ())) , SWELL_LoadMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_LoadMenu)) . as_ptr ())) , TrackPopupMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (TrackPopupMenu)) . as_ptr ())) , SWELL_SetMenuDestination : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetMenuDestination)) . as_ptr ())) , SWELL_DuplicateMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_DuplicateMenu)) . as_ptr ())) , SetMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetMenu)) . as_ptr ())) , GetMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetMenu)) . as_ptr ())) , SWELL_GetDefaultWindowMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetDefaultWindowMenu)) . as_ptr ())) , SWELL_SetDefaultWindowMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetDefaultWindowMenu)) . as_ptr ())) , SWELL_GetDefaultModalWindowMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetDefaultModalWindowMenu)) . as_ptr ())) , SWELL_SetDefaultModalWindowMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetDefaultModalWindowMenu)) . as_ptr ())) , SWELL_GetCurrentMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetCurrentMenu)) . as_ptr ())) , SWELL_SetCurrentMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetCurrentMenu)) . as_ptr ())) , SWELL_DialogBox : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_DialogBox)) . as_ptr ())) , SWELL_CreateDialog : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CreateDialog)) . as_ptr ())) , SWELL_RegisterCustomControlCreator : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_RegisterCustomControlCreator)) . as_ptr ())) , SWELL_UnregisterCustomControlCreator : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_UnregisterCustomControlCreator)) . as_ptr ())) , DefWindowProc : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DefWindowProc)) . as_ptr ())) , EndDialog : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EndDialog)) . as_ptr ())) , SWELL_GetDefaultButtonID : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetDefaultButtonID)) . as_ptr ())) , SendMessage : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SendMessage)) . as_ptr ())) , SWELL_BroadcastMessage : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_BroadcastMessage)) . as_ptr ())) , PostMessage : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (PostMessage)) . as_ptr ())) , SWELL_MessageQueue_Flush : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MessageQueue_Flush)) . as_ptr ())) , SWELL_MessageQueue_Clear : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MessageQueue_Clear)) . as_ptr ())) , SWELL_KeyToASCII : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_KeyToASCII)) . as_ptr ())) , GetAsyncKeyState : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetAsyncKeyState)) . as_ptr ())) , GetCursorPos : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetCursorPos)) . as_ptr ())) , GetMessagePos : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetMessagePos)) . as_ptr ())) , SWELL_LoadCursor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_LoadCursor)) . as_ptr ())) , SWELL_SetCursor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetCursor)) . as_ptr ())) , SWELL_EnableRightClickEmulate : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_EnableRightClickEmulate)) . as_ptr ())) , SWELL_GetCursor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetCursor)) . as_ptr ())) , SWELL_GetLastSetCursor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetLastSetCursor)) . as_ptr ())) , SWELL_IsCursorVisible : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_IsCursorVisible)) . as_ptr ())) , SWELL_ShowCursor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ShowCursor)) . as_ptr ())) , SWELL_SetCursorPos : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetCursorPos)) . as_ptr ())) , SWELL_GetViewPort : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetViewPort)) . as_ptr ())) , OpenClipboard : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (OpenClipboard)) . as_ptr ())) , CloseClipboard : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CloseClipboard)) . as_ptr ())) , GetClipboardData : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetClipboardData)) . as_ptr ())) , EmptyClipboard : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EmptyClipboard)) . as_ptr ())) , SetClipboardData : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetClipboardData)) . as_ptr ())) , RegisterClipboardFormat : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (RegisterClipboardFormat)) . as_ptr ())) , EnumClipboardFormats : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnumClipboardFormats)) . as_ptr ())) , GlobalAlloc : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GlobalAlloc)) . as_ptr ())) , GlobalLock : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GlobalLock)) . as_ptr ())) , GlobalSize : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GlobalSize)) . as_ptr ())) , GlobalUnlock : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GlobalUnlock)) . as_ptr ())) , GlobalFree : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GlobalFree)) . as_ptr ())) , CreateThread : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateThread)) . as_ptr ())) , CreateEvent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateEvent)) . as_ptr ())) , CreateEventAsSocket : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateEventAsSocket)) . as_ptr ())) , GetCurrentThreadId : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetCurrentThreadId)) . as_ptr ())) , WaitForSingleObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WaitForSingleObject)) . as_ptr ())) , WaitForAnySocketObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (WaitForAnySocketObject)) . as_ptr ())) , CloseHandle : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CloseHandle)) . as_ptr ())) , SetThreadPriority : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetThreadPriority)) . as_ptr ())) , SetEvent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetEvent)) . as_ptr ())) , ResetEvent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ResetEvent)) . as_ptr ())) , SWELL_CreateProcessFromPID : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CreateProcessFromPID)) . as_ptr ())) , SWELL_CreateProcess : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CreateProcess)) . as_ptr ())) , SWELL_GetProcessExitCode : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetProcessExitCode)) . as_ptr ())) , LoadLibraryGlobals : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (LoadLibraryGlobals)) . as_ptr ())) , LoadLibrary : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (LoadLibrary)) . as_ptr ())) , GetProcAddress : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetProcAddress)) . as_ptr ())) , FreeLibrary : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (FreeLibrary)) . as_ptr ())) , SWELL_GetBundle : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetBundle)) . as_ptr ())) , SWELL_CreateMemContext : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CreateMemContext)) . as_ptr ())) , SWELL_DeleteGfxContext : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_DeleteGfxContext)) . as_ptr ())) , SWELL_GetCtxGC : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetCtxGC)) . as_ptr ())) , SWELL_GetCtxFrameBuffer : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetCtxFrameBuffer)) . as_ptr ())) , SWELL_PushClipRegion : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_PushClipRegion)) . as_ptr ())) , SWELL_SetClipRegion : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetClipRegion)) . as_ptr ())) , SWELL_PopClipRegion : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_PopClipRegion)) . as_ptr ())) , CreateFontIndirect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateFontIndirect)) . as_ptr ())) , CreateFont : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateFont)) . as_ptr ())) , CreatePen : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreatePen)) . as_ptr ())) , CreateSolidBrush : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateSolidBrush)) . as_ptr ())) , CreatePenAlpha : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreatePenAlpha)) . as_ptr ())) , CreateSolidBrushAlpha : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateSolidBrushAlpha)) . as_ptr ())) , SelectObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SelectObject)) . as_ptr ())) , GetStockObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetStockObject)) . as_ptr ())) , DeleteObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DeleteObject)) . as_ptr ())) , SWELL_FillRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_FillRect)) . as_ptr ())) , Rectangle : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (Rectangle)) . as_ptr ())) , Ellipse : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (Ellipse)) . as_ptr ())) , SWELL_Polygon : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_Polygon)) . as_ptr ())) , MoveToEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (MoveToEx)) . as_ptr ())) , SWELL_LineTo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_LineTo)) . as_ptr ())) , SWELL_SetPixel : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetPixel)) . as_ptr ())) , PolyBezierTo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (PolyBezierTo)) . as_ptr ())) , SWELL_DrawText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_DrawText)) . as_ptr ())) , SetTextColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetTextColor)) . as_ptr ())) , GetTextColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetTextColor)) . as_ptr ())) , SetBkColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetBkColor)) . as_ptr ())) , SetBkMode : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetBkMode)) . as_ptr ())) , GetGlyphIndicesW : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetGlyphIndicesW)) . as_ptr ())) , RoundRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (RoundRect)) . as_ptr ())) , PolyPolyline : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (PolyPolyline)) . as_ptr ())) , GetTextMetrics : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetTextMetrics)) . as_ptr ())) , GetTextFace : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetTextFace)) . as_ptr ())) , GetObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetObject)) . as_ptr ())) , CreateIconIndirect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateIconIndirect)) . as_ptr ())) , LoadNamedImage : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (LoadNamedImage)) . as_ptr ())) , DrawImageInRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DrawImageInRect)) . as_ptr ())) , BitBlt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (BitBlt)) . as_ptr ())) , StretchBlt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (StretchBlt)) . as_ptr ())) , StretchBltFromMem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (StretchBltFromMem)) . as_ptr ())) , SWELL_GetScaling256 : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetScaling256)) . as_ptr ())) , SWELL_ExtendedAPI : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ExtendedAPI)) . as_ptr ())) , GetSysColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetSysColor)) . as_ptr ())) , CreateBitmap : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (CreateBitmap)) . as_ptr ())) , SetOpaque : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetOpaque)) . as_ptr ())) , SetAllowNoMiddleManRendering : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SetAllowNoMiddleManRendering)) . as_ptr ())) , SWELL_SetViewGL : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetViewGL)) . as_ptr ())) , SWELL_GetViewGL : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetViewGL)) . as_ptr ())) , SWELL_SetGLContextToView : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetGLContextToView)) . as_ptr ())) , BeginPaint : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (BeginPaint)) . as_ptr ())) , EndPaint : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EndPaint)) . as_ptr ())) , GetDC : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetDC)) . as_ptr ())) , GetWindowDC : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetWindowDC)) . as_ptr ())) , ReleaseDC : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (ReleaseDC)) . as_ptr ())) , SWELL_FillDialogBackground : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_FillDialogBackground)) . as_ptr ())) , SWELL_CloneGDIObject : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CloneGDIObject)) . as_ptr ())) , GetSystemMetrics : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetSystemMetrics)) . as_ptr ())) , DragQueryPoint : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DragQueryPoint)) . as_ptr ())) , DragFinish : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DragFinish)) . as_ptr ())) , DragQueryFile : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (DragQueryFile)) . as_ptr ())) , SWELL_InitiateDragDrop : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_InitiateDragDrop)) . as_ptr ())) , SWELL_InitiateDragDropOfFileList : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_InitiateDragDropOfFileList)) . as_ptr ())) , SWELL_FinishDragDrop : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_FinishDragDrop)) . as_ptr ())) , SWELL_DrawFocusRect : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_DrawFocusRect)) . as_ptr ())) , SWELL_MakeSetCurParms : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeSetCurParms)) . as_ptr ())) , SWELL_MakeButton : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeButton)) . as_ptr ())) , SWELL_MakeEditField : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeEditField)) . as_ptr ())) , SWELL_MakeLabel : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeLabel)) . as_ptr ())) , SWELL_MakeControl : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeControl)) . as_ptr ())) , SWELL_MakeCombo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeCombo)) . as_ptr ())) , SWELL_MakeGroupBox : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeGroupBox)) . as_ptr ())) , SWELL_MakeCheckBox : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeCheckBox)) . as_ptr ())) , SWELL_MakeListBox : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_MakeListBox)) . as_ptr ())) , SWELL_Menu_AddMenuItem : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_Menu_AddMenuItem)) . as_ptr ())) , SWELL_GenerateMenuFromList : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GenerateMenuFromList)) . as_ptr ())) , SWELL_GenerateDialogFromList : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GenerateDialogFromList)) . as_ptr ())) , _controlfp : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (_controlfp)) . as_ptr ())) , SWELL_Internal_PostMessage_Init : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_Internal_PostMessage_Init)) . as_ptr ())) , SWELL_LoadCursorFromFile : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_LoadCursorFromFile)) . as_ptr ())) , SWELL_SetWindowWantRaiseAmt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetWindowWantRaiseAmt)) . as_ptr ())) , SWELL_GetWindowWantRaiseAmt : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetWindowWantRaiseAmt)) . as_ptr ())) , SWELL_SetListViewFastClickMask : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetListViewFastClickMask)) . as_ptr ())) , GetTempPath : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetTempPath)) . as_ptr ())) , SWELL_initargs : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_initargs)) . as_ptr ())) , SWELL_RunMessageLoop : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_RunMessageLoop)) . as_ptr ())) , SWELL_CreateXBridgeWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_CreateXBridgeWindow)) . as_ptr ())) , SWELL_GetOSWindow : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetOSWindow)) . as_ptr ())) , SWELL_GetOSEvent : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetOSEvent)) . as_ptr ())) , SWELL_GenerateGUID : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GenerateGUID)) . as_ptr ())) , EnumChildWindows : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnumChildWindows)) . as_ptr ())) , SWELL_IsGroupBox : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_IsGroupBox)) . as_ptr ())) , SWELL_IsButton : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_IsButton)) . as_ptr ())) , SWELL_IsStaticText : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_IsStaticText)) . as_ptr ())) , SWELL_GetDesiredControlSize : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_GetDesiredControlSize)) . as_ptr ())) , AddFontResourceEx : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (AddFontResourceEx)) . as_ptr ())) , SWELL_Register_Cursor_Resource : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_Register_Cursor_Resource)) . as_ptr ())) , SWELL_ChooseColor : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ChooseColor)) . as_ptr ())) , SWELL_ChooseFont : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_ChooseFont)) . as_ptr ())) , IsWindowEnabled : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (IsWindowEnabled)) . as_ptr ())) , GetClassName : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetClassName)) . as_ptr ())) , SWELL_SetClassName : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_SetClassName)) . as_ptr ())) , SWELL_DisableContextMenu : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_DisableContextMenu)) . as_ptr ())) , EnumDisplayMonitors : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (EnumDisplayMonitors)) . as_ptr ())) , GetMonitorInfo : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (GetMonitorInfo)) . as_ptr ())) , SWELL_osx_is_dark_mode : std :: mem :: transmute (get_func (c_str_macro :: c_str ! (stringify ! (SWELL_osx_is_dark_mode)) . as_ptr ())) , } } ; if pointers . lstrcpyn . is_some () { loaded_count += 1 ; } if pointers . MulDiv . is_some () { loaded_count += 1 ; } if pointers . Sleep . is_some () { loaded_count += 1 ; } if pointers . GetTickCount . is_some () { loaded_count += 1 ; } if pointers . GetFileTime . is_some () { loaded_count += 1 ; } if pointers . WritePrivateProfileString . is_some () { loaded_count += 1 ; } if pointers . GetPrivateProfileString . is_some () { loaded_count += 1 ; } if pointers . GetPrivateProfileInt . is_some () { loaded_count += 1 ; } if pointers . GetPrivateProfileStruct . is_some () { loaded_count += 1 ; } if pointers . WritePrivateProfileStruct . is_some () { loaded_count += 1 ; } if pointers . WritePrivateProfileSection . is_some () { loaded_count += 1 ; } if pointers . GetPrivateProfileSection . is_some () { loaded_count += 1 ; } if pointers . GetModuleFileName . is_some () { loaded_count += 1 ; } if pointers . SWELL_PtInRect . is_some () { loaded_count += 1 ; } if pointers . ShellExecute . is_some () { loaded_count += 1 ; } if pointers . MessageBox . is_some () { loaded_count += 1 ; } if pointers . BrowseForFiles . is_some () { loaded_count += 1 ; } if pointers . BrowseForSaveFile . is_some () { loaded_count += 1 ; } if pointers . BrowseForDirectory . is_some () { loaded_count += 1 ; } if pointers . BrowseFile_SetTemplate . is_some () { loaded_count += 1 ; } if pointers . GetDlgItem . is_some () { loaded_count += 1 ; } if pointers . ShowWindow . is_some () { loaded_count += 1 ; } if pointers . DestroyWindow . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetGestureInfo . is_some () { loaded_count += 1 ; } if pointers . SWELL_HideApp . is_some () { loaded_count += 1 ; } if pointers . SetDlgItemText . is_some () { loaded_count += 1 ; } if pointers . SetDlgItemInt . is_some () { loaded_count += 1 ; } if pointers . GetDlgItemInt . is_some () { loaded_count += 1 ; } if pointers . GetDlgItemText . is_some () { loaded_count += 1 ; } if pointers . GetWindowTextLength . is_some () { loaded_count += 1 ; } if pointers . CheckDlgButton . is_some () { loaded_count += 1 ; } if pointers . IsDlgButtonChecked . is_some () { loaded_count += 1 ; } if pointers . EnableWindow . is_some () { loaded_count += 1 ; } if pointers . SetFocus . is_some () { loaded_count += 1 ; } if pointers . GetFocus . is_some () { loaded_count += 1 ; } if pointers . SetForegroundWindow . is_some () { loaded_count += 1 ; } if pointers . GetForegroundWindow . is_some () { loaded_count += 1 ; } if pointers . SetCapture . is_some () { loaded_count += 1 ; } if pointers . GetCapture . is_some () { loaded_count += 1 ; } if pointers . ReleaseCapture . is_some () { loaded_count += 1 ; } if pointers . IsChild . is_some () { loaded_count += 1 ; } if pointers . GetParent . is_some () { loaded_count += 1 ; } if pointers . SetParent . is_some () { loaded_count += 1 ; } if pointers . GetWindow . is_some () { loaded_count += 1 ; } if pointers . EnumWindows . is_some () { loaded_count += 1 ; } if pointers . FindWindowEx . is_some () { loaded_count += 1 ; } if pointers . ClientToScreen . is_some () { loaded_count += 1 ; } if pointers . ScreenToClient . is_some () { loaded_count += 1 ; } if pointers . GetWindowRect . is_some () { loaded_count += 1 ; } if pointers . GetWindowContentViewRect . is_some () { loaded_count += 1 ; } if pointers . GetClientRect . is_some () { loaded_count += 1 ; } if pointers . WindowFromPoint . is_some () { loaded_count += 1 ; } if pointers . WinOffsetRect . is_some () { loaded_count += 1 ; } if pointers . WinSetRect . is_some () { loaded_count += 1 ; } if pointers . WinUnionRect . is_some () { loaded_count += 1 ; } if pointers . WinIntersectRect . is_some () { loaded_count += 1 ; } if pointers . SetWindowPos . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetWindowLevel . is_some () { loaded_count += 1 ; } if pointers . InvalidateRect . is_some () { loaded_count += 1 ; } if pointers . UpdateWindow . is_some () { loaded_count += 1 ; } if pointers . GetWindowLong . is_some () { loaded_count += 1 ; } if pointers . SetWindowLong . is_some () { loaded_count += 1 ; } if pointers . ScrollWindow . is_some () { loaded_count += 1 ; } if pointers . EnumPropsEx . is_some () { loaded_count += 1 ; } if pointers . GetProp . is_some () { loaded_count += 1 ; } if pointers . SetProp . is_some () { loaded_count += 1 ; } if pointers . RemoveProp . is_some () { loaded_count += 1 ; } if pointers . IsWindowVisible . is_some () { loaded_count += 1 ; } if pointers . IsWindow . is_some () { loaded_count += 1 ; } if pointers . SetTimer . is_some () { loaded_count += 1 ; } if pointers . KillTimer . is_some () { loaded_count += 1 ; } if pointers . ListView_SetExtendedListViewStyleEx . is_some () { loaded_count += 1 ; } if pointers . ListView_InsertColumn . is_some () { loaded_count += 1 ; } if pointers . ListView_DeleteColumn . is_some () { loaded_count += 1 ; } if pointers . ListView_SetColumn . is_some () { loaded_count += 1 ; } if pointers . ListView_GetColumnWidth . is_some () { loaded_count += 1 ; } if pointers . ListView_InsertItem . is_some () { loaded_count += 1 ; } if pointers . ListView_SetItemText . is_some () { loaded_count += 1 ; } if pointers . ListView_SetItem . is_some () { loaded_count += 1 ; } if pointers . ListView_GetNextItem . is_some () { loaded_count += 1 ; } if pointers . ListView_GetItem . is_some () { loaded_count += 1 ; } if pointers . ListView_GetItemState . is_some () { loaded_count += 1 ; } if pointers . ListView_DeleteItem . is_some () { loaded_count += 1 ; } if pointers . ListView_DeleteAllItems . is_some () { loaded_count += 1 ; } if pointers . ListView_GetSelectedCount . is_some () { loaded_count += 1 ; } if pointers . ListView_GetItemCount . is_some () { loaded_count += 1 ; } if pointers . ListView_GetSelectionMark . is_some () { loaded_count += 1 ; } if pointers . ListView_SetColumnWidth . is_some () { loaded_count += 1 ; } if pointers . ListView_SetItemState . is_some () { loaded_count += 1 ; } if pointers . ListView_RedrawItems . is_some () { loaded_count += 1 ; } if pointers . ListView_SetItemCount . is_some () { loaded_count += 1 ; } if pointers . ListView_EnsureVisible . is_some () { loaded_count += 1 ; } if pointers . ListView_SetImageList . is_some () { loaded_count += 1 ; } if pointers . ListView_SubItemHitTest . is_some () { loaded_count += 1 ; } if pointers . ListView_GetItemText . is_some () { loaded_count += 1 ; } if pointers . ListView_SortItems . is_some () { loaded_count += 1 ; } if pointers . ListView_Scroll . is_some () { loaded_count += 1 ; } if pointers . ListView_GetTopIndex . is_some () { loaded_count += 1 ; } if pointers . ListView_GetCountPerPage . is_some () { loaded_count += 1 ; } if pointers . ListView_SetColumnOrderArray . is_some () { loaded_count += 1 ; } if pointers . ListView_GetColumnOrderArray . is_some () { loaded_count += 1 ; } if pointers . ListView_GetHeader . is_some () { loaded_count += 1 ; } if pointers . Header_GetItemCount . is_some () { loaded_count += 1 ; } if pointers . Header_GetItem . is_some () { loaded_count += 1 ; } if pointers . Header_SetItem . is_some () { loaded_count += 1 ; } if pointers . ListView_GetItemRect . is_some () { loaded_count += 1 ; } if pointers . ListView_GetSubItemRect . is_some () { loaded_count += 1 ; } if pointers . ListView_HitTest . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetListViewHeaderHeight . is_some () { loaded_count += 1 ; } if pointers . ImageList_CreateEx . is_some () { loaded_count += 1 ; } if pointers . ImageList_Remove . is_some () { loaded_count += 1 ; } if pointers . ImageList_ReplaceIcon . is_some () { loaded_count += 1 ; } if pointers . ImageList_Add . is_some () { loaded_count += 1 ; } if pointers . ImageList_Destroy . is_some () { loaded_count += 1 ; } if pointers . TabCtrl_GetItemCount . is_some () { loaded_count += 1 ; } if pointers . TabCtrl_DeleteItem . is_some () { loaded_count += 1 ; } if pointers . TabCtrl_InsertItem . is_some () { loaded_count += 1 ; } if pointers . TabCtrl_SetCurSel . is_some () { loaded_count += 1 ; } if pointers . TabCtrl_GetCurSel . is_some () { loaded_count += 1 ; } if pointers . TabCtrl_AdjustRect . is_some () { loaded_count += 1 ; } if pointers . TreeView_InsertItem . is_some () { loaded_count += 1 ; } if pointers . TreeView_Expand . is_some () { loaded_count += 1 ; } if pointers . TreeView_GetSelection . is_some () { loaded_count += 1 ; } if pointers . TreeView_DeleteItem . is_some () { loaded_count += 1 ; } if pointers . TreeView_DeleteAllItems . is_some () { loaded_count += 1 ; } if pointers . TreeView_SelectItem . is_some () { loaded_count += 1 ; } if pointers . TreeView_EnsureVisible . is_some () { loaded_count += 1 ; } if pointers . TreeView_GetItem . is_some () { loaded_count += 1 ; } if pointers . TreeView_SetItem . is_some () { loaded_count += 1 ; } if pointers . TreeView_HitTest . is_some () { loaded_count += 1 ; } if pointers . TreeView_SetIndent . is_some () { loaded_count += 1 ; } if pointers . TreeView_GetParent . is_some () { loaded_count += 1 ; } if pointers . TreeView_GetChild . is_some () { loaded_count += 1 ; } if pointers . TreeView_GetNextSibling . is_some () { loaded_count += 1 ; } if pointers . TreeView_GetRoot . is_some () { loaded_count += 1 ; } if pointers . TreeView_SetBkColor . is_some () { loaded_count += 1 ; } if pointers . TreeView_SetTextColor . is_some () { loaded_count += 1 ; } if pointers . ListView_SetBkColor . is_some () { loaded_count += 1 ; } if pointers . ListView_SetTextBkColor . is_some () { loaded_count += 1 ; } if pointers . ListView_SetTextColor . is_some () { loaded_count += 1 ; } if pointers . ListView_SetGridColor . is_some () { loaded_count += 1 ; } if pointers . ListView_SetSelColors . is_some () { loaded_count += 1 ; } if pointers . SWELL_ModalWindowStart . is_some () { loaded_count += 1 ; } if pointers . SWELL_ModalWindowRun . is_some () { loaded_count += 1 ; } if pointers . SWELL_ModalWindowEnd . is_some () { loaded_count += 1 ; } if pointers . SWELL_CloseWindow . is_some () { loaded_count += 1 ; } if pointers . CreatePopupMenu . is_some () { loaded_count += 1 ; } if pointers . CreatePopupMenuEx . is_some () { loaded_count += 1 ; } if pointers . DestroyMenu . is_some () { loaded_count += 1 ; } if pointers . AddMenuItem . is_some () { loaded_count += 1 ; } if pointers . GetSubMenu . is_some () { loaded_count += 1 ; } if pointers . GetMenuItemCount . is_some () { loaded_count += 1 ; } if pointers . GetMenuItemID . is_some () { loaded_count += 1 ; } if pointers . SetMenuItemModifier . is_some () { loaded_count += 1 ; } if pointers . SetMenuItemText . is_some () { loaded_count += 1 ; } if pointers . EnableMenuItem . is_some () { loaded_count += 1 ; } if pointers . DeleteMenu . is_some () { loaded_count += 1 ; } if pointers . CheckMenuItem . is_some () { loaded_count += 1 ; } if pointers . InsertMenuItem . is_some () { loaded_count += 1 ; } if pointers . SWELL_InsertMenu . is_some () { loaded_count += 1 ; } if pointers . GetMenuItemInfo . is_some () { loaded_count += 1 ; } if pointers . SetMenuItemInfo . is_some () { loaded_count += 1 ; } if pointers . DrawMenuBar . is_some () { loaded_count += 1 ; } if pointers . SWELL_LoadMenu . is_some () { loaded_count += 1 ; } if pointers . TrackPopupMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetMenuDestination . is_some () { loaded_count += 1 ; } if pointers . SWELL_DuplicateMenu . is_some () { loaded_count += 1 ; } if pointers . SetMenu . is_some () { loaded_count += 1 ; } if pointers . GetMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetDefaultWindowMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetDefaultWindowMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetDefaultModalWindowMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetDefaultModalWindowMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetCurrentMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetCurrentMenu . is_some () { loaded_count += 1 ; } if pointers . SWELL_DialogBox . is_some () { loaded_count += 1 ; } if pointers . SWELL_CreateDialog . is_some () { loaded_count += 1 ; } if pointers . SWELL_RegisterCustomControlCreator . is_some () { loaded_count += 1 ; } if pointers . SWELL_UnregisterCustomControlCreator . is_some () { loaded_count += 1 ; } if pointers . DefWindowProc . is_some () { loaded_count += 1 ; } if pointers . EndDialog . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetDefaultButtonID . is_some () { loaded_count += 1 ; } if pointers . SendMessage . is_some () { loaded_count += 1 ; } if pointers . SWELL_BroadcastMessage . is_some () { loaded_count += 1 ; } if pointers . PostMessage . is_some () { loaded_count += 1 ; } if pointers . SWELL_MessageQueue_Flush . is_some () { loaded_count += 1 ; } if pointers . SWELL_MessageQueue_Clear . is_some () { loaded_count += 1 ; } if pointers . SWELL_KeyToASCII . is_some () { loaded_count += 1 ; } if pointers . GetAsyncKeyState . is_some () { loaded_count += 1 ; } if pointers . GetCursorPos . is_some () { loaded_count += 1 ; } if pointers . GetMessagePos . is_some () { loaded_count += 1 ; } if pointers . SWELL_LoadCursor . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetCursor . is_some () { loaded_count += 1 ; } if pointers . SWELL_EnableRightClickEmulate . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetCursor . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetLastSetCursor . is_some () { loaded_count += 1 ; } if pointers . SWELL_IsCursorVisible . is_some () { loaded_count += 1 ; } if pointers . SWELL_ShowCursor . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetCursorPos . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetViewPort . is_some () { loaded_count += 1 ; } if pointers . OpenClipboard . is_some () { loaded_count += 1 ; } if pointers . CloseClipboard . is_some () { loaded_count += 1 ; } if pointers . GetClipboardData . is_some () { loaded_count += 1 ; } if pointers . EmptyClipboard . is_some () { loaded_count += 1 ; } if pointers . SetClipboardData . is_some () { loaded_count += 1 ; } if pointers . RegisterClipboardFormat . is_some () { loaded_count += 1 ; } if pointers . EnumClipboardFormats . is_some () { loaded_count += 1 ; } if pointers . GlobalAlloc . is_some () { loaded_count += 1 ; } if pointers . GlobalLock . is_some () { loaded_count += 1 ; } if pointers . GlobalSize . is_some () { loaded_count += 1 ; } if pointers . GlobalUnlock . is_some () { loaded_count += 1 ; } if pointers . GlobalFree . is_some () { loaded_count += 1 ; } if pointers . CreateThread . is_some () { loaded_count += 1 ; } if pointers . CreateEvent . is_some () { loaded_count += 1 ; } if pointers . CreateEventAsSocket . is_some () { loaded_count += 1 ; } if pointers . GetCurrentThreadId . is_some () { loaded_count += 1 ; } if pointers . WaitForSingleObject . is_some () { loaded_count += 1 ; } if pointers . WaitForAnySocketObject . is_some () { loaded_count += 1 ; } if pointers . CloseHandle . is_some () { loaded_count += 1 ; } if pointers . SetThreadPriority . is_some () { loaded_count += 1 ; } if pointers . SetEvent . is_some () { loaded_count += 1 ; } if pointers . ResetEvent . is_some () { loaded_count += 1 ; } if pointers . SWELL_CreateProcessFromPID . is_some () { loaded_count += 1 ; } if pointers . SWELL_CreateProcess . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetProcessExitCode . is_some () { loaded_count += 1 ; } if pointers . LoadLibraryGlobals . is_some () { loaded_count += 1 ; } if pointers . LoadLibrary . is_some () { loaded_count += 1 ; } if pointers . GetProcAddress . is_some () { loaded_count += 1 ; } if pointers . FreeLibrary . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetBundle . is_some () { loaded_count += 1 ; } if pointers . SWELL_CreateMemContext . is_some () { loaded_count += 1 ; } if pointers . SWELL_DeleteGfxContext . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetCtxGC . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetCtxFrameBuffer . is_some () { loaded_count += 1 ; } if pointers . SWELL_PushClipRegion . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetClipRegion . is_some () { loaded_count += 1 ; } if pointers . SWELL_PopClipRegion . is_some () { loaded_count += 1 ; } if pointers . CreateFontIndirect . is_some () { loaded_count += 1 ; } if pointers . CreateFont . is_some () { loaded_count += 1 ; } if pointers . CreatePen . is_some () { loaded_count += 1 ; } if pointers . CreateSolidBrush . is_some () { loaded_count += 1 ; } if pointers . CreatePenAlpha . is_some () { loaded_count += 1 ; } if pointers . CreateSolidBrushAlpha . is_some () { loaded_count += 1 ; } if pointers . SelectObject . is_some () { loaded_count += 1 ; } if pointers . GetStockObject . is_some () { loaded_count += 1 ; } if pointers . DeleteObject . is_some () { loaded_count += 1 ; } if pointers . SWELL_FillRect . is_some () { loaded_count += 1 ; } if pointers . Rectangle . is_some () { loaded_count += 1 ; } if pointers . Ellipse . is_some () { loaded_count += 1 ; } if pointers . SWELL_Polygon . is_some () { loaded_count += 1 ; } if pointers . MoveToEx . is_some () { loaded_count += 1 ; } if pointers . SWELL_LineTo . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetPixel . is_some () { loaded_count += 1 ; } if pointers . PolyBezierTo . is_some () { loaded_count += 1 ; } if pointers . SWELL_DrawText . is_some () { loaded_count += 1 ; } if pointers . SetTextColor . is_some () { loaded_count += 1 ; } if pointers . GetTextColor . is_some () { loaded_count += 1 ; } if pointers . SetBkColor . is_some () { loaded_count += 1 ; } if pointers . SetBkMode . is_some () { loaded_count += 1 ; } if pointers . GetGlyphIndicesW . is_some () { loaded_count += 1 ; } if pointers . RoundRect . is_some () { loaded_count += 1 ; } if pointers . PolyPolyline . is_some () { loaded_count += 1 ; } if pointers . GetTextMetrics . is_some () { loaded_count += 1 ; } if pointers . GetTextFace . is_some () { loaded_count += 1 ; } if pointers . GetObject . is_some () { loaded_count += 1 ; } if pointers . CreateIconIndirect . is_some () { loaded_count += 1 ; } if pointers . LoadNamedImage . is_some () { loaded_count += 1 ; } if pointers . DrawImageInRect . is_some () { loaded_count += 1 ; } if pointers . BitBlt . is_some () { loaded_count += 1 ; } if pointers . StretchBlt . is_some () { loaded_count += 1 ; } if pointers . StretchBltFromMem . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetScaling256 . is_some () { loaded_count += 1 ; } if pointers . SWELL_ExtendedAPI . is_some () { loaded_count += 1 ; } if pointers . GetSysColor . is_some () { loaded_count += 1 ; } if pointers . CreateBitmap . is_some () { loaded_count += 1 ; } if pointers . SetOpaque . is_some () { loaded_count += 1 ; } if pointers . SetAllowNoMiddleManRendering . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetViewGL . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetViewGL . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetGLContextToView . is_some () { loaded_count += 1 ; } if pointers . BeginPaint . is_some () { loaded_count += 1 ; } if pointers . EndPaint . is_some () { loaded_count += 1 ; } if pointers . GetDC . is_some () { loaded_count += 1 ; } if pointers . GetWindowDC . is_some () { loaded_count += 1 ; } if pointers . ReleaseDC . is_some () { loaded_count += 1 ; } if pointers . SWELL_FillDialogBackground . is_some () { loaded_count += 1 ; } if pointers . SWELL_CloneGDIObject . is_some () { loaded_count += 1 ; } if pointers . GetSystemMetrics . is_some () { loaded_count += 1 ; } if pointers . DragQueryPoint . is_some () { loaded_count += 1 ; } if pointers . DragFinish . is_some () { loaded_count += 1 ; } if pointers . DragQueryFile . is_some () { loaded_count += 1 ; } if pointers . SWELL_InitiateDragDrop . is_some () { loaded_count += 1 ; } if pointers . SWELL_InitiateDragDropOfFileList . is_some () { loaded_count += 1 ; } if pointers . SWELL_FinishDragDrop . is_some () { loaded_count += 1 ; } if pointers . SWELL_DrawFocusRect . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeSetCurParms . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeButton . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeEditField . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeLabel . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeControl . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeCombo . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeGroupBox . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeCheckBox . is_some () { loaded_count += 1 ; } if pointers . SWELL_MakeListBox . is_some () { loaded_count += 1 ; } if pointers . SWELL_Menu_AddMenuItem . is_some () { loaded_count += 1 ; } if pointers . SWELL_GenerateMenuFromList . is_some () { loaded_count += 1 ; } if pointers . SWELL_GenerateDialogFromList . is_some () { loaded_count += 1 ; } if pointers . _controlfp . is_some () { loaded_count += 1 ; } if pointers . SWELL_Internal_PostMessage_Init . is_some () { loaded_count += 1 ; } if pointers . SWELL_LoadCursorFromFile . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetWindowWantRaiseAmt . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetWindowWantRaiseAmt . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetListViewFastClickMask . is_some () { loaded_count += 1 ; } if pointers . GetTempPath . is_some () { loaded_count += 1 ; } if pointers . SWELL_initargs . is_some () { loaded_count += 1 ; } if pointers . SWELL_RunMessageLoop . is_some () { loaded_count += 1 ; } if pointers . SWELL_CreateXBridgeWindow . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetOSWindow . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetOSEvent . is_some () { loaded_count += 1 ; } if pointers . SWELL_GenerateGUID . is_some () { loaded_count += 1 ; } if pointers . EnumChildWindows . is_some () { loaded_count += 1 ; } if pointers . SWELL_IsGroupBox . is_some () { loaded_count += 1 ; } if pointers . SWELL_IsButton . is_some () { loaded_count += 1 ; } if pointers . SWELL_IsStaticText . is_some () { loaded_count += 1 ; } if pointers . SWELL_GetDesiredControlSize . is_some () { loaded_count += 1 ; } if pointers . AddFontResourceEx . is_some () { loaded_count += 1 ; } if pointers . SWELL_Register_Cursor_Resource . is_some () { loaded_count += 1 ; } if pointers . SWELL_ChooseColor . is_some () { loaded_count += 1 ; } if pointers . SWELL_ChooseFont . is_some () { loaded_count += 1 ; } if pointers . IsWindowEnabled . is_some () { loaded_count += 1 ; } if pointers . GetClassName . is_some () { loaded_count += 1 ; } if pointers . SWELL_SetClassName . is_some () { loaded_count += 1 ; } if pointers . SWELL_DisableContextMenu . is_some () { loaded_count += 1 ; } if pointers . EnumDisplayMonitors . is_some () { loaded_count += 1 ; } if pointers . GetMonitorInfo . is_some () { loaded_count += 1 ; } if pointers . SWELL_osx_is_dark_mode . is_some () { loaded_count += 1 ; } pointers . loaded_count = loaded_count ; Swell { pointers , plugin_context : Some (plugin_context) } } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn lstrcpyn (& self , dest : * mut :: std :: os :: raw :: c_char , src : * const :: std :: os :: raw :: c_char , l : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_char { match self . pointers . lstrcpyn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (lstrcpyn)) , Some (f) => f (dest , src , l) , } } # [cfg (target_family = "unix")] pub fn MulDiv (& self , arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MulDiv { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MulDiv)) , Some (f) => f (arg1 , arg2 , arg3) , } } # [cfg (target_family = "unix")] pub fn Sleep (& self , ms : :: std :: os :: raw :: c_int) { match self . pointers . Sleep { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Sleep)) , Some (f) => f (ms) , } } # [cfg (target_family = "unix")] pub fn GetTickCount (& self) -> root :: DWORD { match self . pointers . GetTickCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTickCount)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetFileTime (& self , filedes : :: std :: os :: raw :: c_int , lpCreationTime : * mut root :: FILETIME , lpLastAccessTime : * mut root :: FILETIME , lpLastWriteTime : * mut root :: FILETIME) -> root :: BOOL { match self . pointers . GetFileTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetFileTime)) , Some (f) => f (filedes , lpCreationTime , lpLastAccessTime , lpLastWriteTime) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WritePrivateProfileString (& self , appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , val : * const :: std :: os :: raw :: c_char , fn_ : * const :: std :: os :: raw :: c_char) -> root :: BOOL { match self . pointers . WritePrivateProfileString { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WritePrivateProfileString)) , Some (f) => f (appname , keyname , val , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPrivateProfileString (& self , appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , def : * const :: std :: os :: raw :: c_char , ret : * mut :: std :: os :: raw :: c_char , retsize : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char) -> root :: DWORD { match self . pointers . GetPrivateProfileString { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPrivateProfileString)) , Some (f) => f (appname , keyname , def , ret , retsize , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPrivateProfileInt (& self , appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , def : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . GetPrivateProfileInt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPrivateProfileInt)) , Some (f) => f (appname , keyname , def , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPrivateProfileStruct (& self , appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_void , bufsz : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char) -> root :: BOOL { match self . pointers . GetPrivateProfileStruct { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPrivateProfileStruct)) , Some (f) => f (appname , keyname , buf , bufsz , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WritePrivateProfileStruct (& self , appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , buf : * const :: std :: os :: raw :: c_void , bufsz : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char) -> root :: BOOL { match self . pointers . WritePrivateProfileStruct { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WritePrivateProfileStruct)) , Some (f) => f (appname , keyname , buf , bufsz , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WritePrivateProfileSection (& self , appname : * const :: std :: os :: raw :: c_char , strings : * const :: std :: os :: raw :: c_char , fn_ : * const :: std :: os :: raw :: c_char) -> root :: BOOL { match self . pointers . WritePrivateProfileSection { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WritePrivateProfileSection)) , Some (f) => f (appname , strings , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPrivateProfileSection (& self , appname : * const :: std :: os :: raw :: c_char , strout : * mut :: std :: os :: raw :: c_char , strout_len : root :: DWORD , fn_ : * const :: std :: os :: raw :: c_char) -> root :: DWORD { match self . pointers . GetPrivateProfileSection { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPrivateProfileSection)) , Some (f) => f (appname , strout , strout_len , fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetModuleFileName (& self , hInst : root :: HINSTANCE , fn_ : * mut :: std :: os :: raw :: c_char , nSize : root :: DWORD) -> root :: DWORD { match self . pointers . GetModuleFileName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetModuleFileName)) , Some (f) => f (hInst , fn_ , nSize) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_PtInRect (& self , r : * const root :: RECT , p : root :: POINT) -> root :: BOOL { match self . pointers . SWELL_PtInRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_PtInRect)) , Some (f) => f (r , p) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShellExecute (& self , hwndDlg : root :: HWND , action : * const :: std :: os :: raw :: c_char , content1 : * const :: std :: os :: raw :: c_char , content2 : * const :: std :: os :: raw :: c_char , content3 : * const :: std :: os :: raw :: c_char , blah : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . ShellExecute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ShellExecute)) , Some (f) => f (hwndDlg , action , content1 , content2 , content3 , blah) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MessageBox (& self , hwndParent : root :: HWND , text : * const :: std :: os :: raw :: c_char , caption : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MessageBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MessageBox)) , Some (f) => f (hwndParent , text , caption , type_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BrowseForFiles (& self , text : * const :: std :: os :: raw :: c_char , initialdir : * const :: std :: os :: raw :: c_char , initialfile : * const :: std :: os :: raw :: c_char , allowmul : bool , extlist : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char { match self . pointers . BrowseForFiles { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BrowseForFiles)) , Some (f) => f (text , initialdir , initialfile , allowmul , extlist) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BrowseForSaveFile (& self , text : * const :: std :: os :: raw :: c_char , initialdir : * const :: std :: os :: raw :: c_char , initialfile : * const :: std :: os :: raw :: c_char , extlist : * const :: std :: os :: raw :: c_char , fn_ : * mut :: std :: os :: raw :: c_char , fnsize : :: std :: os :: raw :: c_int) -> bool { match self . pointers . BrowseForSaveFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BrowseForSaveFile)) , Some (f) => f (text , initialdir , initialfile , extlist , fn_ , fnsize) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BrowseForDirectory (& self , text : * const :: std :: os :: raw :: c_char , initialdir : * const :: std :: os :: raw :: c_char , fn_ : * mut :: std :: os :: raw :: c_char , fnsize : :: std :: os :: raw :: c_int) -> bool { match self . pointers . BrowseForDirectory { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BrowseForDirectory)) , Some (f) => f (text , initialdir , fn_ , fnsize) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BrowseFile_SetTemplate (& self , dlgid : * const :: std :: os :: raw :: c_char , dlgProc : root :: DLGPROC , reshead : * mut root :: SWELL_DialogResourceIndex) { match self . pointers . BrowseFile_SetTemplate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BrowseFile_SetTemplate)) , Some (f) => f (dlgid , dlgProc , reshead) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDlgItem (& self , arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . GetDlgItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetDlgItem)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShowWindow (& self , arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) { match self . pointers . ShowWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ShowWindow)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DestroyWindow (& self , hwnd : root :: HWND) { match self . pointers . DestroyWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DestroyWindow)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetGestureInfo (& self , lParam : root :: LPARAM , gi : * mut root :: GESTUREINFO) -> root :: BOOL { match self . pointers . SWELL_GetGestureInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetGestureInfo)) , Some (f) => f (lParam , gi) , } } # [cfg (target_family = "unix")] pub fn SWELL_HideApp (& self) { match self . pointers . SWELL_HideApp { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_HideApp)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetDlgItemText (& self , arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , text : * const :: std :: os :: raw :: c_char) -> root :: BOOL { match self . pointers . SetDlgItemText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetDlgItemText)) , Some (f) => f (arg1 , idx , text) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetDlgItemInt (& self , arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int , issigned : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . SetDlgItemInt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetDlgItemInt)) , Some (f) => f (arg1 , idx , val , issigned) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDlgItemInt (& self , arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , translated : * mut root :: BOOL , issigned : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetDlgItemInt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetDlgItemInt)) , Some (f) => f (arg1 , idx , translated , issigned) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDlgItemText (& self , arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , text : * mut :: std :: os :: raw :: c_char , textlen : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . GetDlgItemText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetDlgItemText)) , Some (f) => f (arg1 , idx , text , textlen) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowTextLength (& self , arg1 : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . GetWindowTextLength { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetWindowTextLength)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CheckDlgButton (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , check : :: std :: os :: raw :: c_int) { match self . pointers . CheckDlgButton { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CheckDlgButton)) , Some (f) => f (hwnd , idx , check) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsDlgButtonChecked (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . IsDlgButtonChecked { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsDlgButtonChecked)) , Some (f) => f (hwnd , idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnableWindow (& self , hwnd : root :: HWND , enable : :: std :: os :: raw :: c_int) { match self . pointers . EnableWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnableWindow)) , Some (f) => f (hwnd , enable) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetFocus (& self , hwnd : root :: HWND) { match self . pointers . SetFocus { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetFocus)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] pub fn GetFocus (& self) -> root :: HWND { match self . pointers . GetFocus { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetFocus)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetForegroundWindow (& self , hwnd : root :: HWND) { match self . pointers . SetForegroundWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetForegroundWindow)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] pub fn GetForegroundWindow (& self) -> root :: HWND { match self . pointers . GetForegroundWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetForegroundWindow)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetCapture (& self , hwnd : root :: HWND) -> root :: HWND { match self . pointers . SetCapture { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetCapture)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] pub fn GetCapture (& self) -> root :: HWND { match self . pointers . GetCapture { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCapture)) , Some (f) => f () , } } # [cfg (target_family = "unix")] pub fn ReleaseCapture (& self) { match self . pointers . ReleaseCapture { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ReleaseCapture)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsChild (& self , hwndParent : root :: HWND , hwndChild : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . IsChild { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsChild)) , Some (f) => f (hwndParent , hwndChild) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetParent (& self , hwnd : root :: HWND) -> root :: HWND { match self . pointers . GetParent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetParent)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetParent (& self , hwnd : root :: HWND , newPar : root :: HWND) -> root :: HWND { match self . pointers . SetParent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetParent)) , Some (f) => f (hwnd , newPar) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindow (& self , hwnd : root :: HWND , what : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . GetWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetWindow)) , Some (f) => f (hwnd , what) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumWindows (& self , proc_ : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lp : root :: LPARAM) -> root :: BOOL { match self . pointers . EnumWindows { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumWindows)) , Some (f) => f (proc_ , lp) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn FindWindowEx (& self , par : root :: HWND , lastw : root :: HWND , classname : * const :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char) -> root :: HWND { match self . pointers . FindWindowEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (FindWindowEx)) , Some (f) => f (par , lastw , classname , title) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ClientToScreen (& self , hwnd : root :: HWND , p : * mut root :: POINT) { match self . pointers . ClientToScreen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ClientToScreen)) , Some (f) => f (hwnd , p) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ScreenToClient (& self , hwnd : root :: HWND , p : * mut root :: POINT) { match self . pointers . ScreenToClient { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ScreenToClient)) , Some (f) => f (hwnd , p) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowRect (& self , hwnd : root :: HWND , r : * mut root :: RECT) -> bool { match self . pointers . GetWindowRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetWindowRect)) , Some (f) => f (hwnd , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowContentViewRect (& self , hwnd : root :: HWND , r : * mut root :: RECT) { match self . pointers . GetWindowContentViewRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetWindowContentViewRect)) , Some (f) => f (hwnd , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetClientRect (& self , hwnd : root :: HWND , r : * mut root :: RECT) { match self . pointers . GetClientRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetClientRect)) , Some (f) => f (hwnd , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WindowFromPoint (& self , p : root :: POINT) -> root :: HWND { match self . pointers . WindowFromPoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WindowFromPoint)) , Some (f) => f (p) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WinOffsetRect (& self , lprc : root :: LPRECT , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . WinOffsetRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WinOffsetRect)) , Some (f) => f (lprc , dx , dy) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WinSetRect (& self , lprc : root :: LPRECT , xLeft : :: std :: os :: raw :: c_int , yTop : :: std :: os :: raw :: c_int , xRight : :: std :: os :: raw :: c_int , yBottom : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . WinSetRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WinSetRect)) , Some (f) => f (lprc , xLeft , yTop , xRight , yBottom) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WinUnionRect (& self , out : * mut root :: RECT , in1 : * const root :: RECT , in2 : * const root :: RECT) { match self . pointers . WinUnionRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WinUnionRect)) , Some (f) => f (out , in1 , in2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WinIntersectRect (& self , out : * mut root :: RECT , in1 : * const root :: RECT , in2 : * const root :: RECT) -> :: std :: os :: raw :: c_int { match self . pointers . WinIntersectRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WinIntersectRect)) , Some (f) => f (out , in1 , in2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetWindowPos (& self , hwnd : root :: HWND , unused : root :: HWND , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , cx : :: std :: os :: raw :: c_int , cy : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) { match self . pointers . SetWindowPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetWindowPos)) , Some (f) => f (hwnd , unused , x , y , cx , cy , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetWindowLevel (& self , hwnd : root :: HWND , newlevel : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_SetWindowLevel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetWindowLevel)) , Some (f) => f (hwnd , newlevel) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InvalidateRect (& self , hwnd : root :: HWND , r : * const root :: RECT , eraseBk : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . InvalidateRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InvalidateRect)) , Some (f) => f (hwnd , r , eraseBk) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn UpdateWindow (& self , hwnd : root :: HWND) { match self . pointers . UpdateWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (UpdateWindow)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowLong (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> root :: LONG_PTR { match self . pointers . GetWindowLong { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetWindowLong)) , Some (f) => f (hwnd , idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetWindowLong (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , val : root :: LONG_PTR) -> root :: LONG_PTR { match self . pointers . SetWindowLong { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetWindowLong)) , Some (f) => f (hwnd , idx , val) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ScrollWindow (& self , hwnd : root :: HWND , xamt : :: std :: os :: raw :: c_int , yamt : :: std :: os :: raw :: c_int , lpRect : * const root :: RECT , lpClipRect : * const root :: RECT) -> root :: BOOL { match self . pointers . ScrollWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ScrollWindow)) , Some (f) => f (hwnd , xamt , yamt , lpRect , lpClipRect) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumPropsEx (& self , arg1 : root :: HWND , arg2 : root :: PROPENUMPROCEX , arg3 : root :: LPARAM) -> :: std :: os :: raw :: c_int { match self . pointers . EnumPropsEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumPropsEx)) , Some (f) => f (arg1 , arg2 , arg3) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProp (& self , arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char) -> root :: HANDLE { match self . pointers . GetProp { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProp)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProp (& self , arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char , arg3 : root :: HANDLE) -> root :: BOOL { match self . pointers . SetProp { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProp)) , Some (f) => f (arg1 , arg2 , arg3) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn RemoveProp (& self , arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char) -> root :: HANDLE { match self . pointers . RemoveProp { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RemoveProp)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsWindowVisible (& self , hwnd : root :: HWND) -> bool { match self . pointers . IsWindowVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsWindowVisible)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsWindow (& self , hwnd : root :: HWND) -> bool { match self . pointers . IsWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsWindow)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTimer (& self , hwnd : root :: HWND , timerid : root :: UINT_PTR , rate : root :: UINT , tProc : root :: TIMERPROC) -> root :: UINT_PTR { match self . pointers . SetTimer { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTimer)) , Some (f) => f (hwnd , timerid , rate , tProc) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn KillTimer (& self , hwnd : root :: HWND , timerid : root :: UINT_PTR) -> root :: BOOL { match self . pointers . KillTimer { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (KillTimer)) , Some (f) => f (hwnd , timerid) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetExtendedListViewStyleEx (& self , h : root :: HWND , mask : :: std :: os :: raw :: c_int , style : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetExtendedListViewStyleEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetExtendedListViewStyleEx)) , Some (f) => f (h , mask , style) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_InsertColumn (& self , h : root :: HWND , pos : :: std :: os :: raw :: c_int , lvc : * const root :: LVCOLUMN) { match self . pointers . ListView_InsertColumn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_InsertColumn)) , Some (f) => f (h , pos , lvc) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_DeleteColumn (& self , h : root :: HWND , pos : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ListView_DeleteColumn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_DeleteColumn)) , Some (f) => f (h , pos) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetColumn (& self , h : root :: HWND , pos : :: std :: os :: raw :: c_int , lvc : * const root :: LVCOLUMN) { match self . pointers . ListView_SetColumn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetColumn)) , Some (f) => f (h , pos , lvc) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetColumnWidth (& self , h : root :: HWND , pos : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetColumnWidth { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetColumnWidth)) , Some (f) => f (h , pos) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_InsertItem (& self , h : root :: HWND , item : * const root :: LVITEM) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_InsertItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_InsertItem)) , Some (f) => f (h , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetItemText (& self , h : root :: HWND , ipos : :: std :: os :: raw :: c_int , cpos : :: std :: os :: raw :: c_int , txt : * const :: std :: os :: raw :: c_char) { match self . pointers . ListView_SetItemText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetItemText)) , Some (f) => f (h , ipos , cpos , txt) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetItem (& self , h : root :: HWND , item : * mut root :: LVITEM) -> bool { match self . pointers . ListView_SetItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetItem)) , Some (f) => f (h , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetNextItem (& self , h : root :: HWND , istart : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetNextItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetNextItem)) , Some (f) => f (h , istart , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetItem (& self , h : root :: HWND , item : * mut root :: LVITEM) -> bool { match self . pointers . ListView_GetItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetItem)) , Some (f) => f (h , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetItemState (& self , h : root :: HWND , ipos : :: std :: os :: raw :: c_int , mask : root :: UINT) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetItemState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetItemState)) , Some (f) => f (h , ipos , mask) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_DeleteItem (& self , h : root :: HWND , ipos : :: std :: os :: raw :: c_int) { match self . pointers . ListView_DeleteItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_DeleteItem)) , Some (f) => f (h , ipos) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_DeleteAllItems (& self , h : root :: HWND) { match self . pointers . ListView_DeleteAllItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_DeleteAllItems)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetSelectedCount (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetSelectedCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetSelectedCount)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetItemCount (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetItemCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetItemCount)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetSelectionMark (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetSelectionMark { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetSelectionMark)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetColumnWidth (& self , h : root :: HWND , colpos : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetColumnWidth { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetColumnWidth)) , Some (f) => f (h , colpos , wid) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetItemState (& self , h : root :: HWND , item : :: std :: os :: raw :: c_int , state : root :: UINT , statemask : root :: UINT) -> bool { match self . pointers . ListView_SetItemState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetItemState)) , Some (f) => f (h , item , state , statemask) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_RedrawItems (& self , h : root :: HWND , startitem : :: std :: os :: raw :: c_int , enditem : :: std :: os :: raw :: c_int) { match self . pointers . ListView_RedrawItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_RedrawItems)) , Some (f) => f (h , startitem , enditem) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetItemCount (& self , h : root :: HWND , cnt : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetItemCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetItemCount)) , Some (f) => f (h , cnt) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_EnsureVisible (& self , h : root :: HWND , i : :: std :: os :: raw :: c_int , pok : root :: BOOL) { match self . pointers . ListView_EnsureVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_EnsureVisible)) , Some (f) => f (h , i , pok) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetImageList (& self , h : root :: HWND , imagelist : root :: HIMAGELIST , which : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetImageList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetImageList)) , Some (f) => f (h , imagelist , which) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SubItemHitTest (& self , h : root :: HWND , pinf : * mut root :: LVHITTESTINFO) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_SubItemHitTest { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SubItemHitTest)) , Some (f) => f (h , pinf) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetItemText (& self , hwnd : root :: HWND , item : :: std :: os :: raw :: c_int , subitem : :: std :: os :: raw :: c_int , text : * mut :: std :: os :: raw :: c_char , textmax : :: std :: os :: raw :: c_int) { match self . pointers . ListView_GetItemText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetItemText)) , Some (f) => f (hwnd , item , subitem , text , textmax) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SortItems (& self , hwnd : root :: HWND , compf : root :: PFNLVCOMPARE , parm : root :: LPARAM) { match self . pointers . ListView_SortItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SortItems)) , Some (f) => f (hwnd , compf , parm) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_Scroll (& self , h : root :: HWND , xscroll : :: std :: os :: raw :: c_int , yscroll : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ListView_Scroll { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_Scroll)) , Some (f) => f (h , xscroll , yscroll) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetTopIndex (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetTopIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetTopIndex)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetCountPerPage (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_GetCountPerPage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetCountPerPage)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetColumnOrderArray (& self , h : root :: HWND , cnt : :: std :: os :: raw :: c_int , arr : * mut :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . ListView_SetColumnOrderArray { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetColumnOrderArray)) , Some (f) => f (h , cnt , arr) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetColumnOrderArray (& self , h : root :: HWND , cnt : :: std :: os :: raw :: c_int , arr : * mut :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . ListView_GetColumnOrderArray { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetColumnOrderArray)) , Some (f) => f (h , cnt , arr) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetHeader (& self , h : root :: HWND) -> root :: HWND { match self . pointers . ListView_GetHeader { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetHeader)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Header_GetItemCount (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . Header_GetItemCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Header_GetItemCount)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Header_GetItem (& self , h : root :: HWND , col : :: std :: os :: raw :: c_int , hi : * mut root :: HDITEM) -> root :: BOOL { match self . pointers . Header_GetItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Header_GetItem)) , Some (f) => f (h , col , hi) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Header_SetItem (& self , h : root :: HWND , col : :: std :: os :: raw :: c_int , hi : * mut root :: HDITEM) -> root :: BOOL { match self . pointers . Header_SetItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Header_SetItem)) , Some (f) => f (h , col , hi) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetItemRect (& self , h : root :: HWND , item : :: std :: os :: raw :: c_int , r : * mut root :: RECT , code : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ListView_GetItemRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetItemRect)) , Some (f) => f (h , item , r , code) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_GetSubItemRect (& self , h : root :: HWND , item : :: std :: os :: raw :: c_int , subitem : :: std :: os :: raw :: c_int , code : :: std :: os :: raw :: c_int , r : * mut root :: RECT) -> bool { match self . pointers . ListView_GetSubItemRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_GetSubItemRect)) , Some (f) => f (h , item , subitem , code , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_HitTest (& self , h : root :: HWND , pinf : * mut root :: LVHITTESTINFO) -> :: std :: os :: raw :: c_int { match self . pointers . ListView_HitTest { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_HitTest)) , Some (f) => f (h , pinf) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetListViewHeaderHeight (& self , h : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_GetListViewHeaderHeight { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetListViewHeaderHeight)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] pub fn ImageList_CreateEx (& self) -> root :: HIMAGELIST { match self . pointers . ImageList_CreateEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ImageList_CreateEx)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ImageList_Remove (& self , list : root :: HIMAGELIST , idx : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . ImageList_Remove { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ImageList_Remove)) , Some (f) => f (list , idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ImageList_ReplaceIcon (& self , list : root :: HIMAGELIST , offset : :: std :: os :: raw :: c_int , image : root :: HICON) -> :: std :: os :: raw :: c_int { match self . pointers . ImageList_ReplaceIcon { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ImageList_ReplaceIcon)) , Some (f) => f (list , offset , image) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ImageList_Add (& self , list : root :: HIMAGELIST , image : root :: HBITMAP , mask : root :: HBITMAP) -> :: std :: os :: raw :: c_int { match self . pointers . ImageList_Add { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ImageList_Add)) , Some (f) => f (list , image , mask) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ImageList_Destroy (& self , arg1 : root :: HIMAGELIST) { match self . pointers . ImageList_Destroy { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ImageList_Destroy)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TabCtrl_GetItemCount (& self , hwnd : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . TabCtrl_GetItemCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TabCtrl_GetItemCount)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TabCtrl_DeleteItem (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . TabCtrl_DeleteItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TabCtrl_DeleteItem)) , Some (f) => f (hwnd , idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TabCtrl_InsertItem (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , item : * mut root :: TCITEM) -> :: std :: os :: raw :: c_int { match self . pointers . TabCtrl_InsertItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TabCtrl_InsertItem)) , Some (f) => f (hwnd , idx , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TabCtrl_SetCurSel (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TabCtrl_SetCurSel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TabCtrl_SetCurSel)) , Some (f) => f (hwnd , idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TabCtrl_GetCurSel (& self , hwnd : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . TabCtrl_GetCurSel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TabCtrl_GetCurSel)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TabCtrl_AdjustRect (& self , hwnd : root :: HWND , fLarger : root :: BOOL , r : * mut root :: RECT) -> root :: BOOL { match self . pointers . TabCtrl_AdjustRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TabCtrl_AdjustRect)) , Some (f) => f (hwnd , fLarger , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_InsertItem (& self , hwnd : root :: HWND , ins : * mut root :: TV_INSERTSTRUCT) -> root :: HTREEITEM { match self . pointers . TreeView_InsertItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_InsertItem)) , Some (f) => f (hwnd , ins) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_Expand (& self , hwnd : root :: HWND , item : root :: HTREEITEM , flag : root :: UINT) -> root :: BOOL { match self . pointers . TreeView_Expand { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_Expand)) , Some (f) => f (hwnd , item , flag) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_GetSelection (& self , hwnd : root :: HWND) -> root :: HTREEITEM { match self . pointers . TreeView_GetSelection { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_GetSelection)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_DeleteItem (& self , hwnd : root :: HWND , item : root :: HTREEITEM) { match self . pointers . TreeView_DeleteItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_DeleteItem)) , Some (f) => f (hwnd , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_DeleteAllItems (& self , hwnd : root :: HWND) { match self . pointers . TreeView_DeleteAllItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_DeleteAllItems)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_SelectItem (& self , hwnd : root :: HWND , item : root :: HTREEITEM) { match self . pointers . TreeView_SelectItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_SelectItem)) , Some (f) => f (hwnd , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_EnsureVisible (& self , hwnd : root :: HWND , item : root :: HTREEITEM) { match self . pointers . TreeView_EnsureVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_EnsureVisible)) , Some (f) => f (hwnd , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_GetItem (& self , hwnd : root :: HWND , pitem : root :: LPTVITEM) -> root :: BOOL { match self . pointers . TreeView_GetItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_GetItem)) , Some (f) => f (hwnd , pitem) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_SetItem (& self , hwnd : root :: HWND , pitem : root :: LPTVITEM) -> root :: BOOL { match self . pointers . TreeView_SetItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_SetItem)) , Some (f) => f (hwnd , pitem) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_HitTest (& self , hwnd : root :: HWND , hti : * mut root :: TVHITTESTINFO) -> root :: HTREEITEM { match self . pointers . TreeView_HitTest { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_HitTest)) , Some (f) => f (hwnd , hti) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_SetIndent (& self , hwnd : root :: HWND , indent : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . TreeView_SetIndent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_SetIndent)) , Some (f) => f (hwnd , indent) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_GetParent (& self , hwnd : root :: HWND , item : root :: HTREEITEM) -> root :: HTREEITEM { match self . pointers . TreeView_GetParent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_GetParent)) , Some (f) => f (hwnd , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_GetChild (& self , hwnd : root :: HWND , item : root :: HTREEITEM) -> root :: HTREEITEM { match self . pointers . TreeView_GetChild { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_GetChild)) , Some (f) => f (hwnd , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_GetNextSibling (& self , hwnd : root :: HWND , item : root :: HTREEITEM) -> root :: HTREEITEM { match self . pointers . TreeView_GetNextSibling { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_GetNextSibling)) , Some (f) => f (hwnd , item) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_GetRoot (& self , hwnd : root :: HWND) -> root :: HTREEITEM { match self . pointers . TreeView_GetRoot { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_GetRoot)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_SetBkColor (& self , hwnd : root :: HWND , color : :: std :: os :: raw :: c_int) { match self . pointers . TreeView_SetBkColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_SetBkColor)) , Some (f) => f (hwnd , color) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TreeView_SetTextColor (& self , hwnd : root :: HWND , color : :: std :: os :: raw :: c_int) { match self . pointers . TreeView_SetTextColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TreeView_SetTextColor)) , Some (f) => f (hwnd , color) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetBkColor (& self , hwnd : root :: HWND , color : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetBkColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetBkColor)) , Some (f) => f (hwnd , color) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetTextBkColor (& self , hwnd : root :: HWND , color : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetTextBkColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetTextBkColor)) , Some (f) => f (hwnd , color) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetTextColor (& self , hwnd : root :: HWND , color : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetTextColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetTextColor)) , Some (f) => f (hwnd , color) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetGridColor (& self , hwnd : root :: HWND , color : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetGridColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetGridColor)) , Some (f) => f (hwnd , color) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ListView_SetSelColors (& self , hwnd : root :: HWND , colors : * mut :: std :: os :: raw :: c_int , ncolors : :: std :: os :: raw :: c_int) { match self . pointers . ListView_SetSelColors { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ListView_SetSelColors)) , Some (f) => f (hwnd , colors , ncolors) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ModalWindowStart (& self , hwnd : root :: HWND) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_ModalWindowStart { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ModalWindowStart)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ModalWindowRun (& self , ctx : * mut :: std :: os :: raw :: c_void , ret : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . SWELL_ModalWindowRun { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ModalWindowRun)) , Some (f) => f (ctx , ret) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ModalWindowEnd (& self , ctx : * mut :: std :: os :: raw :: c_void) { match self . pointers . SWELL_ModalWindowEnd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ModalWindowEnd)) , Some (f) => f (ctx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_CloseWindow (& self , hwnd : root :: HWND) { match self . pointers . SWELL_CloseWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CloseWindow)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] pub fn CreatePopupMenu (& self) -> root :: HMENU { match self . pointers . CreatePopupMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreatePopupMenu)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreatePopupMenuEx (& self , title : * const :: std :: os :: raw :: c_char) -> root :: HMENU { match self . pointers . CreatePopupMenuEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreatePopupMenuEx)) , Some (f) => f (title) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DestroyMenu (& self , hMenu : root :: HMENU) { match self . pointers . DestroyMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DestroyMenu)) , Some (f) => f (hMenu) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddMenuItem (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char , tagid : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . AddMenuItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddMenuItem)) , Some (f) => f (hMenu , pos , name , tagid) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSubMenu (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int) -> root :: HMENU { match self . pointers . GetSubMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSubMenu)) , Some (f) => f (hMenu , pos) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenuItemCount (& self , hMenu : root :: HMENU) -> :: std :: os :: raw :: c_int { match self . pointers . GetMenuItemCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMenuItemCount)) , Some (f) => f (hMenu) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenuItemID (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetMenuItemID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMenuItemID)) , Some (f) => f (hMenu , pos) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMenuItemModifier (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int , code : :: std :: os :: raw :: c_int , mask : :: std :: os :: raw :: c_uint) -> bool { match self . pointers . SetMenuItemModifier { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMenuItemModifier)) , Some (f) => f (hMenu , idx , flag , code , mask) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMenuItemText (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int , text : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . SetMenuItemText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMenuItemText)) , Some (f) => f (hMenu , idx , flag , text) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnableMenuItem (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , en : :: std :: os :: raw :: c_int) -> bool { match self . pointers . EnableMenuItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnableMenuItem)) , Some (f) => f (hMenu , idx , en) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteMenu (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DeleteMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteMenu)) , Some (f) => f (hMenu , idx , flag) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CheckMenuItem (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , chk : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CheckMenuItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CheckMenuItem)) , Some (f) => f (hMenu , idx , chk) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InsertMenuItem (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , byPos : root :: BOOL , mi : * mut root :: MENUITEMINFO) { match self . pointers . InsertMenuItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertMenuItem)) , Some (f) => f (hMenu , pos , byPos , mi) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_InsertMenu (& self , menu : root :: HMENU , pos : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_uint , idx : root :: UINT_PTR , str_ : * const :: std :: os :: raw :: c_char) { match self . pointers . SWELL_InsertMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_InsertMenu)) , Some (f) => f (menu , pos , flag , idx , str_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenuItemInfo (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , byPos : root :: BOOL , mi : * mut root :: MENUITEMINFO) -> root :: BOOL { match self . pointers . GetMenuItemInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMenuItemInfo)) , Some (f) => f (hMenu , pos , byPos , mi) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMenuItemInfo (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , byPos : root :: BOOL , mi : * mut root :: MENUITEMINFO) -> root :: BOOL { match self . pointers . SetMenuItemInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMenuItemInfo)) , Some (f) => f (hMenu , pos , byPos , mi) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DrawMenuBar (& self , arg1 : root :: HWND) { match self . pointers . DrawMenuBar { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DrawMenuBar)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_LoadMenu (& self , head : * mut root :: SWELL_MenuResourceIndex , resid : * const :: std :: os :: raw :: c_char) -> root :: HMENU { match self . pointers . SWELL_LoadMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_LoadMenu)) , Some (f) => f (head , resid) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackPopupMenu (& self , hMenu : root :: HMENU , flags : :: std :: os :: raw :: c_int , xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int , resvd : :: std :: os :: raw :: c_int , hwnd : root :: HWND , r : * const root :: RECT) -> :: std :: os :: raw :: c_int { match self . pointers . TrackPopupMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackPopupMenu)) , Some (f) => f (hMenu , flags , xpos , ypos , resvd , hwnd , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetMenuDestination (& self , menu : root :: HMENU , hwnd : root :: HWND) { match self . pointers . SWELL_SetMenuDestination { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetMenuDestination)) , Some (f) => f (menu , hwnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_DuplicateMenu (& self , menu : root :: HMENU) -> root :: HMENU { match self . pointers . SWELL_DuplicateMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_DuplicateMenu)) , Some (f) => f (menu) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMenu (& self , hwnd : root :: HWND , menu : root :: HMENU) -> root :: BOOL { match self . pointers . SetMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMenu)) , Some (f) => f (hwnd , menu) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenu (& self , hwnd : root :: HWND) -> root :: HMENU { match self . pointers . GetMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMenu)) , Some (f) => f (hwnd) , } } # [cfg (target_family = "unix")] pub fn SWELL_GetDefaultWindowMenu (& self) -> root :: HMENU { match self . pointers . SWELL_GetDefaultWindowMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetDefaultWindowMenu)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetDefaultWindowMenu (& self , arg1 : root :: HMENU) { match self . pointers . SWELL_SetDefaultWindowMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetDefaultWindowMenu)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] pub fn SWELL_GetDefaultModalWindowMenu (& self) -> root :: HMENU { match self . pointers . SWELL_GetDefaultModalWindowMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetDefaultModalWindowMenu)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetDefaultModalWindowMenu (& self , arg1 : root :: HMENU) { match self . pointers . SWELL_SetDefaultModalWindowMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetDefaultModalWindowMenu)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] pub fn SWELL_GetCurrentMenu (& self) -> root :: HMENU { match self . pointers . SWELL_GetCurrentMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetCurrentMenu)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetCurrentMenu (& self , arg1 : root :: HMENU) { match self . pointers . SWELL_SetCurrentMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetCurrentMenu)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_DialogBox (& self , reshead : * mut root :: SWELL_DialogResourceIndex , resid : * const :: std :: os :: raw :: c_char , parent : root :: HWND , dlgproc : root :: DLGPROC , param : root :: LPARAM) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_DialogBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_DialogBox)) , Some (f) => f (reshead , resid , parent , dlgproc , param) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_CreateDialog (& self , reshead : * mut root :: SWELL_DialogResourceIndex , resid : * const :: std :: os :: raw :: c_char , parent : root :: HWND , dlgproc : root :: DLGPROC , param : root :: LPARAM) -> root :: HWND { match self . pointers . SWELL_CreateDialog { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CreateDialog)) , Some (f) => f (reshead , resid , parent , dlgproc , param) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_RegisterCustomControlCreator (& self , proc_ : root :: SWELL_ControlCreatorProc) { match self . pointers . SWELL_RegisterCustomControlCreator { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_RegisterCustomControlCreator)) , Some (f) => f (proc_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_UnregisterCustomControlCreator (& self , proc_ : root :: SWELL_ControlCreatorProc) { match self . pointers . SWELL_UnregisterCustomControlCreator { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_UnregisterCustomControlCreator)) , Some (f) => f (proc_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DefWindowProc (& self , hwnd : root :: HWND , msg : root :: UINT , wParam : root :: WPARAM , lParam : root :: LPARAM) -> root :: LRESULT { match self . pointers . DefWindowProc { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DefWindowProc)) , Some (f) => f (hwnd , msg , wParam , lParam) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EndDialog (& self , arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) { match self . pointers . EndDialog { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EndDialog)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetDefaultButtonID (& self , hwndDlg : root :: HWND , onlyIfEnabled : bool) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_GetDefaultButtonID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetDefaultButtonID)) , Some (f) => f (hwndDlg , onlyIfEnabled) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SendMessage (& self , arg1 : root :: HWND , arg2 : root :: UINT , arg3 : root :: WPARAM , arg4 : root :: LPARAM) -> root :: LRESULT { match self . pointers . SendMessage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SendMessage)) , Some (f) => f (arg1 , arg2 , arg3 , arg4) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_BroadcastMessage (& self , arg1 : root :: UINT , arg2 : root :: WPARAM , arg3 : root :: LPARAM) { match self . pointers . SWELL_BroadcastMessage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_BroadcastMessage)) , Some (f) => f (arg1 , arg2 , arg3) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PostMessage (& self , hwnd : root :: HWND , msg : root :: UINT , wParam : root :: WPARAM , lParam : root :: LPARAM) -> root :: BOOL { match self . pointers . PostMessage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PostMessage)) , Some (f) => f (hwnd , msg , wParam , lParam) , } } # [cfg (target_family = "unix")] pub fn SWELL_MessageQueue_Flush (& self) { match self . pointers . SWELL_MessageQueue_Flush { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MessageQueue_Flush)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MessageQueue_Clear (& self , h : root :: HWND) { match self . pointers . SWELL_MessageQueue_Clear { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MessageQueue_Clear)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_KeyToASCII (& self , wParam : :: std :: os :: raw :: c_int , lParam : :: std :: os :: raw :: c_int , newflags : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_KeyToASCII { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_KeyToASCII)) , Some (f) => f (wParam , lParam , newflags) , } } # [cfg (target_family = "unix")] pub fn GetAsyncKeyState (& self , key : :: std :: os :: raw :: c_int) -> root :: WORD { match self . pointers . GetAsyncKeyState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAsyncKeyState)) , Some (f) => f (key) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetCursorPos (& self , pt : * mut root :: POINT) { match self . pointers . GetCursorPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCursorPos)) , Some (f) => f (pt) , } } # [cfg (target_family = "unix")] pub fn GetMessagePos (& self) -> root :: DWORD { match self . pointers . GetMessagePos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMessagePos)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_LoadCursor (& self , idx : * const :: std :: os :: raw :: c_char) -> root :: HCURSOR { match self . pointers . SWELL_LoadCursor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_LoadCursor)) , Some (f) => f (idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetCursor (& self , curs : root :: HCURSOR) { match self . pointers . SWELL_SetCursor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetCursor)) , Some (f) => f (curs) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_EnableRightClickEmulate (& self , enable : root :: BOOL) { match self . pointers . SWELL_EnableRightClickEmulate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_EnableRightClickEmulate)) , Some (f) => f (enable) , } } # [cfg (target_family = "unix")] pub fn SWELL_GetCursor (& self) -> root :: HCURSOR { match self . pointers . SWELL_GetCursor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetCursor)) , Some (f) => f () , } } # [cfg (target_family = "unix")] pub fn SWELL_GetLastSetCursor (& self) -> root :: HCURSOR { match self . pointers . SWELL_GetLastSetCursor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetLastSetCursor)) , Some (f) => f () , } } # [cfg (target_family = "unix")] pub fn SWELL_IsCursorVisible (& self) -> bool { match self . pointers . SWELL_IsCursorVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_IsCursorVisible)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ShowCursor (& self , bShow : root :: BOOL) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_ShowCursor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ShowCursor)) , Some (f) => f (bShow) , } } # [cfg (target_family = "unix")] pub fn SWELL_SetCursorPos (& self , X : :: std :: os :: raw :: c_int , Y : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . SWELL_SetCursorPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetCursorPos)) , Some (f) => f (X , Y) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetViewPort (& self , r : * mut root :: RECT , sourcerect : * const root :: RECT , wantWork : bool) { match self . pointers . SWELL_GetViewPort { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetViewPort)) , Some (f) => f (r , sourcerect , wantWork) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OpenClipboard (& self , hwndDlg : root :: HWND) -> bool { match self . pointers . OpenClipboard { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OpenClipboard)) , Some (f) => f (hwndDlg) , } } # [cfg (target_family = "unix")] pub fn CloseClipboard (& self) { match self . pointers . CloseClipboard { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CloseClipboard)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetClipboardData (& self , type_ : root :: UINT) -> root :: HANDLE { match self . pointers . GetClipboardData { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetClipboardData)) , Some (f) => f (type_) , } } # [cfg (target_family = "unix")] pub fn EmptyClipboard (& self) { match self . pointers . EmptyClipboard { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EmptyClipboard)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetClipboardData (& self , type_ : root :: UINT , h : root :: HANDLE) { match self . pointers . SetClipboardData { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetClipboardData)) , Some (f) => f (type_ , h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn RegisterClipboardFormat (& self , desc : * const :: std :: os :: raw :: c_char) -> root :: UINT { match self . pointers . RegisterClipboardFormat { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RegisterClipboardFormat)) , Some (f) => f (desc) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumClipboardFormats (& self , lastfmt : root :: UINT) -> root :: UINT { match self . pointers . EnumClipboardFormats { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumClipboardFormats)) , Some (f) => f (lastfmt) , } } # [cfg (target_family = "unix")] pub fn GlobalAlloc (& self , flags : :: std :: os :: raw :: c_int , sz : :: std :: os :: raw :: c_int) -> root :: HANDLE { match self . pointers . GlobalAlloc { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GlobalAlloc)) , Some (f) => f (flags , sz) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GlobalLock (& self , h : root :: HANDLE) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GlobalLock { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GlobalLock)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GlobalSize (& self , h : root :: HANDLE) -> :: std :: os :: raw :: c_int { match self . pointers . GlobalSize { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GlobalSize)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GlobalUnlock (& self , h : root :: HANDLE) { match self . pointers . GlobalUnlock { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GlobalUnlock)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GlobalFree (& self , h : root :: HANDLE) { match self . pointers . GlobalFree { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GlobalFree)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateThread (& self , TA : * mut :: std :: os :: raw :: c_void , stackSize : root :: DWORD , ThreadProc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: LPVOID ,) -> root :: DWORD , > , parm : root :: LPVOID , cf : root :: DWORD , tidOut : * mut root :: DWORD) -> root :: HANDLE { match self . pointers . CreateThread { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateThread)) , Some (f) => f (TA , stackSize , ThreadProc , parm , cf , tidOut) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateEvent (& self , SA : * mut :: std :: os :: raw :: c_void , manualReset : root :: BOOL , initialSig : root :: BOOL , ignored : * const :: std :: os :: raw :: c_char) -> root :: HANDLE { match self . pointers . CreateEvent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateEvent)) , Some (f) => f (SA , manualReset , initialSig , ignored) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateEventAsSocket (& self , SA : * mut :: std :: os :: raw :: c_void , manualReset : root :: BOOL , initialSig : root :: BOOL , ignored : * const :: std :: os :: raw :: c_char) -> root :: HANDLE { match self . pointers . CreateEventAsSocket { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateEventAsSocket)) , Some (f) => f (SA , manualReset , initialSig , ignored) , } } # [cfg (target_family = "unix")] pub fn GetCurrentThreadId (& self) -> root :: DWORD { match self . pointers . GetCurrentThreadId { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCurrentThreadId)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WaitForSingleObject (& self , hand : root :: HANDLE , msTO : root :: DWORD) -> root :: DWORD { match self . pointers . WaitForSingleObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WaitForSingleObject)) , Some (f) => f (hand , msTO) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WaitForAnySocketObject (& self , numObjs : :: std :: os :: raw :: c_int , objs : * mut root :: HANDLE , msTO : root :: DWORD) -> root :: DWORD { match self . pointers . WaitForAnySocketObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WaitForAnySocketObject)) , Some (f) => f (numObjs , objs , msTO) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CloseHandle (& self , hand : root :: HANDLE) -> root :: BOOL { match self . pointers . CloseHandle { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CloseHandle)) , Some (f) => f (hand) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetThreadPriority (& self , evt : root :: HANDLE , prio : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . SetThreadPriority { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetThreadPriority)) , Some (f) => f (evt , prio) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetEvent (& self , evt : root :: HANDLE) -> root :: BOOL { match self . pointers . SetEvent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetEvent)) , Some (f) => f (evt) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ResetEvent (& self , evt : root :: HANDLE) -> root :: BOOL { match self . pointers . ResetEvent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ResetEvent)) , Some (f) => f (evt) , } } # [cfg (target_family = "unix")] pub fn SWELL_CreateProcessFromPID (& self , pid : :: std :: os :: raw :: c_int) -> root :: HANDLE { match self . pointers . SWELL_CreateProcessFromPID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CreateProcessFromPID)) , Some (f) => f (pid) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_CreateProcess (& self , exe : * const :: std :: os :: raw :: c_char , nparams : :: std :: os :: raw :: c_int , params : * mut * const :: std :: os :: raw :: c_char) -> root :: HANDLE { match self . pointers . SWELL_CreateProcess { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CreateProcess)) , Some (f) => f (exe , nparams , params) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetProcessExitCode (& self , hand : root :: HANDLE) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_GetProcessExitCode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetProcessExitCode)) , Some (f) => f (hand) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LoadLibraryGlobals (& self , fileName : * const :: std :: os :: raw :: c_char , symbolsAsGlobals : bool) -> root :: HINSTANCE { match self . pointers . LoadLibraryGlobals { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LoadLibraryGlobals)) , Some (f) => f (fileName , symbolsAsGlobals) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LoadLibrary (& self , fileName : * const :: std :: os :: raw :: c_char) -> root :: HINSTANCE { match self . pointers . LoadLibrary { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LoadLibrary)) , Some (f) => f (fileName) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProcAddress (& self , hInst : root :: HINSTANCE , procName : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetProcAddress { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProcAddress)) , Some (f) => f (hInst , procName) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn FreeLibrary (& self , hInst : root :: HINSTANCE) -> root :: BOOL { match self . pointers . FreeLibrary { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (FreeLibrary)) , Some (f) => f (hInst) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetBundle (& self , hInst : root :: HINSTANCE) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_GetBundle { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetBundle)) , Some (f) => f (hInst) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_CreateMemContext (& self , hdc : root :: HDC , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int) -> root :: HDC { match self . pointers . SWELL_CreateMemContext { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CreateMemContext)) , Some (f) => f (hdc , w , h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_DeleteGfxContext (& self , arg1 : root :: HDC) { match self . pointers . SWELL_DeleteGfxContext { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_DeleteGfxContext)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetCtxGC (& self , ctx : root :: HDC) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_GetCtxGC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetCtxGC)) , Some (f) => f (ctx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetCtxFrameBuffer (& self , ctx : root :: HDC) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_GetCtxFrameBuffer { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetCtxFrameBuffer)) , Some (f) => f (ctx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_PushClipRegion (& self , ctx : root :: HDC) { match self . pointers . SWELL_PushClipRegion { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_PushClipRegion)) , Some (f) => f (ctx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetClipRegion (& self , ctx : root :: HDC , r : * const root :: RECT) { match self . pointers . SWELL_SetClipRegion { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetClipRegion)) , Some (f) => f (ctx , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_PopClipRegion (& self , ctx : root :: HDC) { match self . pointers . SWELL_PopClipRegion { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_PopClipRegion)) , Some (f) => f (ctx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateFontIndirect (& self , arg1 : * mut root :: LOGFONT) -> root :: HFONT { match self . pointers . CreateFontIndirect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateFontIndirect)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateFont (& self , lfHeight : :: std :: os :: raw :: c_int , lfWidth : :: std :: os :: raw :: c_int , lfEscapement : :: std :: os :: raw :: c_int , lfOrientation : :: std :: os :: raw :: c_int , lfWeight : :: std :: os :: raw :: c_int , lfItalic : :: std :: os :: raw :: c_char , lfUnderline : :: std :: os :: raw :: c_char , lfStrikeOut : :: std :: os :: raw :: c_char , lfCharSet : :: std :: os :: raw :: c_char , lfOutPrecision : :: std :: os :: raw :: c_char , lfClipPrecision : :: std :: os :: raw :: c_char , lfQuality : :: std :: os :: raw :: c_char , lfPitchAndFamily : :: std :: os :: raw :: c_char , lfFaceName : * const :: std :: os :: raw :: c_char) -> root :: HFONT { match self . pointers . CreateFont { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateFont)) , Some (f) => f (lfHeight , lfWidth , lfEscapement , lfOrientation , lfWeight , lfItalic , lfUnderline , lfStrikeOut , lfCharSet , lfOutPrecision , lfClipPrecision , lfQuality , lfPitchAndFamily , lfFaceName) , } } # [cfg (target_family = "unix")] pub fn CreatePen (& self , attr : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int) -> root :: HPEN { match self . pointers . CreatePen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreatePen)) , Some (f) => f (attr , wid , col) , } } # [cfg (target_family = "unix")] pub fn CreateSolidBrush (& self , col : :: std :: os :: raw :: c_int) -> root :: HBRUSH { match self . pointers . CreateSolidBrush { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateSolidBrush)) , Some (f) => f (col) , } } # [cfg (target_family = "unix")] pub fn CreatePenAlpha (& self , attr : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , alpha : f32) -> root :: HPEN { match self . pointers . CreatePenAlpha { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreatePenAlpha)) , Some (f) => f (attr , wid , col , alpha) , } } # [cfg (target_family = "unix")] pub fn CreateSolidBrushAlpha (& self , col : :: std :: os :: raw :: c_int , alpha : f32) -> root :: HBRUSH { match self . pointers . CreateSolidBrushAlpha { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateSolidBrushAlpha)) , Some (f) => f (col , alpha) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SelectObject (& self , ctx : root :: HDC , pen : root :: HGDIOBJ) -> root :: HGDIOBJ { match self . pointers . SelectObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SelectObject)) , Some (f) => f (ctx , pen) , } } # [cfg (target_family = "unix")] pub fn GetStockObject (& self , wh : :: std :: os :: raw :: c_int) -> root :: HGDIOBJ { match self . pointers . GetStockObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetStockObject)) , Some (f) => f (wh) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteObject (& self , arg1 : root :: HGDIOBJ) { match self . pointers . DeleteObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteObject)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_FillRect (& self , ctx : root :: HDC , r : * const root :: RECT , br : root :: HBRUSH) { match self . pointers . SWELL_FillRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_FillRect)) , Some (f) => f (ctx , r , br) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Rectangle (& self , ctx : root :: HDC , l : :: std :: os :: raw :: c_int , t : :: std :: os :: raw :: c_int , r : :: std :: os :: raw :: c_int , b : :: std :: os :: raw :: c_int) { match self . pointers . Rectangle { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Rectangle)) , Some (f) => f (ctx , l , t , r , b) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Ellipse (& self , ctx : root :: HDC , l : :: std :: os :: raw :: c_int , t : :: std :: os :: raw :: c_int , r : :: std :: os :: raw :: c_int , b : :: std :: os :: raw :: c_int) { match self . pointers . Ellipse { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Ellipse)) , Some (f) => f (ctx , l , t , r , b) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_Polygon (& self , ctx : root :: HDC , pts : * mut root :: POINT , npts : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_Polygon { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_Polygon)) , Some (f) => f (ctx , pts , npts) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MoveToEx (& self , ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , op : * mut root :: POINT) { match self . pointers . MoveToEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MoveToEx)) , Some (f) => f (ctx , x , y , op) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_LineTo (& self , ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_LineTo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_LineTo)) , Some (f) => f (ctx , x , y) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetPixel (& self , ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , c : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_SetPixel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetPixel)) , Some (f) => f (ctx , x , y , c) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PolyBezierTo (& self , ctx : root :: HDC , pts : * mut root :: POINT , np : :: std :: os :: raw :: c_int) { match self . pointers . PolyBezierTo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PolyBezierTo)) , Some (f) => f (ctx , pts , np) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_DrawText (& self , ctx : root :: HDC , buf : * const :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , r : * mut root :: RECT , align : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_DrawText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_DrawText)) , Some (f) => f (ctx , buf , len , r , align) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTextColor (& self , ctx : root :: HDC , col : :: std :: os :: raw :: c_int) { match self . pointers . SetTextColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTextColor)) , Some (f) => f (ctx , col) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTextColor (& self , ctx : root :: HDC) -> :: std :: os :: raw :: c_int { match self . pointers . GetTextColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTextColor)) , Some (f) => f (ctx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetBkColor (& self , ctx : root :: HDC , col : :: std :: os :: raw :: c_int) { match self . pointers . SetBkColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetBkColor)) , Some (f) => f (ctx , col) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetBkMode (& self , ctx : root :: HDC , col : :: std :: os :: raw :: c_int) { match self . pointers . SetBkMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetBkMode)) , Some (f) => f (ctx , col) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetGlyphIndicesW (& self , ctx : root :: HDC , buf : * mut u32 , len : :: std :: os :: raw :: c_int , indices : * mut :: std :: os :: raw :: c_ushort , flags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetGlyphIndicesW { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetGlyphIndicesW)) , Some (f) => f (ctx , buf , len , indices , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn RoundRect (& self , ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , x2 : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , xrnd : :: std :: os :: raw :: c_int , yrnd : :: std :: os :: raw :: c_int) { match self . pointers . RoundRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RoundRect)) , Some (f) => f (ctx , x , y , x2 , y2 , xrnd , yrnd) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PolyPolyline (& self , ctx : root :: HDC , pts : * mut root :: POINT , cnts : * mut root :: DWORD , nseg : :: std :: os :: raw :: c_int) { match self . pointers . PolyPolyline { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PolyPolyline)) , Some (f) => f (ctx , pts , cnts , nseg) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTextMetrics (& self , ctx : root :: HDC , tm : * mut root :: TEXTMETRIC) -> root :: BOOL { match self . pointers . GetTextMetrics { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTextMetrics)) , Some (f) => f (ctx , tm) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTextFace (& self , ctx : root :: HDC , nCount : :: std :: os :: raw :: c_int , lpFaceName : root :: LPTSTR) -> :: std :: os :: raw :: c_int { match self . pointers . GetTextFace { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTextFace)) , Some (f) => f (ctx , nCount , lpFaceName) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetObject (& self , icon : root :: HICON , bmsz : :: std :: os :: raw :: c_int , _bm : * mut :: std :: os :: raw :: c_void) -> root :: BOOL { match self . pointers . GetObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetObject)) , Some (f) => f (icon , bmsz , _bm) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateIconIndirect (& self , iconinfo : * mut root :: ICONINFO) -> root :: HICON { match self . pointers . CreateIconIndirect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateIconIndirect)) , Some (f) => f (iconinfo) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LoadNamedImage (& self , name : * const :: std :: os :: raw :: c_char , alphaFromMask : bool) -> root :: HICON { match self . pointers . LoadNamedImage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LoadNamedImage)) , Some (f) => f (name , alphaFromMask) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DrawImageInRect (& self , ctx : root :: HDC , img : root :: HICON , r : * const root :: RECT) { match self . pointers . DrawImageInRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DrawImageInRect)) , Some (f) => f (ctx , img , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BitBlt (& self , hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) { match self . pointers . BitBlt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BitBlt)) , Some (f) => f (hdcOut , x , y , w , h , hdcIn , xin , yin , mode) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn StretchBlt (& self , hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) { match self . pointers . StretchBlt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (StretchBlt)) , Some (f) => f (hdcOut , x , y , w , h , hdcIn , xin , yin , srcw , srch , mode) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn StretchBltFromMem (& self , hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , bits : * const :: std :: os :: raw :: c_void , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , srcspan : :: std :: os :: raw :: c_int) { match self . pointers . StretchBltFromMem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (StretchBltFromMem)) , Some (f) => f (hdcOut , x , y , w , h , bits , srcw , srch , srcspan) , } } # [cfg (target_family = "unix")] pub fn SWELL_GetScaling256 (& self) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_GetScaling256 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetScaling256)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ExtendedAPI (& self , key : * const :: std :: os :: raw :: c_char , v : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_ExtendedAPI { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ExtendedAPI)) , Some (f) => f (key , v) , } } # [cfg (target_family = "unix")] pub fn GetSysColor (& self , idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetSysColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSysColor)) , Some (f) => f (idx) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateBitmap (& self , width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , numplanes : :: std :: os :: raw :: c_int , bitsperpixel : :: std :: os :: raw :: c_int , bits : * mut :: std :: os :: raw :: c_uchar) -> root :: HBITMAP { match self . pointers . CreateBitmap { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateBitmap)) , Some (f) => f (width , height , numplanes , bitsperpixel , bits) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetOpaque (& self , h : root :: HWND , isopaque : bool) { match self . pointers . SetOpaque { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetOpaque)) , Some (f) => f (h , isopaque) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetAllowNoMiddleManRendering (& self , h : root :: HWND , allow : bool) { match self . pointers . SetAllowNoMiddleManRendering { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetAllowNoMiddleManRendering)) , Some (f) => f (h , allow) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetViewGL (& self , h : root :: HWND , wantGL : :: std :: os :: raw :: c_char) { match self . pointers . SWELL_SetViewGL { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetViewGL)) , Some (f) => f (h , wantGL) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetViewGL (& self , h : root :: HWND) -> bool { match self . pointers . SWELL_GetViewGL { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetViewGL)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetGLContextToView (& self , h : root :: HWND) -> bool { match self . pointers . SWELL_SetGLContextToView { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetGLContextToView)) , Some (f) => f (h) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BeginPaint (& self , arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT) -> root :: HDC { match self . pointers . BeginPaint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BeginPaint)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EndPaint (& self , arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT) -> root :: BOOL { match self . pointers . EndPaint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EndPaint)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDC (& self , arg1 : root :: HWND) -> root :: HDC { match self . pointers . GetDC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetDC)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowDC (& self , arg1 : root :: HWND) -> root :: HDC { match self . pointers . GetWindowDC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetWindowDC)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ReleaseDC (& self , arg1 : root :: HWND , arg2 : root :: HDC) { match self . pointers . ReleaseDC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ReleaseDC)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_FillDialogBackground (& self , hdc : root :: HDC , r : * const root :: RECT , level : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_FillDialogBackground { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_FillDialogBackground)) , Some (f) => f (hdc , r , level) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_CloneGDIObject (& self , a : root :: HGDIOBJ) -> root :: HGDIOBJ { match self . pointers . SWELL_CloneGDIObject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CloneGDIObject)) , Some (f) => f (a) , } } # [cfg (target_family = "unix")] pub fn GetSystemMetrics (& self , arg1 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetSystemMetrics { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSystemMetrics)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DragQueryPoint (& self , arg1 : root :: HDROP , arg2 : root :: LPPOINT) -> root :: BOOL { match self . pointers . DragQueryPoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DragQueryPoint)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DragFinish (& self , arg1 : root :: HDROP) { match self . pointers . DragFinish { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DragFinish)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DragQueryFile (& self , arg1 : root :: HDROP , arg2 : root :: UINT , arg3 : * mut :: std :: os :: raw :: c_char , arg4 : root :: UINT) -> root :: UINT { match self . pointers . DragQueryFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DragQueryFile)) , Some (f) => f (arg1 , arg2 , arg3 , arg4) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_InitiateDragDrop (& self , arg1 : root :: HWND , srcrect : * mut root :: RECT , srcfn : * const :: std :: os :: raw :: c_char , callback : :: std :: option :: Option < unsafe extern "C" fn (droppath : * const :: std :: os :: raw :: c_char ,) , >) { match self . pointers . SWELL_InitiateDragDrop { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_InitiateDragDrop)) , Some (f) => f (arg1 , srcrect , srcfn , callback) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_InitiateDragDropOfFileList (& self , arg1 : root :: HWND , srcrect : * mut root :: RECT , srclist : * mut * const :: std :: os :: raw :: c_char , srccount : :: std :: os :: raw :: c_int , icon : root :: HICON) { match self . pointers . SWELL_InitiateDragDropOfFileList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_InitiateDragDropOfFileList)) , Some (f) => f (arg1 , srcrect , srclist , srccount , icon) , } } # [cfg (target_family = "unix")] pub fn SWELL_FinishDragDrop (& self) { match self . pointers . SWELL_FinishDragDrop { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_FinishDragDrop)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_DrawFocusRect (& self , hwndPar : root :: HWND , rct : * mut root :: RECT , handle : * mut * mut :: std :: os :: raw :: c_void) { match self . pointers . SWELL_DrawFocusRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_DrawFocusRect)) , Some (f) => f (hwndPar , rct , handle) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MakeSetCurParms (& self , xscale : f32 , yscale : f32 , xtrans : f32 , ytrans : f32 , parent : root :: HWND , doauto : bool , dosizetofit : bool) { match self . pointers . SWELL_MakeSetCurParms { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeSetCurParms)) , Some (f) => f (xscale , yscale , xtrans , ytrans , parent , doauto , dosizetofit) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MakeButton (& self , def : :: std :: os :: raw :: c_int , label : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeButton { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeButton)) , Some (f) => f (def , label , idx , x , y , w , h , flags) , } } # [cfg (target_family = "unix")] pub fn SWELL_MakeEditField (& self , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeEditField { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeEditField)) , Some (f) => f (idx , x , y , w , h , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MakeLabel (& self , align : :: std :: os :: raw :: c_int , label : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeLabel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeLabel)) , Some (f) => f (align , label , idx , x , y , w , h , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MakeControl (& self , cname : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , classname : * const :: std :: os :: raw :: c_char , style : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , exstyle : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeControl { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeControl)) , Some (f) => f (cname , idx , classname , style , x , y , w , h , exstyle) , } } # [cfg (target_family = "unix")] pub fn SWELL_MakeCombo (& self , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeCombo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeCombo)) , Some (f) => f (idx , x , y , w , h , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MakeGroupBox (& self , name : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , style : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeGroupBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeGroupBox)) , Some (f) => f (name , idx , x , y , w , h , style) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_MakeCheckBox (& self , name : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeCheckBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeCheckBox)) , Some (f) => f (name , idx , x , y , w , h , flags) , } } # [cfg (target_family = "unix")] pub fn SWELL_MakeListBox (& self , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , styles : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . SWELL_MakeListBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_MakeListBox)) , Some (f) => f (idx , x , y , w , h , styles) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_Menu_AddMenuItem (& self , hMenu : root :: HMENU , name : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_uint) { match self . pointers . SWELL_Menu_AddMenuItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_Menu_AddMenuItem)) , Some (f) => f (hMenu , name , idx , flags) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GenerateMenuFromList (& self , hMenu : root :: HMENU , list : * const :: std :: os :: raw :: c_void , listsz : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_GenerateMenuFromList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GenerateMenuFromList)) , Some (f) => f (hMenu , list , listsz) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GenerateDialogFromList (& self , list : * const :: std :: os :: raw :: c_void , listsz : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_GenerateDialogFromList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GenerateDialogFromList)) , Some (f) => f (list , listsz) , } } # [cfg (target_family = "unix")] pub fn _controlfp (& self , flag : :: std :: os :: raw :: c_uint , mask : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint { match self . pointers . _controlfp { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (_controlfp)) , Some (f) => f (flag , mask) , } } # [cfg (target_family = "unix")] pub fn SWELL_Internal_PostMessage_Init (& self) { match self . pointers . SWELL_Internal_PostMessage_Init { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_Internal_PostMessage_Init)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_LoadCursorFromFile (& self , fn_ : * const :: std :: os :: raw :: c_char) -> root :: HCURSOR { match self . pointers . SWELL_LoadCursorFromFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_LoadCursorFromFile)) , Some (f) => f (fn_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetWindowWantRaiseAmt (& self , h : root :: HWND , amt : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_SetWindowWantRaiseAmt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetWindowWantRaiseAmt)) , Some (f) => f (h , amt) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetWindowWantRaiseAmt (& self , arg1 : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . SWELL_GetWindowWantRaiseAmt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetWindowWantRaiseAmt)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetListViewFastClickMask (& self , hList : root :: HWND , mask : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_SetListViewFastClickMask { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetListViewFastClickMask)) , Some (f) => f (hList , mask) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTempPath (& self , sz : :: std :: os :: raw :: c_int , buf : * mut :: std :: os :: raw :: c_char) { match self . pointers . GetTempPath { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTempPath)) , Some (f) => f (sz , buf) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_initargs (& self , argc : * mut :: std :: os :: raw :: c_int , argv : * mut * mut * mut :: std :: os :: raw :: c_char) { match self . pointers . SWELL_initargs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_initargs)) , Some (f) => f (argc , argv) , } } # [cfg (target_family = "unix")] pub fn SWELL_RunMessageLoop (& self) { match self . pointers . SWELL_RunMessageLoop { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_RunMessageLoop)) , Some (f) => f () , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_CreateXBridgeWindow (& self , viewpar : root :: HWND , wref : * mut * mut :: std :: os :: raw :: c_void , arg1 : * const root :: RECT) -> root :: HWND { match self . pointers . SWELL_CreateXBridgeWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_CreateXBridgeWindow)) , Some (f) => f (viewpar , wref , arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetOSWindow (& self , hwnd : root :: HWND , type_ : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_GetOSWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetOSWindow)) , Some (f) => f (hwnd , type_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetOSEvent (& self , type_ : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_void { match self . pointers . SWELL_GetOSEvent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetOSEvent)) , Some (f) => f (type_) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GenerateGUID (& self , g : * mut :: std :: os :: raw :: c_void) -> bool { match self . pointers . SWELL_GenerateGUID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GenerateGUID)) , Some (f) => f (g) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumChildWindows (& self , hwnd : root :: HWND , cwEnumFunc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lParam : root :: LPARAM) -> root :: BOOL { match self . pointers . EnumChildWindows { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumChildWindows)) , Some (f) => f (hwnd , cwEnumFunc , lParam) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_IsGroupBox (& self , arg1 : root :: HWND) -> root :: BOOL { match self . pointers . SWELL_IsGroupBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_IsGroupBox)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_IsButton (& self , arg1 : root :: HWND) -> root :: BOOL { match self . pointers . SWELL_IsButton { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_IsButton)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_IsStaticText (& self , arg1 : root :: HWND) -> root :: BOOL { match self . pointers . SWELL_IsStaticText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_IsStaticText)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_GetDesiredControlSize (& self , hwnd : root :: HWND , r : * mut root :: RECT) { match self . pointers . SWELL_GetDesiredControlSize { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_GetDesiredControlSize)) , Some (f) => f (hwnd , r) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddFontResourceEx (& self , str_ : root :: LPCTSTR , fl : root :: DWORD , pdv : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int { match self . pointers . AddFontResourceEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddFontResourceEx)) , Some (f) => f (str_ , fl , pdv) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_Register_Cursor_Resource (& self , idx : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , hotspot_x : :: std :: os :: raw :: c_int , hotspot_y : :: std :: os :: raw :: c_int) { match self . pointers . SWELL_Register_Cursor_Resource { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_Register_Cursor_Resource)) , Some (f) => f (idx , name , hotspot_x , hotspot_y) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ChooseColor (& self , arg1 : root :: HWND , arg2 : * mut root :: COLORREF , ncustom : :: std :: os :: raw :: c_int , custom : * mut root :: COLORREF) -> bool { match self . pointers . SWELL_ChooseColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ChooseColor)) , Some (f) => f (arg1 , arg2 , ncustom , custom) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_ChooseFont (& self , arg1 : root :: HWND , arg2 : * mut root :: LOGFONT) -> bool { match self . pointers . SWELL_ChooseFont { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_ChooseFont)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsWindowEnabled (& self , arg1 : root :: HWND) -> bool { match self . pointers . IsWindowEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsWindowEnabled)) , Some (f) => f (arg1) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetClassName (& self , arg1 : root :: HWND , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetClassName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetClassName)) , Some (f) => f (arg1 , arg2 , arg3) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_SetClassName (& self , arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char) { match self . pointers . SWELL_SetClassName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_SetClassName)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SWELL_DisableContextMenu (& self , arg1 : root :: HWND , arg2 : bool) { match self . pointers . SWELL_DisableContextMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_DisableContextMenu)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumDisplayMonitors (& self , arg1 : root :: HDC , arg2 : root :: LPRECT , arg3 : root :: MONITORENUMPROC , arg4 : root :: LPARAM) -> root :: BOOL { match self . pointers . EnumDisplayMonitors { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumDisplayMonitors)) , Some (f) => f (arg1 , arg2 , arg3 , arg4) , } } # [cfg (target_family = "unix")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMonitorInfo (& self , arg1 : root :: HMONITOR , arg2 : * mut :: std :: os :: raw :: c_void) -> root :: BOOL { match self . pointers . GetMonitorInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMonitorInfo)) , Some (f) => f (arg1 , arg2) , } } # [cfg (target_family = "unix")] pub fn SWELL_osx_is_dark_mode (& self , mode : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SWELL_osx_is_dark_mode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SWELL_osx_is_dark_mode)) , Some (f) => f (mode) , } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDlgItem (& self , arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) -> root :: HWND { unsafe { windows :: GetDlgItem (arg1 , arg2) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShowWindow (& self , arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) { unsafe { windows :: ShowWindow (arg1 , arg2) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DestroyWindow (& self , hwnd : root :: HWND) { unsafe { windows :: DestroyWindow (hwnd) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetDlgItemInt (& self , arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int , issigned : :: std :: os :: raw :: c_int) -> root :: BOOL { unsafe { windows :: SetDlgItemInt (arg1 , idx , val , issigned) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDlgItemInt (& self , arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , translated : * mut root :: BOOL , issigned : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { unsafe { windows :: GetDlgItemInt (arg1 , idx , translated , issigned) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CheckDlgButton (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , check : :: std :: os :: raw :: c_int) { unsafe { windows :: CheckDlgButton (hwnd , idx , check) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsDlgButtonChecked (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { unsafe { windows :: IsDlgButtonChecked (hwnd , idx) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnableWindow (& self , hwnd : root :: HWND , enable : :: std :: os :: raw :: c_int) { unsafe { windows :: EnableWindow (hwnd , enable) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetFocus (& self , hwnd : root :: HWND) { unsafe { windows :: SetFocus (hwnd) } } # [cfg (target_family = "windows")] pub fn GetFocus (& self) -> root :: HWND { unsafe { windows :: GetFocus () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetForegroundWindow (& self , hwnd : root :: HWND) { unsafe { windows :: SetForegroundWindow (hwnd) } } # [cfg (target_family = "windows")] pub fn GetForegroundWindow (& self) -> root :: HWND { unsafe { windows :: GetForegroundWindow () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetCapture (& self , hwnd : root :: HWND) -> root :: HWND { unsafe { windows :: SetCapture (hwnd) } } # [cfg (target_family = "windows")] pub fn GetCapture (& self) -> root :: HWND { unsafe { windows :: GetCapture () } } # [cfg (target_family = "windows")] pub fn ReleaseCapture (& self) { unsafe { windows :: ReleaseCapture () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsChild (& self , hwndParent : root :: HWND , hwndChild : root :: HWND) -> :: std :: os :: raw :: c_int { unsafe { windows :: IsChild (hwndParent , hwndChild) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetParent (& self , hwnd : root :: HWND) -> root :: HWND { unsafe { windows :: GetParent (hwnd) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetParent (& self , hwnd : root :: HWND , newPar : root :: HWND) -> root :: HWND { unsafe { windows :: SetParent (hwnd , newPar) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindow (& self , hwnd : root :: HWND , what : :: std :: os :: raw :: c_int) -> root :: HWND { unsafe { windows :: GetWindow (hwnd , what) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumWindows (& self , proc_ : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lp : root :: LPARAM) -> root :: BOOL { unsafe { windows :: EnumWindows (proc_ , lp) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ClientToScreen (& self , hwnd : root :: HWND , p : * mut root :: POINT) { unsafe { windows :: ClientToScreen (hwnd , p) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ScreenToClient (& self , hwnd : root :: HWND , p : * mut root :: POINT) { unsafe { windows :: ScreenToClient (hwnd , p) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowRect (& self , hwnd : root :: HWND , r : * mut root :: RECT) -> bool { unsafe { windows :: GetWindowRect (hwnd , r) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetClientRect (& self , hwnd : root :: HWND , r : * mut root :: RECT) { unsafe { windows :: GetClientRect (hwnd , r) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WindowFromPoint (& self , p : root :: POINT) -> root :: HWND { unsafe { windows :: WindowFromPoint (p) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetWindowPos (& self , hwnd : root :: HWND , unused : root :: HWND , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , cx : :: std :: os :: raw :: c_int , cy : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) { unsafe { windows :: SetWindowPos (hwnd , unused , x , y , cx , cy , flags) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InvalidateRect (& self , hwnd : root :: HWND , r : * const root :: RECT , eraseBk : :: std :: os :: raw :: c_int) -> root :: BOOL { unsafe { windows :: InvalidateRect (hwnd , r , eraseBk) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ScrollWindow (& self , hwnd : root :: HWND , xamt : :: std :: os :: raw :: c_int , yamt : :: std :: os :: raw :: c_int , lpRect : * const root :: RECT , lpClipRect : * const root :: RECT) -> root :: BOOL { unsafe { windows :: ScrollWindow (hwnd , xamt , yamt , lpRect , lpClipRect) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsWindowVisible (& self , hwnd : root :: HWND) -> bool { unsafe { windows :: IsWindowVisible (hwnd) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsWindow (& self , hwnd : root :: HWND) -> bool { unsafe { windows :: IsWindow (hwnd) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTimer (& self , hwnd : root :: HWND , timerid : root :: UINT_PTR , rate : root :: UINT , tProc : root :: TIMERPROC) -> root :: UINT_PTR { unsafe { windows :: SetTimer (hwnd , timerid , rate , tProc) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn KillTimer (& self , hwnd : root :: HWND , timerid : root :: UINT_PTR) -> root :: BOOL { unsafe { windows :: KillTimer (hwnd , timerid) } } # [cfg (target_family = "windows")] pub fn CreatePopupMenu (& self) -> root :: HMENU { unsafe { windows :: CreatePopupMenu () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DestroyMenu (& self , hMenu : root :: HMENU) { unsafe { windows :: DestroyMenu (hMenu) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSubMenu (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int) -> root :: HMENU { unsafe { windows :: GetSubMenu (hMenu , pos) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenuItemCount (& self , hMenu : root :: HMENU) -> :: std :: os :: raw :: c_int { unsafe { windows :: GetMenuItemCount (hMenu) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenuItemID (& self , hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { unsafe { windows :: GetMenuItemID (hMenu , pos) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnableMenuItem (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , en : :: std :: os :: raw :: c_int) -> bool { unsafe { windows :: EnableMenuItem (hMenu , idx , en) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteMenu (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int) -> bool { unsafe { windows :: DeleteMenu (hMenu , idx , flag) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CheckMenuItem (& self , hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , chk : :: std :: os :: raw :: c_int) -> bool { unsafe { windows :: CheckMenuItem (hMenu , idx , chk) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DrawMenuBar (& self , arg1 : root :: HWND) { unsafe { windows :: DrawMenuBar (arg1) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackPopupMenu (& self , hMenu : root :: HMENU , flags : :: std :: os :: raw :: c_int , xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int , resvd : :: std :: os :: raw :: c_int , hwnd : root :: HWND , r : * const root :: RECT) -> :: std :: os :: raw :: c_int { unsafe { windows :: TrackPopupMenu (hMenu , flags , xpos , ypos , resvd , hwnd , r) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMenu (& self , hwnd : root :: HWND , menu : root :: HMENU) -> root :: BOOL { unsafe { windows :: SetMenu (hwnd , menu) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMenu (& self , hwnd : root :: HWND) -> root :: HMENU { unsafe { windows :: GetMenu (hwnd) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EndDialog (& self , arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) { unsafe { windows :: EndDialog (arg1 , arg2) } } # [cfg (target_family = "windows")] pub fn GetAsyncKeyState (& self , key : :: std :: os :: raw :: c_int) -> root :: WORD { unsafe { windows :: GetAsyncKeyState (key) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetCursorPos (& self , pt : * mut root :: POINT) { unsafe { windows :: GetCursorPos (pt) } } # [cfg (target_family = "windows")] pub fn GetMessagePos (& self) -> root :: DWORD { unsafe { windows :: GetMessagePos () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OpenClipboard (& self , hwndDlg : root :: HWND) -> bool { unsafe { windows :: OpenClipboard (hwndDlg) } } # [cfg (target_family = "windows")] pub fn CloseClipboard (& self) { unsafe { windows :: CloseClipboard () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetClipboardData (& self , type_ : root :: UINT) -> root :: HANDLE { unsafe { windows :: GetClipboardData (type_) } } # [cfg (target_family = "windows")] pub fn EmptyClipboard (& self) { unsafe { windows :: EmptyClipboard () } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetClipboardData (& self , type_ : root :: UINT , h : root :: HANDLE) { unsafe { windows :: SetClipboardData (type_ , h) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumClipboardFormats (& self , lastfmt : root :: UINT) -> root :: UINT { unsafe { windows :: EnumClipboardFormats (lastfmt) } } # [cfg (target_family = "windows")] pub fn GlobalAlloc (& self , flags : :: std :: os :: raw :: c_int , sz : :: std :: os :: raw :: c_int) -> root :: HANDLE { unsafe { windows :: GlobalAlloc (flags , sz) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GlobalLock (& self , h : root :: HANDLE) -> * mut :: std :: os :: raw :: c_void { unsafe { windows :: GlobalLock (h) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GlobalUnlock (& self , h : root :: HANDLE) { unsafe { windows :: GlobalUnlock (h) } } # [cfg (target_family = "windows")] pub fn CreateSolidBrush (& self , col : :: std :: os :: raw :: c_int) -> root :: HBRUSH { unsafe { windows :: CreateSolidBrush (col) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTextColor (& self , ctx : root :: HDC , col : :: std :: os :: raw :: c_int) { unsafe { windows :: SetTextColor (ctx , col) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetBkColor (& self , ctx : root :: HDC , col : :: std :: os :: raw :: c_int) { unsafe { windows :: SetBkColor (ctx , col) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetBkMode (& self , ctx : root :: HDC , col : :: std :: os :: raw :: c_int) { unsafe { windows :: SetBkMode (ctx , col) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateIconIndirect (& self , iconinfo : * mut root :: ICONINFO) -> root :: HICON { unsafe { windows :: CreateIconIndirect (iconinfo) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BitBlt (& self , hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) { unsafe { windows :: BitBlt (hdcOut , x , y , w , h , hdcIn , xin , yin , mode) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn StretchBlt (& self , hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) { unsafe { windows :: StretchBlt (hdcOut , x , y , w , h , hdcIn , xin , yin , srcw , srch , mode) } } # [cfg (target_family = "windows")] pub fn GetSysColor (& self , idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { unsafe { windows :: GetSysColor (idx) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn BeginPaint (& self , arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT) -> root :: HDC { unsafe { windows :: BeginPaint (arg1 , arg2) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EndPaint (& self , arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT) -> root :: BOOL { unsafe { windows :: EndPaint (arg1 , arg2) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDC (& self , arg1 : root :: HWND) -> root :: HDC { unsafe { windows :: GetDC (arg1) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetWindowDC (& self , arg1 : root :: HWND) -> root :: HDC { unsafe { windows :: GetWindowDC (arg1) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ReleaseDC (& self , arg1 : root :: HWND , arg2 : root :: HDC) { unsafe { windows :: ReleaseDC (arg1 , arg2) } } # [cfg (target_family = "windows")] pub fn GetSystemMetrics (& self , arg1 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { unsafe { windows :: GetSystemMetrics (arg1) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumChildWindows (& self , hwnd : root :: HWND , cwEnumFunc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lParam : root :: LPARAM) -> root :: BOOL { unsafe { windows :: EnumChildWindows (hwnd , cwEnumFunc , lParam) } } # [cfg (target_family = "windows")] # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsWindowEnabled (& self , arg1 : root :: HWND) -> bool { unsafe { windows :: IsWindowEnabled (arg1) } } } # [doc = r" Container for the SWELL function pointers."] # [derive (Copy , Clone , Default)] pub struct SwellFunctionPointers { pub (crate) loaded_count : u32 , pub lstrcpyn : Option < unsafe extern "C" fn (dest : * mut :: std :: os :: raw :: c_char , src : * const :: std :: os :: raw :: c_char , l : :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_char > , pub MulDiv : Option < extern "C" fn (arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub Sleep : Option < extern "C" fn (ms : :: std :: os :: raw :: c_int) > , pub GetTickCount : Option < extern "C" fn () -> root :: DWORD > , pub GetFileTime : Option < unsafe extern "C" fn (filedes : :: std :: os :: raw :: c_int , lpCreationTime : * mut root :: FILETIME , lpLastAccessTime : * mut root :: FILETIME , lpLastWriteTime : * mut root :: FILETIME ,) -> root :: BOOL > , pub WritePrivateProfileString : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , val : * const :: std :: os :: raw :: c_char , fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: BOOL > , pub GetPrivateProfileString : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , def : * const :: std :: os :: raw :: c_char , ret : * mut :: std :: os :: raw :: c_char , retsize : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: DWORD > , pub GetPrivateProfileInt : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , def : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub GetPrivateProfileStruct : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_void , bufsz : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: BOOL > , pub WritePrivateProfileStruct : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , keyname : * const :: std :: os :: raw :: c_char , buf : * const :: std :: os :: raw :: c_void , bufsz : :: std :: os :: raw :: c_int , fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: BOOL > , pub WritePrivateProfileSection : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , strings : * const :: std :: os :: raw :: c_char , fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: BOOL > , pub GetPrivateProfileSection : Option < unsafe extern "C" fn (appname : * const :: std :: os :: raw :: c_char , strout : * mut :: std :: os :: raw :: c_char , strout_len : root :: DWORD , fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: DWORD > , pub GetModuleFileName : Option < unsafe extern "C" fn (hInst : root :: HINSTANCE , fn_ : * mut :: std :: os :: raw :: c_char , nSize : root :: DWORD ,) -> root :: DWORD > , pub SWELL_PtInRect : Option < unsafe extern "C" fn (r : * const root :: RECT , p : root :: POINT ,) -> root :: BOOL > , pub ShellExecute : Option < unsafe extern "C" fn (hwndDlg : root :: HWND , action : * const :: std :: os :: raw :: c_char , content1 : * const :: std :: os :: raw :: c_char , content2 : * const :: std :: os :: raw :: c_char , content3 : * const :: std :: os :: raw :: c_char , blah : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub MessageBox : Option < unsafe extern "C" fn (hwndParent : root :: HWND , text : * const :: std :: os :: raw :: c_char , caption : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub BrowseForFiles : Option < unsafe extern "C" fn (text : * const :: std :: os :: raw :: c_char , initialdir : * const :: std :: os :: raw :: c_char , initialfile : * const :: std :: os :: raw :: c_char , allowmul : bool , extlist : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_char > , pub BrowseForSaveFile : Option < unsafe extern "C" fn (text : * const :: std :: os :: raw :: c_char , initialdir : * const :: std :: os :: raw :: c_char , initialfile : * const :: std :: os :: raw :: c_char , extlist : * const :: std :: os :: raw :: c_char , fn_ : * mut :: std :: os :: raw :: c_char , fnsize : :: std :: os :: raw :: c_int ,) -> bool > , pub BrowseForDirectory : Option < unsafe extern "C" fn (text : * const :: std :: os :: raw :: c_char , initialdir : * const :: std :: os :: raw :: c_char , fn_ : * mut :: std :: os :: raw :: c_char , fnsize : :: std :: os :: raw :: c_int ,) -> bool > , pub BrowseFile_SetTemplate : Option < unsafe extern "C" fn (dlgid : * const :: std :: os :: raw :: c_char , dlgProc : root :: DLGPROC , reshead : * mut root :: SWELL_DialogResourceIndex ,) > , pub GetDlgItem : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub ShowWindow : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int ,) > , pub DestroyWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub SWELL_GetGestureInfo : Option < unsafe extern "C" fn (lParam : root :: LPARAM , gi : * mut root :: GESTUREINFO ,) -> root :: BOOL > , pub SWELL_HideApp : Option < extern "C" fn () > , pub SetDlgItemText : Option < unsafe extern "C" fn (arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , text : * const :: std :: os :: raw :: c_char ,) -> root :: BOOL > , pub SetDlgItemInt : Option < unsafe extern "C" fn (arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int , issigned : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub GetDlgItemInt : Option < unsafe extern "C" fn (arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , translated : * mut root :: BOOL , issigned : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetDlgItemText : Option < unsafe extern "C" fn (arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , text : * mut :: std :: os :: raw :: c_char , textlen : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub GetWindowTextLength : Option < unsafe extern "C" fn (arg1 : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub CheckDlgButton : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , check : :: std :: os :: raw :: c_int ,) > , pub IsDlgButtonChecked : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub EnableWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND , enable : :: std :: os :: raw :: c_int ,) > , pub SetFocus : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub GetFocus : Option < extern "C" fn () -> root :: HWND > , pub SetForegroundWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub GetForegroundWindow : Option < extern "C" fn () -> root :: HWND > , pub SetCapture : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> root :: HWND > , pub GetCapture : Option < extern "C" fn () -> root :: HWND > , pub ReleaseCapture : Option < extern "C" fn () > , pub IsChild : Option < unsafe extern "C" fn (hwndParent : root :: HWND , hwndChild : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub GetParent : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> root :: HWND > , pub SetParent : Option < unsafe extern "C" fn (hwnd : root :: HWND , newPar : root :: HWND ,) -> root :: HWND > , pub GetWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND , what : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub EnumWindows : Option < unsafe extern "C" fn (proc_ : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lp : root :: LPARAM ,) -> root :: BOOL > , pub FindWindowEx : Option < unsafe extern "C" fn (par : root :: HWND , lastw : root :: HWND , classname : * const :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char ,) -> root :: HWND > , pub ClientToScreen : Option < unsafe extern "C" fn (hwnd : root :: HWND , p : * mut root :: POINT) > , pub ScreenToClient : Option < unsafe extern "C" fn (hwnd : root :: HWND , p : * mut root :: POINT) > , pub GetWindowRect : Option < unsafe extern "C" fn (hwnd : root :: HWND , r : * mut root :: RECT ,) -> bool > , pub GetWindowContentViewRect : Option < unsafe extern "C" fn (hwnd : root :: HWND , r : * mut root :: RECT) > , pub GetClientRect : Option < unsafe extern "C" fn (hwnd : root :: HWND , r : * mut root :: RECT) > , pub WindowFromPoint : Option < unsafe extern "C" fn (p : root :: POINT) -> root :: HWND > , pub WinOffsetRect : Option < unsafe extern "C" fn (lprc : root :: LPRECT , dx : :: std :: os :: raw :: c_int , dy : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub WinSetRect : Option < unsafe extern "C" fn (lprc : root :: LPRECT , xLeft : :: std :: os :: raw :: c_int , yTop : :: std :: os :: raw :: c_int , xRight : :: std :: os :: raw :: c_int , yBottom : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub WinUnionRect : Option < unsafe extern "C" fn (out : * mut root :: RECT , in1 : * const root :: RECT , in2 : * const root :: RECT ,) > , pub WinIntersectRect : Option < unsafe extern "C" fn (out : * mut root :: RECT , in1 : * const root :: RECT , in2 : * const root :: RECT ,) -> :: std :: os :: raw :: c_int > , pub SetWindowPos : Option < unsafe extern "C" fn (hwnd : root :: HWND , unused : root :: HWND , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , cx : :: std :: os :: raw :: c_int , cy : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) > , pub SWELL_SetWindowLevel : Option < unsafe extern "C" fn (hwnd : root :: HWND , newlevel : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub InvalidateRect : Option < unsafe extern "C" fn (hwnd : root :: HWND , r : * const root :: RECT , eraseBk : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub UpdateWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub GetWindowLong : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int ,) -> root :: LONG_PTR > , pub SetWindowLong : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , val : root :: LONG_PTR ,) -> root :: LONG_PTR > , pub ScrollWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND , xamt : :: std :: os :: raw :: c_int , yamt : :: std :: os :: raw :: c_int , lpRect : * const root :: RECT , lpClipRect : * const root :: RECT ,) -> root :: BOOL > , pub EnumPropsEx : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: PROPENUMPROCEX , arg3 : root :: LPARAM ,) -> :: std :: os :: raw :: c_int > , pub GetProp : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char ,) -> root :: HANDLE > , pub SetProp : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char , arg3 : root :: HANDLE ,) -> root :: BOOL > , pub RemoveProp : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char ,) -> root :: HANDLE > , pub IsWindowVisible : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> bool > , pub IsWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> bool > , pub SetTimer : Option < unsafe extern "C" fn (hwnd : root :: HWND , timerid : root :: UINT_PTR , rate : root :: UINT , tProc : root :: TIMERPROC ,) -> root :: UINT_PTR > , pub KillTimer : Option < unsafe extern "C" fn (hwnd : root :: HWND , timerid : root :: UINT_PTR ,) -> root :: BOOL > , pub ListView_SetExtendedListViewStyleEx : Option < unsafe extern "C" fn (h : root :: HWND , mask : :: std :: os :: raw :: c_int , style : :: std :: os :: raw :: c_int ,) > , pub ListView_InsertColumn : Option < unsafe extern "C" fn (h : root :: HWND , pos : :: std :: os :: raw :: c_int , lvc : * const root :: LVCOLUMN ,) > , pub ListView_DeleteColumn : Option < unsafe extern "C" fn (h : root :: HWND , pos : :: std :: os :: raw :: c_int ,) -> bool > , pub ListView_SetColumn : Option < unsafe extern "C" fn (h : root :: HWND , pos : :: std :: os :: raw :: c_int , lvc : * const root :: LVCOLUMN ,) > , pub ListView_GetColumnWidth : Option < unsafe extern "C" fn (h : root :: HWND , pos : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub ListView_InsertItem : Option < unsafe extern "C" fn (h : root :: HWND , item : * const root :: LVITEM ,) -> :: std :: os :: raw :: c_int > , pub ListView_SetItemText : Option < unsafe extern "C" fn (h : root :: HWND , ipos : :: std :: os :: raw :: c_int , cpos : :: std :: os :: raw :: c_int , txt : * const :: std :: os :: raw :: c_char ,) > , pub ListView_SetItem : Option < unsafe extern "C" fn (h : root :: HWND , item : * mut root :: LVITEM ,) -> bool > , pub ListView_GetNextItem : Option < unsafe extern "C" fn (h : root :: HWND , istart : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub ListView_GetItem : Option < unsafe extern "C" fn (h : root :: HWND , item : * mut root :: LVITEM ,) -> bool > , pub ListView_GetItemState : Option < unsafe extern "C" fn (h : root :: HWND , ipos : :: std :: os :: raw :: c_int , mask : root :: UINT ,) -> :: std :: os :: raw :: c_int > , pub ListView_DeleteItem : Option < unsafe extern "C" fn (h : root :: HWND , ipos : :: std :: os :: raw :: c_int ,) > , pub ListView_DeleteAllItems : Option < unsafe extern "C" fn (h : root :: HWND) > , pub ListView_GetSelectedCount : Option < unsafe extern "C" fn (h : root :: HWND) -> :: std :: os :: raw :: c_int > , pub ListView_GetItemCount : Option < unsafe extern "C" fn (h : root :: HWND) -> :: std :: os :: raw :: c_int > , pub ListView_GetSelectionMark : Option < unsafe extern "C" fn (h : root :: HWND) -> :: std :: os :: raw :: c_int > , pub ListView_SetColumnWidth : Option < unsafe extern "C" fn (h : root :: HWND , colpos : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int ,) > , pub ListView_SetItemState : Option < unsafe extern "C" fn (h : root :: HWND , item : :: std :: os :: raw :: c_int , state : root :: UINT , statemask : root :: UINT ,) -> bool > , pub ListView_RedrawItems : Option < unsafe extern "C" fn (h : root :: HWND , startitem : :: std :: os :: raw :: c_int , enditem : :: std :: os :: raw :: c_int ,) > , pub ListView_SetItemCount : Option < unsafe extern "C" fn (h : root :: HWND , cnt : :: std :: os :: raw :: c_int ,) > , pub ListView_EnsureVisible : Option < unsafe extern "C" fn (h : root :: HWND , i : :: std :: os :: raw :: c_int , pok : root :: BOOL ,) > , pub ListView_SetImageList : Option < unsafe extern "C" fn (h : root :: HWND , imagelist : root :: HIMAGELIST , which : :: std :: os :: raw :: c_int ,) > , pub ListView_SubItemHitTest : Option < unsafe extern "C" fn (h : root :: HWND , pinf : * mut root :: LVHITTESTINFO ,) -> :: std :: os :: raw :: c_int > , pub ListView_GetItemText : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : :: std :: os :: raw :: c_int , subitem : :: std :: os :: raw :: c_int , text : * mut :: std :: os :: raw :: c_char , textmax : :: std :: os :: raw :: c_int ,) > , pub ListView_SortItems : Option < unsafe extern "C" fn (hwnd : root :: HWND , compf : root :: PFNLVCOMPARE , parm : root :: LPARAM ,) > , pub ListView_Scroll : Option < unsafe extern "C" fn (h : root :: HWND , xscroll : :: std :: os :: raw :: c_int , yscroll : :: std :: os :: raw :: c_int ,) -> bool > , pub ListView_GetTopIndex : Option < unsafe extern "C" fn (h : root :: HWND) -> :: std :: os :: raw :: c_int > , pub ListView_GetCountPerPage : Option < unsafe extern "C" fn (h : root :: HWND) -> :: std :: os :: raw :: c_int > , pub ListView_SetColumnOrderArray : Option < unsafe extern "C" fn (h : root :: HWND , cnt : :: std :: os :: raw :: c_int , arr : * mut :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub ListView_GetColumnOrderArray : Option < unsafe extern "C" fn (h : root :: HWND , cnt : :: std :: os :: raw :: c_int , arr : * mut :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub ListView_GetHeader : Option < unsafe extern "C" fn (h : root :: HWND) -> root :: HWND > , pub Header_GetItemCount : Option < unsafe extern "C" fn (h : root :: HWND) -> :: std :: os :: raw :: c_int > , pub Header_GetItem : Option < unsafe extern "C" fn (h : root :: HWND , col : :: std :: os :: raw :: c_int , hi : * mut root :: HDITEM ,) -> root :: BOOL > , pub Header_SetItem : Option < unsafe extern "C" fn (h : root :: HWND , col : :: std :: os :: raw :: c_int , hi : * mut root :: HDITEM ,) -> root :: BOOL > , pub ListView_GetItemRect : Option < unsafe extern "C" fn (h : root :: HWND , item : :: std :: os :: raw :: c_int , r : * mut root :: RECT , code : :: std :: os :: raw :: c_int ,) -> bool > , pub ListView_GetSubItemRect : Option < unsafe extern "C" fn (h : root :: HWND , item : :: std :: os :: raw :: c_int , subitem : :: std :: os :: raw :: c_int , code : :: std :: os :: raw :: c_int , r : * mut root :: RECT ,) -> bool > , pub ListView_HitTest : Option < unsafe extern "C" fn (h : root :: HWND , pinf : * mut root :: LVHITTESTINFO ,) -> :: std :: os :: raw :: c_int > , pub SWELL_GetListViewHeaderHeight : Option < unsafe extern "C" fn (h : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub ImageList_CreateEx : Option < extern "C" fn () -> root :: HIMAGELIST > , pub ImageList_Remove : Option < unsafe extern "C" fn (list : root :: HIMAGELIST , idx : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub ImageList_ReplaceIcon : Option < unsafe extern "C" fn (list : root :: HIMAGELIST , offset : :: std :: os :: raw :: c_int , image : root :: HICON ,) -> :: std :: os :: raw :: c_int > , pub ImageList_Add : Option < unsafe extern "C" fn (list : root :: HIMAGELIST , image : root :: HBITMAP , mask : root :: HBITMAP ,) -> :: std :: os :: raw :: c_int > , pub ImageList_Destroy : Option < unsafe extern "C" fn (arg1 : root :: HIMAGELIST) > , pub TabCtrl_GetItemCount : Option < unsafe extern "C" fn (hwnd : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub TabCtrl_DeleteItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub TabCtrl_InsertItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , item : * mut root :: TCITEM ,) -> :: std :: os :: raw :: c_int > , pub TabCtrl_SetCurSel : Option < unsafe extern "C" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TabCtrl_GetCurSel : Option < unsafe extern "C" fn (hwnd : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub TabCtrl_AdjustRect : Option < unsafe extern "C" fn (hwnd : root :: HWND , fLarger : root :: BOOL , r : * mut root :: RECT ,) -> root :: BOOL > , pub TreeView_InsertItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , ins : * mut root :: TV_INSERTSTRUCT ,) -> root :: HTREEITEM > , pub TreeView_Expand : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM , flag : root :: UINT ,) -> root :: BOOL > , pub TreeView_GetSelection : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> root :: HTREEITEM > , pub TreeView_DeleteItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM) > , pub TreeView_DeleteAllItems : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub TreeView_SelectItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM) > , pub TreeView_EnsureVisible : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM) > , pub TreeView_GetItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , pitem : root :: LPTVITEM ,) -> root :: BOOL > , pub TreeView_SetItem : Option < unsafe extern "C" fn (hwnd : root :: HWND , pitem : root :: LPTVITEM ,) -> root :: BOOL > , pub TreeView_HitTest : Option < unsafe extern "C" fn (hwnd : root :: HWND , hti : * mut root :: TVHITTESTINFO ,) -> root :: HTREEITEM > , pub TreeView_SetIndent : Option < unsafe extern "C" fn (hwnd : root :: HWND , indent : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub TreeView_GetParent : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM ,) -> root :: HTREEITEM > , pub TreeView_GetChild : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM ,) -> root :: HTREEITEM > , pub TreeView_GetNextSibling : Option < unsafe extern "C" fn (hwnd : root :: HWND , item : root :: HTREEITEM ,) -> root :: HTREEITEM > , pub TreeView_GetRoot : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> root :: HTREEITEM > , pub TreeView_SetBkColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , color : :: std :: os :: raw :: c_int ,) > , pub TreeView_SetTextColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , color : :: std :: os :: raw :: c_int ,) > , pub ListView_SetBkColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , color : :: std :: os :: raw :: c_int ,) > , pub ListView_SetTextBkColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , color : :: std :: os :: raw :: c_int ,) > , pub ListView_SetTextColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , color : :: std :: os :: raw :: c_int ,) > , pub ListView_SetGridColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , color : :: std :: os :: raw :: c_int ,) > , pub ListView_SetSelColors : Option < unsafe extern "C" fn (hwnd : root :: HWND , colors : * mut :: std :: os :: raw :: c_int , ncolors : :: std :: os :: raw :: c_int ,) > , pub SWELL_ModalWindowStart : Option < unsafe extern "C" fn (hwnd : root :: HWND ,) -> * mut :: std :: os :: raw :: c_void > , pub SWELL_ModalWindowRun : Option < unsafe extern "C" fn (ctx : * mut :: std :: os :: raw :: c_void , ret : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub SWELL_ModalWindowEnd : Option < unsafe extern "C" fn (ctx : * mut :: std :: os :: raw :: c_void) > , pub SWELL_CloseWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub CreatePopupMenu : Option < extern "C" fn () -> root :: HMENU > , pub CreatePopupMenuEx : Option < unsafe extern "C" fn (title : * const :: std :: os :: raw :: c_char ,) -> root :: HMENU > , pub DestroyMenu : Option < unsafe extern "C" fn (hMenu : root :: HMENU) > , pub AddMenuItem : Option < unsafe extern "C" fn (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char , tagid : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetSubMenu : Option < unsafe extern "C" fn (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int ,) -> root :: HMENU > , pub GetMenuItemCount : Option < unsafe extern "C" fn (hMenu : root :: HMENU ,) -> :: std :: os :: raw :: c_int > , pub GetMenuItemID : Option < unsafe extern "C" fn (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetMenuItemModifier : Option < unsafe extern "C" fn (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int , code : :: std :: os :: raw :: c_int , mask : :: std :: os :: raw :: c_uint ,) -> bool > , pub SetMenuItemText : Option < unsafe extern "C" fn (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int , text : * const :: std :: os :: raw :: c_char ,) -> bool > , pub EnableMenuItem : Option < unsafe extern "C" fn (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , en : :: std :: os :: raw :: c_int ,) -> bool > , pub DeleteMenu : Option < unsafe extern "C" fn (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int ,) -> bool > , pub CheckMenuItem : Option < unsafe extern "C" fn (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , chk : :: std :: os :: raw :: c_int ,) -> bool > , pub InsertMenuItem : Option < unsafe extern "C" fn (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , byPos : root :: BOOL , mi : * mut root :: MENUITEMINFO ,) > , pub SWELL_InsertMenu : Option < unsafe extern "C" fn (menu : root :: HMENU , pos : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_uint , idx : root :: UINT_PTR , str_ : * const :: std :: os :: raw :: c_char ,) > , pub GetMenuItemInfo : Option < unsafe extern "C" fn (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , byPos : root :: BOOL , mi : * mut root :: MENUITEMINFO ,) -> root :: BOOL > , pub SetMenuItemInfo : Option < unsafe extern "C" fn (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int , byPos : root :: BOOL , mi : * mut root :: MENUITEMINFO ,) -> root :: BOOL > , pub DrawMenuBar : Option < unsafe extern "C" fn (arg1 : root :: HWND) > , pub SWELL_LoadMenu : Option < unsafe extern "C" fn (head : * mut root :: SWELL_MenuResourceIndex , resid : * const :: std :: os :: raw :: c_char ,) -> root :: HMENU > , pub TrackPopupMenu : Option < unsafe extern "C" fn (hMenu : root :: HMENU , flags : :: std :: os :: raw :: c_int , xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int , resvd : :: std :: os :: raw :: c_int , hwnd : root :: HWND , r : * const root :: RECT ,) -> :: std :: os :: raw :: c_int > , pub SWELL_SetMenuDestination : Option < unsafe extern "C" fn (menu : root :: HMENU , hwnd : root :: HWND) > , pub SWELL_DuplicateMenu : Option < unsafe extern "C" fn (menu : root :: HMENU) -> root :: HMENU > , pub SetMenu : Option < unsafe extern "C" fn (hwnd : root :: HWND , menu : root :: HMENU ,) -> root :: BOOL > , pub GetMenu : Option < unsafe extern "C" fn (hwnd : root :: HWND) -> root :: HMENU > , pub SWELL_GetDefaultWindowMenu : Option < extern "C" fn () -> root :: HMENU > , pub SWELL_SetDefaultWindowMenu : Option < unsafe extern "C" fn (arg1 : root :: HMENU) > , pub SWELL_GetDefaultModalWindowMenu : Option < extern "C" fn () -> root :: HMENU > , pub SWELL_SetDefaultModalWindowMenu : Option < unsafe extern "C" fn (arg1 : root :: HMENU) > , pub SWELL_GetCurrentMenu : Option < extern "C" fn () -> root :: HMENU > , pub SWELL_SetCurrentMenu : Option < unsafe extern "C" fn (arg1 : root :: HMENU) > , pub SWELL_DialogBox : Option < unsafe extern "C" fn (reshead : * mut root :: SWELL_DialogResourceIndex , resid : * const :: std :: os :: raw :: c_char , parent : root :: HWND , dlgproc : root :: DLGPROC , param : root :: LPARAM ,) -> :: std :: os :: raw :: c_int > , pub SWELL_CreateDialog : Option < unsafe extern "C" fn (reshead : * mut root :: SWELL_DialogResourceIndex , resid : * const :: std :: os :: raw :: c_char , parent : root :: HWND , dlgproc : root :: DLGPROC , param : root :: LPARAM ,) -> root :: HWND > , pub SWELL_RegisterCustomControlCreator : Option < unsafe extern "C" fn (proc_ : root :: SWELL_ControlCreatorProc ,) > , pub SWELL_UnregisterCustomControlCreator : Option < unsafe extern "C" fn (proc_ : root :: SWELL_ControlCreatorProc ,) > , pub DefWindowProc : Option < unsafe extern "C" fn (hwnd : root :: HWND , msg : root :: UINT , wParam : root :: WPARAM , lParam : root :: LPARAM ,) -> root :: LRESULT > , pub EndDialog : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int ,) > , pub SWELL_GetDefaultButtonID : Option < unsafe extern "C" fn (hwndDlg : root :: HWND , onlyIfEnabled : bool ,) -> :: std :: os :: raw :: c_int > , pub SendMessage : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: UINT , arg3 : root :: WPARAM , arg4 : root :: LPARAM ,) -> root :: LRESULT > , pub SWELL_BroadcastMessage : Option < unsafe extern "C" fn (arg1 : root :: UINT , arg2 : root :: WPARAM , arg3 : root :: LPARAM ,) > , pub PostMessage : Option < unsafe extern "C" fn (hwnd : root :: HWND , msg : root :: UINT , wParam : root :: WPARAM , lParam : root :: LPARAM ,) -> root :: BOOL > , pub SWELL_MessageQueue_Flush : Option < extern "C" fn () > , pub SWELL_MessageQueue_Clear : Option < unsafe extern "C" fn (h : root :: HWND) > , pub SWELL_KeyToASCII : Option < unsafe extern "C" fn (wParam : :: std :: os :: raw :: c_int , lParam : :: std :: os :: raw :: c_int , newflags : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetAsyncKeyState : Option < extern "C" fn (key : :: std :: os :: raw :: c_int) -> root :: WORD > , pub GetCursorPos : Option < unsafe extern "C" fn (pt : * mut root :: POINT) > , pub GetMessagePos : Option < extern "C" fn () -> root :: DWORD > , pub SWELL_LoadCursor : Option < unsafe extern "C" fn (idx : * const :: std :: os :: raw :: c_char ,) -> root :: HCURSOR > , pub SWELL_SetCursor : Option < unsafe extern "C" fn (curs : root :: HCURSOR) > , pub SWELL_EnableRightClickEmulate : Option < unsafe extern "C" fn (enable : root :: BOOL) > , pub SWELL_GetCursor : Option < extern "C" fn () -> root :: HCURSOR > , pub SWELL_GetLastSetCursor : Option < extern "C" fn () -> root :: HCURSOR > , pub SWELL_IsCursorVisible : Option < extern "C" fn () -> bool > , pub SWELL_ShowCursor : Option < unsafe extern "C" fn (bShow : root :: BOOL ,) -> :: std :: os :: raw :: c_int > , pub SWELL_SetCursorPos : Option < extern "C" fn (X : :: std :: os :: raw :: c_int , Y : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub SWELL_GetViewPort : Option < unsafe extern "C" fn (r : * mut root :: RECT , sourcerect : * const root :: RECT , wantWork : bool ,) > , pub OpenClipboard : Option < unsafe extern "C" fn (hwndDlg : root :: HWND) -> bool > , pub CloseClipboard : Option < extern "C" fn () > , pub GetClipboardData : Option < unsafe extern "C" fn (type_ : root :: UINT) -> root :: HANDLE > , pub EmptyClipboard : Option < extern "C" fn () > , pub SetClipboardData : Option < unsafe extern "C" fn (type_ : root :: UINT , h : root :: HANDLE) > , pub RegisterClipboardFormat : Option < unsafe extern "C" fn (desc : * const :: std :: os :: raw :: c_char ,) -> root :: UINT > , pub EnumClipboardFormats : Option < unsafe extern "C" fn (lastfmt : root :: UINT) -> root :: UINT > , pub GlobalAlloc : Option < extern "C" fn (flags : :: std :: os :: raw :: c_int , sz : :: std :: os :: raw :: c_int ,) -> root :: HANDLE > , pub GlobalLock : Option < unsafe extern "C" fn (h : root :: HANDLE ,) -> * mut :: std :: os :: raw :: c_void > , pub GlobalSize : Option < unsafe extern "C" fn (h : root :: HANDLE) -> :: std :: os :: raw :: c_int > , pub GlobalUnlock : Option < unsafe extern "C" fn (h : root :: HANDLE) > , pub GlobalFree : Option < unsafe extern "C" fn (h : root :: HANDLE) > , pub CreateThread : Option < unsafe extern "C" fn (TA : * mut :: std :: os :: raw :: c_void , stackSize : root :: DWORD , ThreadProc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: LPVOID ,) -> root :: DWORD , > , parm : root :: LPVOID , cf : root :: DWORD , tidOut : * mut root :: DWORD ,) -> root :: HANDLE > , pub CreateEvent : Option < unsafe extern "C" fn (SA : * mut :: std :: os :: raw :: c_void , manualReset : root :: BOOL , initialSig : root :: BOOL , ignored : * const :: std :: os :: raw :: c_char ,) -> root :: HANDLE > , pub CreateEventAsSocket : Option < unsafe extern "C" fn (SA : * mut :: std :: os :: raw :: c_void , manualReset : root :: BOOL , initialSig : root :: BOOL , ignored : * const :: std :: os :: raw :: c_char ,) -> root :: HANDLE > , pub GetCurrentThreadId : Option < extern "C" fn () -> root :: DWORD > , pub WaitForSingleObject : Option < unsafe extern "C" fn (hand : root :: HANDLE , msTO : root :: DWORD ,) -> root :: DWORD > , pub WaitForAnySocketObject : Option < unsafe extern "C" fn (numObjs : :: std :: os :: raw :: c_int , objs : * mut root :: HANDLE , msTO : root :: DWORD ,) -> root :: DWORD > , pub CloseHandle : Option < unsafe extern "C" fn (hand : root :: HANDLE) -> root :: BOOL > , pub SetThreadPriority : Option < unsafe extern "C" fn (evt : root :: HANDLE , prio : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , pub SetEvent : Option < unsafe extern "C" fn (evt : root :: HANDLE) -> root :: BOOL > , pub ResetEvent : Option < unsafe extern "C" fn (evt : root :: HANDLE) -> root :: BOOL > , pub SWELL_CreateProcessFromPID : Option < extern "C" fn (pid : :: std :: os :: raw :: c_int ,) -> root :: HANDLE > , pub SWELL_CreateProcess : Option < unsafe extern "C" fn (exe : * const :: std :: os :: raw :: c_char , nparams : :: std :: os :: raw :: c_int , params : * mut * const :: std :: os :: raw :: c_char ,) -> root :: HANDLE > , pub SWELL_GetProcessExitCode : Option < unsafe extern "C" fn (hand : root :: HANDLE ,) -> :: std :: os :: raw :: c_int > , pub LoadLibraryGlobals : Option < unsafe extern "C" fn (fileName : * const :: std :: os :: raw :: c_char , symbolsAsGlobals : bool ,) -> root :: HINSTANCE > , pub LoadLibrary : Option < unsafe extern "C" fn (fileName : * const :: std :: os :: raw :: c_char ,) -> root :: HINSTANCE > , pub GetProcAddress : Option < unsafe extern "C" fn (hInst : root :: HINSTANCE , procName : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_void > , pub FreeLibrary : Option < unsafe extern "C" fn (hInst : root :: HINSTANCE) -> root :: BOOL > , pub SWELL_GetBundle : Option < unsafe extern "C" fn (hInst : root :: HINSTANCE ,) -> * mut :: std :: os :: raw :: c_void > , pub SWELL_CreateMemContext : Option < unsafe extern "C" fn (hdc : root :: HDC , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int ,) -> root :: HDC > , pub SWELL_DeleteGfxContext : Option < unsafe extern "C" fn (arg1 : root :: HDC) > , pub SWELL_GetCtxGC : Option < unsafe extern "C" fn (ctx : root :: HDC ,) -> * mut :: std :: os :: raw :: c_void > , pub SWELL_GetCtxFrameBuffer : Option < unsafe extern "C" fn (ctx : root :: HDC ,) -> * mut :: std :: os :: raw :: c_void > , pub SWELL_PushClipRegion : Option < unsafe extern "C" fn (ctx : root :: HDC) > , pub SWELL_SetClipRegion : Option < unsafe extern "C" fn (ctx : root :: HDC , r : * const root :: RECT) > , pub SWELL_PopClipRegion : Option < unsafe extern "C" fn (ctx : root :: HDC) > , pub CreateFontIndirect : Option < unsafe extern "C" fn (arg1 : * mut root :: LOGFONT) -> root :: HFONT > , pub CreateFont : Option < unsafe extern "C" fn (lfHeight : :: std :: os :: raw :: c_int , lfWidth : :: std :: os :: raw :: c_int , lfEscapement : :: std :: os :: raw :: c_int , lfOrientation : :: std :: os :: raw :: c_int , lfWeight : :: std :: os :: raw :: c_int , lfItalic : :: std :: os :: raw :: c_char , lfUnderline : :: std :: os :: raw :: c_char , lfStrikeOut : :: std :: os :: raw :: c_char , lfCharSet : :: std :: os :: raw :: c_char , lfOutPrecision : :: std :: os :: raw :: c_char , lfClipPrecision : :: std :: os :: raw :: c_char , lfQuality : :: std :: os :: raw :: c_char , lfPitchAndFamily : :: std :: os :: raw :: c_char , lfFaceName : * const :: std :: os :: raw :: c_char ,) -> root :: HFONT > , pub CreatePen : Option < extern "C" fn (attr : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int ,) -> root :: HPEN > , pub CreateSolidBrush : Option < extern "C" fn (col : :: std :: os :: raw :: c_int ,) -> root :: HBRUSH > , pub CreatePenAlpha : Option < extern "C" fn (attr : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int , col : :: std :: os :: raw :: c_int , alpha : f32 ,) -> root :: HPEN > , pub CreateSolidBrushAlpha : Option < extern "C" fn (col : :: std :: os :: raw :: c_int , alpha : f32 ,) -> root :: HBRUSH > , pub SelectObject : Option < unsafe extern "C" fn (ctx : root :: HDC , pen : root :: HGDIOBJ ,) -> root :: HGDIOBJ > , pub GetStockObject : Option < extern "C" fn (wh : :: std :: os :: raw :: c_int ,) -> root :: HGDIOBJ > , pub DeleteObject : Option < unsafe extern "C" fn (arg1 : root :: HGDIOBJ) > , pub SWELL_FillRect : Option < unsafe extern "C" fn (ctx : root :: HDC , r : * const root :: RECT , br : root :: HBRUSH ,) > , pub Rectangle : Option < unsafe extern "C" fn (ctx : root :: HDC , l : :: std :: os :: raw :: c_int , t : :: std :: os :: raw :: c_int , r : :: std :: os :: raw :: c_int , b : :: std :: os :: raw :: c_int ,) > , pub Ellipse : Option < unsafe extern "C" fn (ctx : root :: HDC , l : :: std :: os :: raw :: c_int , t : :: std :: os :: raw :: c_int , r : :: std :: os :: raw :: c_int , b : :: std :: os :: raw :: c_int ,) > , pub SWELL_Polygon : Option < unsafe extern "C" fn (ctx : root :: HDC , pts : * mut root :: POINT , npts : :: std :: os :: raw :: c_int ,) > , pub MoveToEx : Option < unsafe extern "C" fn (ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , op : * mut root :: POINT ,) > , pub SWELL_LineTo : Option < unsafe extern "C" fn (ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ,) > , pub SWELL_SetPixel : Option < unsafe extern "C" fn (ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , c : :: std :: os :: raw :: c_int ,) > , pub PolyBezierTo : Option < unsafe extern "C" fn (ctx : root :: HDC , pts : * mut root :: POINT , np : :: std :: os :: raw :: c_int ,) > , pub SWELL_DrawText : Option < unsafe extern "C" fn (ctx : root :: HDC , buf : * const :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , r : * mut root :: RECT , align : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTextColor : Option < unsafe extern "C" fn (ctx : root :: HDC , col : :: std :: os :: raw :: c_int ,) > , pub GetTextColor : Option < unsafe extern "C" fn (ctx : root :: HDC) -> :: std :: os :: raw :: c_int > , pub SetBkColor : Option < unsafe extern "C" fn (ctx : root :: HDC , col : :: std :: os :: raw :: c_int ,) > , pub SetBkMode : Option < unsafe extern "C" fn (ctx : root :: HDC , col : :: std :: os :: raw :: c_int ,) > , pub GetGlyphIndicesW : Option < unsafe extern "C" fn (ctx : root :: HDC , buf : * mut u32 , len : :: std :: os :: raw :: c_int , indices : * mut :: std :: os :: raw :: c_ushort , flags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub RoundRect : Option < unsafe extern "C" fn (ctx : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , x2 : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , xrnd : :: std :: os :: raw :: c_int , yrnd : :: std :: os :: raw :: c_int ,) > , pub PolyPolyline : Option < unsafe extern "C" fn (ctx : root :: HDC , pts : * mut root :: POINT , cnts : * mut root :: DWORD , nseg : :: std :: os :: raw :: c_int ,) > , pub GetTextMetrics : Option < unsafe extern "C" fn (ctx : root :: HDC , tm : * mut root :: TEXTMETRIC ,) -> root :: BOOL > , pub GetTextFace : Option < unsafe extern "C" fn (ctx : root :: HDC , nCount : :: std :: os :: raw :: c_int , lpFaceName : root :: LPTSTR ,) -> :: std :: os :: raw :: c_int > , pub GetObject : Option < unsafe extern "C" fn (icon : root :: HICON , bmsz : :: std :: os :: raw :: c_int , _bm : * mut :: std :: os :: raw :: c_void ,) -> root :: BOOL > , pub CreateIconIndirect : Option < unsafe extern "C" fn (iconinfo : * mut root :: ICONINFO ,) -> root :: HICON > , pub LoadNamedImage : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , alphaFromMask : bool ,) -> root :: HICON > , pub DrawImageInRect : Option < unsafe extern "C" fn (ctx : root :: HDC , img : root :: HICON , r : * const root :: RECT ,) > , pub BitBlt : Option < unsafe extern "C" fn (hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int ,) > , pub StretchBlt : Option < unsafe extern "C" fn (hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int ,) > , pub StretchBltFromMem : Option < unsafe extern "C" fn (hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , bits : * const :: std :: os :: raw :: c_void , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , srcspan : :: std :: os :: raw :: c_int ,) > , pub SWELL_GetScaling256 : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub SWELL_ExtendedAPI : Option < unsafe extern "C" fn (key : * const :: std :: os :: raw :: c_char , v : * mut :: std :: os :: raw :: c_void ,) -> * mut :: std :: os :: raw :: c_void > , pub GetSysColor : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub CreateBitmap : Option < unsafe extern "C" fn (width : :: std :: os :: raw :: c_int , height : :: std :: os :: raw :: c_int , numplanes : :: std :: os :: raw :: c_int , bitsperpixel : :: std :: os :: raw :: c_int , bits : * mut :: std :: os :: raw :: c_uchar ,) -> root :: HBITMAP > , pub SetOpaque : Option < unsafe extern "C" fn (h : root :: HWND , isopaque : bool) > , pub SetAllowNoMiddleManRendering : Option < unsafe extern "C" fn (h : root :: HWND , allow : bool) > , pub SWELL_SetViewGL : Option < unsafe extern "C" fn (h : root :: HWND , wantGL : :: std :: os :: raw :: c_char ,) > , pub SWELL_GetViewGL : Option < unsafe extern "C" fn (h : root :: HWND) -> bool > , pub SWELL_SetGLContextToView : Option < unsafe extern "C" fn (h : root :: HWND) -> bool > , pub BeginPaint : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT ,) -> root :: HDC > , pub EndPaint : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT ,) -> root :: BOOL > , pub GetDC : Option < unsafe extern "C" fn (arg1 : root :: HWND) -> root :: HDC > , pub GetWindowDC : Option < unsafe extern "C" fn (arg1 : root :: HWND) -> root :: HDC > , pub ReleaseDC : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: HDC) > , pub SWELL_FillDialogBackground : Option < unsafe extern "C" fn (hdc : root :: HDC , r : * const root :: RECT , level : :: std :: os :: raw :: c_int ,) > , pub SWELL_CloneGDIObject : Option < unsafe extern "C" fn (a : root :: HGDIOBJ) -> root :: HGDIOBJ > , pub GetSystemMetrics : Option < extern "C" fn (arg1 : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub DragQueryPoint : Option < unsafe extern "C" fn (arg1 : root :: HDROP , arg2 : root :: LPPOINT ,) -> root :: BOOL > , pub DragFinish : Option < unsafe extern "C" fn (arg1 : root :: HDROP) > , pub DragQueryFile : Option < unsafe extern "C" fn (arg1 : root :: HDROP , arg2 : root :: UINT , arg3 : * mut :: std :: os :: raw :: c_char , arg4 : root :: UINT ,) -> root :: UINT > , pub SWELL_InitiateDragDrop : Option < unsafe extern "C" fn (arg1 : root :: HWND , srcrect : * mut root :: RECT , srcfn : * const :: std :: os :: raw :: c_char , callback : :: std :: option :: Option < unsafe extern "C" fn (droppath : * const :: std :: os :: raw :: c_char ,) , > ,) > , pub SWELL_InitiateDragDropOfFileList : Option < unsafe extern "C" fn (arg1 : root :: HWND , srcrect : * mut root :: RECT , srclist : * mut * const :: std :: os :: raw :: c_char , srccount : :: std :: os :: raw :: c_int , icon : root :: HICON ,) > , pub SWELL_FinishDragDrop : Option < extern "C" fn () > , pub SWELL_DrawFocusRect : Option < unsafe extern "C" fn (hwndPar : root :: HWND , rct : * mut root :: RECT , handle : * mut * mut :: std :: os :: raw :: c_void ,) > , pub SWELL_MakeSetCurParms : Option < unsafe extern "C" fn (xscale : f32 , yscale : f32 , xtrans : f32 , ytrans : f32 , parent : root :: HWND , doauto : bool , dosizetofit : bool ,) > , pub SWELL_MakeButton : Option < unsafe extern "C" fn (def : :: std :: os :: raw :: c_int , label : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeEditField : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeLabel : Option < unsafe extern "C" fn (align : :: std :: os :: raw :: c_int , label : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeControl : Option < unsafe extern "C" fn (cname : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , classname : * const :: std :: os :: raw :: c_char , style : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , exstyle : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeCombo : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeGroupBox : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , style : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeCheckBox : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_MakeListBox : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , styles : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub SWELL_Menu_AddMenuItem : Option < unsafe extern "C" fn (hMenu : root :: HMENU , name : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_uint ,) > , pub SWELL_GenerateMenuFromList : Option < unsafe extern "C" fn (hMenu : root :: HMENU , list : * const :: std :: os :: raw :: c_void , listsz : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SWELL_GenerateDialogFromList : Option < unsafe extern "C" fn (list : * const :: std :: os :: raw :: c_void , listsz : :: std :: os :: raw :: c_int ,) > , pub _controlfp : Option < extern "C" fn (flag : :: std :: os :: raw :: c_uint , mask : :: std :: os :: raw :: c_uint ,) -> :: std :: os :: raw :: c_uint > , pub SWELL_Internal_PostMessage_Init : Option < extern "C" fn () > , pub SWELL_LoadCursorFromFile : Option < unsafe extern "C" fn (fn_ : * const :: std :: os :: raw :: c_char ,) -> root :: HCURSOR > , pub SWELL_SetWindowWantRaiseAmt : Option < unsafe extern "C" fn (h : root :: HWND , amt : :: std :: os :: raw :: c_int ,) > , pub SWELL_GetWindowWantRaiseAmt : Option < unsafe extern "C" fn (arg1 : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub SWELL_SetListViewFastClickMask : Option < unsafe extern "C" fn (hList : root :: HWND , mask : :: std :: os :: raw :: c_int ,) > , pub GetTempPath : Option < unsafe extern "C" fn (sz : :: std :: os :: raw :: c_int , buf : * mut :: std :: os :: raw :: c_char ,) > , pub SWELL_initargs : Option < unsafe extern "C" fn (argc : * mut :: std :: os :: raw :: c_int , argv : * mut * mut * mut :: std :: os :: raw :: c_char ,) > , pub SWELL_RunMessageLoop : Option < extern "C" fn () > , pub SWELL_CreateXBridgeWindow : Option < unsafe extern "C" fn (viewpar : root :: HWND , wref : * mut * mut :: std :: os :: raw :: c_void , arg1 : * const root :: RECT ,) -> root :: HWND > , pub SWELL_GetOSWindow : Option < unsafe extern "C" fn (hwnd : root :: HWND , type_ : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_void > , pub SWELL_GetOSEvent : Option < unsafe extern "C" fn (type_ : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_void > , pub SWELL_GenerateGUID : Option < unsafe extern "C" fn (g : * mut :: std :: os :: raw :: c_void) -> bool > , pub EnumChildWindows : Option < unsafe extern "C" fn (hwnd : root :: HWND , cwEnumFunc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lParam : root :: LPARAM ,) -> root :: BOOL > , pub SWELL_IsGroupBox : Option < unsafe extern "C" fn (arg1 : root :: HWND) -> root :: BOOL > , pub SWELL_IsButton : Option < unsafe extern "C" fn (arg1 : root :: HWND) -> root :: BOOL > , pub SWELL_IsStaticText : Option < unsafe extern "C" fn (arg1 : root :: HWND) -> root :: BOOL > , pub SWELL_GetDesiredControlSize : Option < unsafe extern "C" fn (hwnd : root :: HWND , r : * mut root :: RECT) > , pub AddFontResourceEx : Option < unsafe extern "C" fn (str_ : root :: LPCTSTR , fl : root :: DWORD , pdv : * mut :: std :: os :: raw :: c_void ,) -> :: std :: os :: raw :: c_int > , pub SWELL_Register_Cursor_Resource : Option < unsafe extern "C" fn (idx : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , hotspot_x : :: std :: os :: raw :: c_int , hotspot_y : :: std :: os :: raw :: c_int ,) > , pub SWELL_ChooseColor : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * mut root :: COLORREF , ncustom : :: std :: os :: raw :: c_int , custom : * mut root :: COLORREF ,) -> bool > , pub SWELL_ChooseFont : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * mut root :: LOGFONT ,) -> bool > , pub IsWindowEnabled : Option < unsafe extern "C" fn (arg1 : root :: HWND) -> bool > , pub GetClassName : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SWELL_SetClassName : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : * const :: std :: os :: raw :: c_char ,) > , pub SWELL_DisableContextMenu : Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : bool) > , pub EnumDisplayMonitors : Option < unsafe extern "C" fn (arg1 : root :: HDC , arg2 : root :: LPRECT , arg3 : root :: MONITORENUMPROC , arg4 : root :: LPARAM ,) -> root :: BOOL > , pub GetMonitorInfo : Option < unsafe extern "C" fn (arg1 : root :: HMONITOR , arg2 : * mut :: std :: os :: raw :: c_void ,) -> root :: BOOL > , pub SWELL_osx_is_dark_mode : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int) -> bool > , } impl SwellFunctionPointers { pub (crate) const TOTAL_COUNT : u32 = 336u32 ; } # [cfg (target_family = "windows")] mod windows { use crate :: bindings :: root ; extern "system" { pub fn GetDlgItem (arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) -> root :: HWND ; } extern "system" { pub fn ShowWindow (arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn DestroyWindow (hwnd : root :: HWND) ; } extern "system" { pub fn SetDlgItemInt (arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int , issigned : :: std :: os :: raw :: c_int) -> root :: BOOL ; } extern "system" { pub fn GetDlgItemInt (arg1 : root :: HWND , idx : :: std :: os :: raw :: c_int , translated : * mut root :: BOOL , issigned : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn CheckDlgButton (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int , check : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn IsDlgButtonChecked (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn EnableWindow (hwnd : root :: HWND , enable : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn SetFocus (hwnd : root :: HWND) ; } extern "system" { pub fn GetFocus () -> root :: HWND ; } extern "system" { pub fn SetForegroundWindow (hwnd : root :: HWND) ; } extern "system" { pub fn GetForegroundWindow () -> root :: HWND ; } extern "system" { pub fn SetCapture (hwnd : root :: HWND) -> root :: HWND ; } extern "system" { pub fn GetCapture () -> root :: HWND ; } extern "system" { pub fn ReleaseCapture () ; } extern "system" { pub fn IsChild (hwndParent : root :: HWND , hwndChild : root :: HWND) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn GetParent (hwnd : root :: HWND) -> root :: HWND ; } extern "system" { pub fn SetParent (hwnd : root :: HWND , newPar : root :: HWND) -> root :: HWND ; } extern "system" { pub fn GetWindow (hwnd : root :: HWND , what : :: std :: os :: raw :: c_int) -> root :: HWND ; } extern "system" { pub fn EnumWindows (proc_ : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lp : root :: LPARAM) -> root :: BOOL ; } extern "system" { pub fn ClientToScreen (hwnd : root :: HWND , p : * mut root :: POINT) ; } extern "system" { pub fn ScreenToClient (hwnd : root :: HWND , p : * mut root :: POINT) ; } extern "system" { pub fn GetWindowRect (hwnd : root :: HWND , r : * mut root :: RECT) -> bool ; } extern "system" { pub fn GetClientRect (hwnd : root :: HWND , r : * mut root :: RECT) ; } extern "system" { pub fn WindowFromPoint (p : root :: POINT) -> root :: HWND ; } extern "system" { pub fn SetWindowPos (hwnd : root :: HWND , unused : root :: HWND , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , cx : :: std :: os :: raw :: c_int , cy : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn InvalidateRect (hwnd : root :: HWND , r : * const root :: RECT , eraseBk : :: std :: os :: raw :: c_int) -> root :: BOOL ; } extern "system" { pub fn ScrollWindow (hwnd : root :: HWND , xamt : :: std :: os :: raw :: c_int , yamt : :: std :: os :: raw :: c_int , lpRect : * const root :: RECT , lpClipRect : * const root :: RECT) -> root :: BOOL ; } extern "system" { pub fn IsWindowVisible (hwnd : root :: HWND) -> bool ; } extern "system" { pub fn IsWindow (hwnd : root :: HWND) -> bool ; } extern "system" { pub fn SetTimer (hwnd : root :: HWND , timerid : root :: UINT_PTR , rate : root :: UINT , tProc : root :: TIMERPROC) -> root :: UINT_PTR ; } extern "system" { pub fn KillTimer (hwnd : root :: HWND , timerid : root :: UINT_PTR) -> root :: BOOL ; } extern "system" { pub fn CreatePopupMenu () -> root :: HMENU ; } extern "system" { pub fn DestroyMenu (hMenu : root :: HMENU) ; } extern "system" { pub fn GetSubMenu (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int) -> root :: HMENU ; } extern "system" { pub fn GetMenuItemCount (hMenu : root :: HMENU) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn GetMenuItemID (hMenu : root :: HMENU , pos : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn EnableMenuItem (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , en : :: std :: os :: raw :: c_int) -> bool ; } extern "system" { pub fn DeleteMenu (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int) -> bool ; } extern "system" { pub fn CheckMenuItem (hMenu : root :: HMENU , idx : :: std :: os :: raw :: c_int , chk : :: std :: os :: raw :: c_int) -> bool ; } extern "system" { pub fn DrawMenuBar (arg1 : root :: HWND) ; } extern "system" { pub fn TrackPopupMenu (hMenu : root :: HMENU , flags : :: std :: os :: raw :: c_int , xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int , resvd : :: std :: os :: raw :: c_int , hwnd : root :: HWND , r : * const root :: RECT) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn SetMenu (hwnd : root :: HWND , menu : root :: HMENU) -> root :: BOOL ; } extern "system" { pub fn GetMenu (hwnd : root :: HWND) -> root :: HMENU ; } extern "system" { pub fn EndDialog (arg1 : root :: HWND , arg2 : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn GetAsyncKeyState (key : :: std :: os :: raw :: c_int) -> root :: WORD ; } extern "system" { pub fn GetCursorPos (pt : * mut root :: POINT) ; } extern "system" { pub fn GetMessagePos () -> root :: DWORD ; } extern "system" { pub fn OpenClipboard (hwndDlg : root :: HWND) -> bool ; } extern "system" { pub fn CloseClipboard () ; } extern "system" { pub fn GetClipboardData (type_ : root :: UINT) -> root :: HANDLE ; } extern "system" { pub fn EmptyClipboard () ; } extern "system" { pub fn SetClipboardData (type_ : root :: UINT , h : root :: HANDLE) ; } extern "system" { pub fn EnumClipboardFormats (lastfmt : root :: UINT) -> root :: UINT ; } extern "system" { pub fn GlobalAlloc (flags : :: std :: os :: raw :: c_int , sz : :: std :: os :: raw :: c_int) -> root :: HANDLE ; } extern "system" { pub fn GlobalLock (h : root :: HANDLE) -> * mut :: std :: os :: raw :: c_void ; } extern "system" { pub fn GlobalUnlock (h : root :: HANDLE) ; } extern "system" { pub fn CreateSolidBrush (col : :: std :: os :: raw :: c_int) -> root :: HBRUSH ; } extern "system" { pub fn SetTextColor (ctx : root :: HDC , col : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn SetBkColor (ctx : root :: HDC , col : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn SetBkMode (ctx : root :: HDC , col : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn CreateIconIndirect (iconinfo : * mut root :: ICONINFO) -> root :: HICON ; } extern "system" { pub fn BitBlt (hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn StretchBlt (hdcOut : root :: HDC , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , hdcIn : root :: HDC , xin : :: std :: os :: raw :: c_int , yin : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int) ; } extern "system" { pub fn GetSysColor (idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn BeginPaint (arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT) -> root :: HDC ; } extern "system" { pub fn EndPaint (arg1 : root :: HWND , arg2 : * mut root :: PAINTSTRUCT) -> root :: BOOL ; } extern "system" { pub fn GetDC (arg1 : root :: HWND) -> root :: HDC ; } extern "system" { pub fn GetWindowDC (arg1 : root :: HWND) -> root :: HDC ; } extern "system" { pub fn ReleaseDC (arg1 : root :: HWND , arg2 : root :: HDC) ; } extern "system" { pub fn GetSystemMetrics (arg1 : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "system" { pub fn EnumChildWindows (hwnd : root :: HWND , cwEnumFunc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : root :: HWND , arg2 : root :: LPARAM ,) -> root :: BOOL , > , lParam : root :: LPARAM) -> root :: BOOL ; } extern "system" { pub fn IsWindowEnabled (arg1 : root :: HWND) -> bool ; } }
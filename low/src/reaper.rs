# ! [doc = r" This file is automatically generated by executing `cargo build --features generate`."] # ! [doc = r""] # ! [doc = r" **Make adjustments in `build.rs`, not in this file!**"] # ! [allow (clippy :: many_single_char_names)] # ! [allow (clippy :: too_many_arguments)] # ! [allow (clippy :: type_complexity)] # ! [allow (non_upper_case_globals)] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] use crate :: { bindings :: root , PluginContext } ; # [doc = r" This is the low-level API access point to all REAPER functions."] # [doc = r""] # [doc = r" In order to use it, you first must obtain an instance of this struct by invoking [`load()`]."] # [doc = r""] # [doc = r" `Default::default()` will give you an instance which panics on each function call. It's"] # [doc = r" intended to be used for example code only."] # [doc = r""] # [doc = r" # Panics"] # [doc = r""] # [doc = r" Please note that it's possible that functions are *not available*. This can be the case if"] # [doc = r" the user runs your plug-in in an older version of REAPER which doesn't have that function yet."] # [doc = r" The availability of a function can be checked by inspecting the respective function pointer"] # [doc = r" option accessible via the [`pointers()`] method. The actual methods in this structs are just"] # [doc = r" convenience methods which unwrap the function pointers and panic if they are not available."] # [doc = r""] # [doc = r" [`load()`]: #method.load"] # [doc = r" [`pointers()`]: #method.pointers"] # [derive (Copy , Clone , Debug , Default)] pub struct Reaper { pub (crate) pointers : ReaperFunctionPointers , pub (crate) plugin_context : Option < PluginContext > , } impl Reaper { # [doc = r" Loads all available REAPER functions from the given plug-in context."] # [doc = r""] # [doc = r" Returns a low-level `Reaper` instance which allows you to call these functions."] pub fn load (plugin_context : PluginContext) -> Reaper { let mut loaded_count = 0 ; let mut pointers = unsafe { ReaperFunctionPointers { loaded_count : 0 , __mergesort : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (__mergesort)) . as_ptr ())) , AddCustomizableMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddCustomizableMenu)) . as_ptr ())) , AddExtensionsMainMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddExtensionsMainMenu)) . as_ptr ())) , AddMediaItemToTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddMediaItemToTrack)) . as_ptr ())) , AddProjectMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddProjectMarker)) . as_ptr ())) , AddProjectMarker2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddProjectMarker2)) . as_ptr ())) , AddRemoveReaScript : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddRemoveReaScript)) . as_ptr ())) , AddTakeToMediaItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddTakeToMediaItem)) . as_ptr ())) , AddTempoTimeSigMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AddTempoTimeSigMarker)) . as_ptr ())) , adjustZoom : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (adjustZoom)) . as_ptr ())) , AnyTrackSolo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AnyTrackSolo)) . as_ptr ())) , APIExists : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (APIExists)) . as_ptr ())) , APITest : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (APITest)) . as_ptr ())) , ApplyNudge : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ApplyNudge)) . as_ptr ())) , ArmCommand : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ArmCommand)) . as_ptr ())) , Audio_Init : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Audio_Init)) . as_ptr ())) , Audio_IsPreBuffer : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Audio_IsPreBuffer)) . as_ptr ())) , Audio_IsRunning : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Audio_IsRunning)) . as_ptr ())) , Audio_Quit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Audio_Quit)) . as_ptr ())) , Audio_RegHardwareHook : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Audio_RegHardwareHook)) . as_ptr ())) , AudioAccessorStateChanged : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AudioAccessorStateChanged)) . as_ptr ())) , AudioAccessorUpdate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AudioAccessorUpdate)) . as_ptr ())) , AudioAccessorValidateState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (AudioAccessorValidateState)) . as_ptr ())) , BypassFxAllTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (BypassFxAllTracks)) . as_ptr ())) , CalcMediaSrcLoudness : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CalcMediaSrcLoudness)) . as_ptr ())) , CalculateNormalization : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CalculateNormalization)) . as_ptr ())) , CalculatePeaks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CalculatePeaks)) . as_ptr ())) , CalculatePeaksFloatSrcPtr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CalculatePeaksFloatSrcPtr)) . as_ptr ())) , ClearAllRecArmed : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ClearAllRecArmed)) . as_ptr ())) , ClearConsole : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ClearConsole)) . as_ptr ())) , ClearPeakCache : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ClearPeakCache)) . as_ptr ())) , ColorFromNative : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ColorFromNative)) . as_ptr ())) , ColorToNative : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ColorToNative)) . as_ptr ())) , CountActionShortcuts : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountActionShortcuts)) . as_ptr ())) , CountAutomationItems : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountAutomationItems)) . as_ptr ())) , CountEnvelopePoints : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountEnvelopePoints)) . as_ptr ())) , CountEnvelopePointsEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountEnvelopePointsEx)) . as_ptr ())) , CountMediaItems : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountMediaItems)) . as_ptr ())) , CountProjectMarkers : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountProjectMarkers)) . as_ptr ())) , CountSelectedMediaItems : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountSelectedMediaItems)) . as_ptr ())) , CountSelectedTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountSelectedTracks)) . as_ptr ())) , CountSelectedTracks2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountSelectedTracks2)) . as_ptr ())) , CountTakeEnvelopes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTakeEnvelopes)) . as_ptr ())) , CountTakes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTakes)) . as_ptr ())) , CountTCPFXParms : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTCPFXParms)) . as_ptr ())) , CountTempoTimeSigMarkers : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTempoTimeSigMarkers)) . as_ptr ())) , CountTrackEnvelopes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTrackEnvelopes)) . as_ptr ())) , CountTrackMediaItems : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTrackMediaItems)) . as_ptr ())) , CountTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CountTracks)) . as_ptr ())) , CreateLocalOscHandler : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateLocalOscHandler)) . as_ptr ())) , CreateMIDIInput : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateMIDIInput)) . as_ptr ())) , CreateMIDIOutput : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateMIDIOutput)) . as_ptr ())) , CreateNewMIDIItemInProj : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateNewMIDIItemInProj)) . as_ptr ())) , CreateTakeAudioAccessor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateTakeAudioAccessor)) . as_ptr ())) , CreateTrackAudioAccessor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateTrackAudioAccessor)) . as_ptr ())) , CreateTrackSend : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CreateTrackSend)) . as_ptr ())) , CSurf_FlushUndo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_FlushUndo)) . as_ptr ())) , CSurf_GetTouchState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_GetTouchState)) . as_ptr ())) , CSurf_GoEnd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_GoEnd)) . as_ptr ())) , CSurf_GoStart : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_GoStart)) . as_ptr ())) , CSurf_NumTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_NumTracks)) . as_ptr ())) , CSurf_OnArrow : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnArrow)) . as_ptr ())) , CSurf_OnFwd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnFwd)) . as_ptr ())) , CSurf_OnFXChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnFXChange)) . as_ptr ())) , CSurf_OnInputMonitorChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnInputMonitorChange)) . as_ptr ())) , CSurf_OnInputMonitorChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnInputMonitorChangeEx)) . as_ptr ())) , CSurf_OnMuteChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnMuteChange)) . as_ptr ())) , CSurf_OnMuteChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnMuteChangeEx)) . as_ptr ())) , CSurf_OnOscControlMessage : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnOscControlMessage)) . as_ptr ())) , CSurf_OnOscControlMessage2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnOscControlMessage2)) . as_ptr ())) , CSurf_OnPanChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnPanChange)) . as_ptr ())) , CSurf_OnPanChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnPanChangeEx)) . as_ptr ())) , CSurf_OnPause : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnPause)) . as_ptr ())) , CSurf_OnPlay : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnPlay)) . as_ptr ())) , CSurf_OnPlayRateChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnPlayRateChange)) . as_ptr ())) , CSurf_OnRecArmChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRecArmChange)) . as_ptr ())) , CSurf_OnRecArmChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRecArmChangeEx)) . as_ptr ())) , CSurf_OnRecord : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRecord)) . as_ptr ())) , CSurf_OnRecvPanChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRecvPanChange)) . as_ptr ())) , CSurf_OnRecvVolumeChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRecvVolumeChange)) . as_ptr ())) , CSurf_OnRew : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRew)) . as_ptr ())) , CSurf_OnRewFwd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnRewFwd)) . as_ptr ())) , CSurf_OnScroll : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnScroll)) . as_ptr ())) , CSurf_OnSelectedChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnSelectedChange)) . as_ptr ())) , CSurf_OnSendPanChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnSendPanChange)) . as_ptr ())) , CSurf_OnSendVolumeChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnSendVolumeChange)) . as_ptr ())) , CSurf_OnSoloChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnSoloChange)) . as_ptr ())) , CSurf_OnSoloChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnSoloChangeEx)) . as_ptr ())) , CSurf_OnStop : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnStop)) . as_ptr ())) , CSurf_OnTempoChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnTempoChange)) . as_ptr ())) , CSurf_OnTrackSelection : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnTrackSelection)) . as_ptr ())) , CSurf_OnVolumeChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnVolumeChange)) . as_ptr ())) , CSurf_OnVolumeChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnVolumeChangeEx)) . as_ptr ())) , CSurf_OnWidthChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnWidthChange)) . as_ptr ())) , CSurf_OnWidthChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnWidthChangeEx)) . as_ptr ())) , CSurf_OnZoom : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_OnZoom)) . as_ptr ())) , CSurf_ResetAllCachedVolPanStates : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_ResetAllCachedVolPanStates)) . as_ptr ())) , CSurf_ScrubAmt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_ScrubAmt)) . as_ptr ())) , CSurf_SetAutoMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetAutoMode)) . as_ptr ())) , CSurf_SetPlayState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetPlayState)) . as_ptr ())) , CSurf_SetRepeatState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetRepeatState)) . as_ptr ())) , CSurf_SetSurfaceMute : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetSurfaceMute)) . as_ptr ())) , CSurf_SetSurfacePan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetSurfacePan)) . as_ptr ())) , CSurf_SetSurfaceRecArm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetSurfaceRecArm)) . as_ptr ())) , CSurf_SetSurfaceSelected : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetSurfaceSelected)) . as_ptr ())) , CSurf_SetSurfaceSolo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetSurfaceSolo)) . as_ptr ())) , CSurf_SetSurfaceVolume : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetSurfaceVolume)) . as_ptr ())) , CSurf_SetTrackListChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_SetTrackListChange)) . as_ptr ())) , CSurf_TrackFromID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_TrackFromID)) . as_ptr ())) , CSurf_TrackToID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CSurf_TrackToID)) . as_ptr ())) , DB2SLIDER : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DB2SLIDER)) . as_ptr ())) , DeleteActionShortcut : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteActionShortcut)) . as_ptr ())) , DeleteEnvelopePointEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteEnvelopePointEx)) . as_ptr ())) , DeleteEnvelopePointRange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteEnvelopePointRange)) . as_ptr ())) , DeleteEnvelopePointRangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteEnvelopePointRangeEx)) . as_ptr ())) , DeleteExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteExtState)) . as_ptr ())) , DeleteProjectMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteProjectMarker)) . as_ptr ())) , DeleteProjectMarkerByIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteProjectMarkerByIndex)) . as_ptr ())) , DeleteTakeMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteTakeMarker)) . as_ptr ())) , DeleteTakeStretchMarkers : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteTakeStretchMarkers)) . as_ptr ())) , DeleteTempoTimeSigMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteTempoTimeSigMarker)) . as_ptr ())) , DeleteTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteTrack)) . as_ptr ())) , DeleteTrackMediaItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DeleteTrackMediaItem)) . as_ptr ())) , DestroyAudioAccessor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DestroyAudioAccessor)) . as_ptr ())) , DestroyLocalOscHandler : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DestroyLocalOscHandler)) . as_ptr ())) , DoActionShortcutDialog : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DoActionShortcutDialog)) . as_ptr ())) , Dock_UpdateDockID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Dock_UpdateDockID)) . as_ptr ())) , DockGetPosition : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockGetPosition)) . as_ptr ())) , DockIsChildOfDock : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockIsChildOfDock)) . as_ptr ())) , DockWindowActivate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockWindowActivate)) . as_ptr ())) , DockWindowAdd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockWindowAdd)) . as_ptr ())) , DockWindowAddEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockWindowAddEx)) . as_ptr ())) , DockWindowRefresh : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockWindowRefresh)) . as_ptr ())) , DockWindowRefreshForHWND : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockWindowRefreshForHWND)) . as_ptr ())) , DockWindowRemove : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DockWindowRemove)) . as_ptr ())) , DuplicateCustomizableMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (DuplicateCustomizableMenu)) . as_ptr ())) , EditTempoTimeSigMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EditTempoTimeSigMarker)) . as_ptr ())) , EnsureNotCompletelyOffscreen : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnsureNotCompletelyOffscreen)) . as_ptr ())) , EnumerateFiles : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumerateFiles)) . as_ptr ())) , EnumerateSubdirectories : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumerateSubdirectories)) . as_ptr ())) , EnumPitchShiftModes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumPitchShiftModes)) . as_ptr ())) , EnumPitchShiftSubModes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumPitchShiftSubModes)) . as_ptr ())) , EnumProjectMarkers : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumProjectMarkers)) . as_ptr ())) , EnumProjectMarkers2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumProjectMarkers2)) . as_ptr ())) , EnumProjectMarkers3 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumProjectMarkers3)) . as_ptr ())) , EnumProjects : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumProjects)) . as_ptr ())) , EnumProjExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumProjExtState)) . as_ptr ())) , EnumRegionRenderMatrix : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumRegionRenderMatrix)) . as_ptr ())) , EnumTrackMIDIProgramNames : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumTrackMIDIProgramNames)) . as_ptr ())) , EnumTrackMIDIProgramNamesEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (EnumTrackMIDIProgramNamesEx)) . as_ptr ())) , Envelope_Evaluate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Envelope_Evaluate)) . as_ptr ())) , Envelope_FormatValue : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Envelope_FormatValue)) . as_ptr ())) , Envelope_GetParentTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Envelope_GetParentTake)) . as_ptr ())) , Envelope_GetParentTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Envelope_GetParentTrack)) . as_ptr ())) , Envelope_SortPoints : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Envelope_SortPoints)) . as_ptr ())) , Envelope_SortPointsEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Envelope_SortPointsEx)) . as_ptr ())) , ExecProcess : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ExecProcess)) . as_ptr ())) , file_exists : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (file_exists)) . as_ptr ())) , FindTempoTimeSigMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (FindTempoTimeSigMarker)) . as_ptr ())) , format_timestr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (format_timestr)) . as_ptr ())) , format_timestr_len : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (format_timestr_len)) . as_ptr ())) , format_timestr_pos : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (format_timestr_pos)) . as_ptr ())) , FreeHeapPtr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (FreeHeapPtr)) . as_ptr ())) , genGuid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (genGuid)) . as_ptr ())) , get_config_var : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (get_config_var)) . as_ptr ())) , get_config_var_string : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (get_config_var_string)) . as_ptr ())) , get_ini_file : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (get_ini_file)) . as_ptr ())) , get_midi_config_var : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (get_midi_config_var)) . as_ptr ())) , GetActionShortcutDesc : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetActionShortcutDesc)) . as_ptr ())) , GetActiveTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetActiveTake)) . as_ptr ())) , GetAllProjectPlayStates : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAllProjectPlayStates)) . as_ptr ())) , GetAppVersion : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAppVersion)) . as_ptr ())) , GetArmedCommand : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetArmedCommand)) . as_ptr ())) , GetAudioAccessorEndTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAudioAccessorEndTime)) . as_ptr ())) , GetAudioAccessorHash : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAudioAccessorHash)) . as_ptr ())) , GetAudioAccessorSamples : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAudioAccessorSamples)) . as_ptr ())) , GetAudioAccessorStartTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAudioAccessorStartTime)) . as_ptr ())) , GetAudioDeviceInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetAudioDeviceInfo)) . as_ptr ())) , GetColorTheme : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetColorTheme)) . as_ptr ())) , GetColorThemeStruct : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetColorThemeStruct)) . as_ptr ())) , GetConfigWantsDock : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetConfigWantsDock)) . as_ptr ())) , GetContextMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetContextMenu)) . as_ptr ())) , GetCurrentProjectInLoadSave : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetCurrentProjectInLoadSave)) . as_ptr ())) , GetCursorContext : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetCursorContext)) . as_ptr ())) , GetCursorContext2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetCursorContext2)) . as_ptr ())) , GetCursorPosition : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetCursorPosition)) . as_ptr ())) , GetCursorPositionEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetCursorPositionEx)) . as_ptr ())) , GetDisplayedMediaItemColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetDisplayedMediaItemColor)) . as_ptr ())) , GetDisplayedMediaItemColor2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetDisplayedMediaItemColor2)) . as_ptr ())) , GetEnvelopeInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopeInfo_Value)) . as_ptr ())) , GetEnvelopeName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopeName)) . as_ptr ())) , GetEnvelopePoint : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopePoint)) . as_ptr ())) , GetEnvelopePointByTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopePointByTime)) . as_ptr ())) , GetEnvelopePointByTimeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopePointByTimeEx)) . as_ptr ())) , GetEnvelopePointEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopePointEx)) . as_ptr ())) , GetEnvelopeScalingMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopeScalingMode)) . as_ptr ())) , GetEnvelopeStateChunk : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopeStateChunk)) . as_ptr ())) , GetEnvelopeUIState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetEnvelopeUIState)) . as_ptr ())) , GetExePath : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetExePath)) . as_ptr ())) , GetExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetExtState)) . as_ptr ())) , GetFocusedFX : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetFocusedFX)) . as_ptr ())) , GetFocusedFX2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetFocusedFX2)) . as_ptr ())) , GetFreeDiskSpaceForRecordPath : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetFreeDiskSpaceForRecordPath)) . as_ptr ())) , GetFXEnvelope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetFXEnvelope)) . as_ptr ())) , GetGlobalAutomationOverride : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetGlobalAutomationOverride)) . as_ptr ())) , GetHZoomLevel : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetHZoomLevel)) . as_ptr ())) , GetIconThemePointer : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetIconThemePointer)) . as_ptr ())) , GetIconThemePointerForDPI : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetIconThemePointerForDPI)) . as_ptr ())) , GetIconThemeStruct : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetIconThemeStruct)) . as_ptr ())) , GetInputChannelName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetInputChannelName)) . as_ptr ())) , GetInputOutputLatency : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetInputOutputLatency)) . as_ptr ())) , GetItemEditingTime2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetItemEditingTime2)) . as_ptr ())) , GetItemFromPoint : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetItemFromPoint)) . as_ptr ())) , GetItemProjectContext : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetItemProjectContext)) . as_ptr ())) , GetItemStateChunk : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetItemStateChunk)) . as_ptr ())) , GetLastColorThemeFile : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetLastColorThemeFile)) . as_ptr ())) , GetLastMarkerAndCurRegion : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetLastMarkerAndCurRegion)) . as_ptr ())) , GetLastTouchedFX : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetLastTouchedFX)) . as_ptr ())) , GetLastTouchedTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetLastTouchedTrack)) . as_ptr ())) , GetMainHwnd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMainHwnd)) . as_ptr ())) , GetMasterMuteSoloFlags : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMasterMuteSoloFlags)) . as_ptr ())) , GetMasterTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMasterTrack)) . as_ptr ())) , GetMasterTrackVisibility : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMasterTrackVisibility)) . as_ptr ())) , GetMaxMidiInputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMaxMidiInputs)) . as_ptr ())) , GetMaxMidiOutputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMaxMidiOutputs)) . as_ptr ())) , GetMediaFileMetadata : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaFileMetadata)) . as_ptr ())) , GetMediaItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItem)) . as_ptr ())) , GetMediaItem_Track : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItem_Track)) . as_ptr ())) , GetMediaItemInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemInfo_Value)) . as_ptr ())) , GetMediaItemNumTakes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemNumTakes)) . as_ptr ())) , GetMediaItemTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTake)) . as_ptr ())) , GetMediaItemTake_Item : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTake_Item)) . as_ptr ())) , GetMediaItemTake_Peaks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTake_Peaks)) . as_ptr ())) , GetMediaItemTake_Source : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTake_Source)) . as_ptr ())) , GetMediaItemTake_Track : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTake_Track)) . as_ptr ())) , GetMediaItemTakeByGUID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTakeByGUID)) . as_ptr ())) , GetMediaItemTakeInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTakeInfo_Value)) . as_ptr ())) , GetMediaItemTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaItemTrack)) . as_ptr ())) , GetMediaSourceFileName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaSourceFileName)) . as_ptr ())) , GetMediaSourceLength : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaSourceLength)) . as_ptr ())) , GetMediaSourceNumChannels : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaSourceNumChannels)) . as_ptr ())) , GetMediaSourceParent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaSourceParent)) . as_ptr ())) , GetMediaSourceSampleRate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaSourceSampleRate)) . as_ptr ())) , GetMediaSourceType : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaSourceType)) . as_ptr ())) , GetMediaTrackInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMediaTrackInfo_Value)) . as_ptr ())) , GetMIDIInputName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMIDIInputName)) . as_ptr ())) , GetMIDIOutputName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMIDIOutputName)) . as_ptr ())) , GetMixerScroll : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMixerScroll)) . as_ptr ())) , GetMouseModifier : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMouseModifier)) . as_ptr ())) , GetMousePosition : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMousePosition)) . as_ptr ())) , GetNumAudioInputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetNumAudioInputs)) . as_ptr ())) , GetNumAudioOutputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetNumAudioOutputs)) . as_ptr ())) , GetNumMIDIInputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetNumMIDIInputs)) . as_ptr ())) , GetNumMIDIOutputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetNumMIDIOutputs)) . as_ptr ())) , GetNumTakeMarkers : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetNumTakeMarkers)) . as_ptr ())) , GetNumTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetNumTracks)) . as_ptr ())) , GetOS : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetOS)) . as_ptr ())) , GetOutputChannelName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetOutputChannelName)) . as_ptr ())) , GetOutputLatency : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetOutputLatency)) . as_ptr ())) , GetParentTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetParentTrack)) . as_ptr ())) , GetPeakFileName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPeakFileName)) . as_ptr ())) , GetPeakFileNameEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPeakFileNameEx)) . as_ptr ())) , GetPeakFileNameEx2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPeakFileNameEx2)) . as_ptr ())) , GetPeaksBitmap : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPeaksBitmap)) . as_ptr ())) , GetPlayPosition : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPlayPosition)) . as_ptr ())) , GetPlayPosition2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPlayPosition2)) . as_ptr ())) , GetPlayPosition2Ex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPlayPosition2Ex)) . as_ptr ())) , GetPlayPositionEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPlayPositionEx)) . as_ptr ())) , GetPlayState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPlayState)) . as_ptr ())) , GetPlayStateEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPlayStateEx)) . as_ptr ())) , GetPreferredDiskReadMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPreferredDiskReadMode)) . as_ptr ())) , GetPreferredDiskReadModePeak : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPreferredDiskReadModePeak)) . as_ptr ())) , GetPreferredDiskWriteMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetPreferredDiskWriteMode)) . as_ptr ())) , GetProjectLength : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectLength)) . as_ptr ())) , GetProjectName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectName)) . as_ptr ())) , GetProjectPath : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectPath)) . as_ptr ())) , GetProjectPathEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectPathEx)) . as_ptr ())) , GetProjectStateChangeCount : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectStateChangeCount)) . as_ptr ())) , GetProjectTimeOffset : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectTimeOffset)) . as_ptr ())) , GetProjectTimeSignature : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectTimeSignature)) . as_ptr ())) , GetProjectTimeSignature2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjectTimeSignature2)) . as_ptr ())) , GetProjExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetProjExtState)) . as_ptr ())) , GetResourcePath : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetResourcePath)) . as_ptr ())) , GetSelectedEnvelope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSelectedEnvelope)) . as_ptr ())) , GetSelectedMediaItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSelectedMediaItem)) . as_ptr ())) , GetSelectedTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSelectedTrack)) . as_ptr ())) , GetSelectedTrack2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSelectedTrack2)) . as_ptr ())) , GetSelectedTrackEnvelope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSelectedTrackEnvelope)) . as_ptr ())) , GetSet_ArrangeView2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSet_ArrangeView2)) . as_ptr ())) , GetSet_LoopTimeRange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSet_LoopTimeRange)) . as_ptr ())) , GetSet_LoopTimeRange2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSet_LoopTimeRange2)) . as_ptr ())) , GetSetAutomationItemInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetAutomationItemInfo)) . as_ptr ())) , GetSetAutomationItemInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetAutomationItemInfo_String)) . as_ptr ())) , GetSetEnvelopeInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetEnvelopeInfo_String)) . as_ptr ())) , GetSetEnvelopeState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetEnvelopeState)) . as_ptr ())) , GetSetEnvelopeState2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetEnvelopeState2)) . as_ptr ())) , GetSetItemState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetItemState)) . as_ptr ())) , GetSetItemState2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetItemState2)) . as_ptr ())) , GetSetMediaItemInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetMediaItemInfo)) . as_ptr ())) , GetSetMediaItemInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetMediaItemInfo_String)) . as_ptr ())) , GetSetMediaItemTakeInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetMediaItemTakeInfo)) . as_ptr ())) , GetSetMediaItemTakeInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetMediaItemTakeInfo_String)) . as_ptr ())) , GetSetMediaTrackInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetMediaTrackInfo)) . as_ptr ())) , GetSetMediaTrackInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetMediaTrackInfo_String)) . as_ptr ())) , GetSetObjectState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetObjectState)) . as_ptr ())) , GetSetObjectState2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetObjectState2)) . as_ptr ())) , GetSetProjectAuthor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetProjectAuthor)) . as_ptr ())) , GetSetProjectGrid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetProjectGrid)) . as_ptr ())) , GetSetProjectInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetProjectInfo)) . as_ptr ())) , GetSetProjectInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetProjectInfo_String)) . as_ptr ())) , GetSetProjectNotes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetProjectNotes)) . as_ptr ())) , GetSetRepeat : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetRepeat)) . as_ptr ())) , GetSetRepeatEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetRepeatEx)) . as_ptr ())) , GetSetTrackGroupMembership : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackGroupMembership)) . as_ptr ())) , GetSetTrackGroupMembershipHigh : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackGroupMembershipHigh)) . as_ptr ())) , GetSetTrackMIDISupportFile : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackMIDISupportFile)) . as_ptr ())) , GetSetTrackSendInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackSendInfo)) . as_ptr ())) , GetSetTrackSendInfo_String : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackSendInfo_String)) . as_ptr ())) , GetSetTrackState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackState)) . as_ptr ())) , GetSetTrackState2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSetTrackState2)) . as_ptr ())) , GetSubProjectFromSource : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetSubProjectFromSource)) . as_ptr ())) , GetTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTake)) . as_ptr ())) , GetTakeEnvelope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeEnvelope)) . as_ptr ())) , GetTakeEnvelopeByName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeEnvelopeByName)) . as_ptr ())) , GetTakeMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeMarker)) . as_ptr ())) , GetTakeName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeName)) . as_ptr ())) , GetTakeNumStretchMarkers : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeNumStretchMarkers)) . as_ptr ())) , GetTakeStretchMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeStretchMarker)) . as_ptr ())) , GetTakeStretchMarkerSlope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTakeStretchMarkerSlope)) . as_ptr ())) , GetTCPFXParm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTCPFXParm)) . as_ptr ())) , GetTempoMatchPlayRate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTempoMatchPlayRate)) . as_ptr ())) , GetTempoTimeSigMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTempoTimeSigMarker)) . as_ptr ())) , GetThemeColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetThemeColor)) . as_ptr ())) , GetThingFromPoint : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetThingFromPoint)) . as_ptr ())) , GetToggleCommandState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetToggleCommandState)) . as_ptr ())) , GetToggleCommandState2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetToggleCommandState2)) . as_ptr ())) , GetToggleCommandStateEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetToggleCommandStateEx)) . as_ptr ())) , GetToggleCommandStateThroughHooks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetToggleCommandStateThroughHooks)) . as_ptr ())) , GetTooltipWindow : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTooltipWindow)) . as_ptr ())) , GetTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrack)) . as_ptr ())) , GetTrackAutomationMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackAutomationMode)) . as_ptr ())) , GetTrackColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackColor)) . as_ptr ())) , GetTrackDepth : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackDepth)) . as_ptr ())) , GetTrackEnvelope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackEnvelope)) . as_ptr ())) , GetTrackEnvelopeByChunkName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackEnvelopeByChunkName)) . as_ptr ())) , GetTrackEnvelopeByName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackEnvelopeByName)) . as_ptr ())) , GetTrackFromPoint : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackFromPoint)) . as_ptr ())) , GetTrackGUID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackGUID)) . as_ptr ())) , GetTrackInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackInfo)) . as_ptr ())) , GetTrackMediaItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackMediaItem)) . as_ptr ())) , GetTrackMIDILyrics : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackMIDILyrics)) . as_ptr ())) , GetTrackMIDINoteName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackMIDINoteName)) . as_ptr ())) , GetTrackMIDINoteNameEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackMIDINoteNameEx)) . as_ptr ())) , GetTrackMIDINoteRange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackMIDINoteRange)) . as_ptr ())) , GetTrackName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackName)) . as_ptr ())) , GetTrackNumMediaItems : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackNumMediaItems)) . as_ptr ())) , GetTrackNumSends : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackNumSends)) . as_ptr ())) , GetTrackReceiveName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackReceiveName)) . as_ptr ())) , GetTrackReceiveUIMute : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackReceiveUIMute)) . as_ptr ())) , GetTrackReceiveUIVolPan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackReceiveUIVolPan)) . as_ptr ())) , GetTrackSendInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackSendInfo_Value)) . as_ptr ())) , GetTrackSendName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackSendName)) . as_ptr ())) , GetTrackSendUIMute : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackSendUIMute)) . as_ptr ())) , GetTrackSendUIVolPan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackSendUIVolPan)) . as_ptr ())) , GetTrackState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackState)) . as_ptr ())) , GetTrackStateChunk : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackStateChunk)) . as_ptr ())) , GetTrackUIMute : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackUIMute)) . as_ptr ())) , GetTrackUIPan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackUIPan)) . as_ptr ())) , GetTrackUIVolPan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetTrackUIVolPan)) . as_ptr ())) , GetUnderrunTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetUnderrunTime)) . as_ptr ())) , GetUserFileNameForRead : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetUserFileNameForRead)) . as_ptr ())) , GetUserInputs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetUserInputs)) . as_ptr ())) , GoToMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GoToMarker)) . as_ptr ())) , GoToRegion : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GoToRegion)) . as_ptr ())) , GR_SelectColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GR_SelectColor)) . as_ptr ())) , GSC_mainwnd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GSC_mainwnd)) . as_ptr ())) , guidToString : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (guidToString)) . as_ptr ())) , HasExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (HasExtState)) . as_ptr ())) , HasTrackMIDIPrograms : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (HasTrackMIDIPrograms)) . as_ptr ())) , HasTrackMIDIProgramsEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (HasTrackMIDIProgramsEx)) . as_ptr ())) , Help_Set : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Help_Set)) . as_ptr ())) , HiresPeaksFromSource : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (HiresPeaksFromSource)) . as_ptr ())) , image_resolve_fn : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (image_resolve_fn)) . as_ptr ())) , InsertAutomationItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InsertAutomationItem)) . as_ptr ())) , InsertEnvelopePoint : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InsertEnvelopePoint)) . as_ptr ())) , InsertEnvelopePointEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InsertEnvelopePointEx)) . as_ptr ())) , InsertMedia : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InsertMedia)) . as_ptr ())) , InsertMediaSection : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InsertMediaSection)) . as_ptr ())) , InsertTrackAtIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InsertTrackAtIndex)) . as_ptr ())) , IsInRealTimeAudio : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsInRealTimeAudio)) . as_ptr ())) , IsItemTakeActiveForPlayback : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsItemTakeActiveForPlayback)) . as_ptr ())) , IsMediaExtension : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsMediaExtension)) . as_ptr ())) , IsMediaItemSelected : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsMediaItemSelected)) . as_ptr ())) , IsProjectDirty : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsProjectDirty)) . as_ptr ())) , IsREAPER : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsREAPER)) . as_ptr ())) , IsTrackSelected : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsTrackSelected)) . as_ptr ())) , IsTrackVisible : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (IsTrackVisible)) . as_ptr ())) , joystick_create : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_create)) . as_ptr ())) , joystick_destroy : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_destroy)) . as_ptr ())) , joystick_enum : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_enum)) . as_ptr ())) , joystick_getaxis : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_getaxis)) . as_ptr ())) , joystick_getbuttonmask : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_getbuttonmask)) . as_ptr ())) , joystick_getinfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_getinfo)) . as_ptr ())) , joystick_getpov : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_getpov)) . as_ptr ())) , joystick_update : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (joystick_update)) . as_ptr ())) , kbd_enumerateActions : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_enumerateActions)) . as_ptr ())) , kbd_formatKeyName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_formatKeyName)) . as_ptr ())) , kbd_getCommandName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_getCommandName)) . as_ptr ())) , kbd_getTextFromCmd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_getTextFromCmd)) . as_ptr ())) , KBD_OnMainActionEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (KBD_OnMainActionEx)) . as_ptr ())) , kbd_OnMidiEvent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_OnMidiEvent)) . as_ptr ())) , kbd_OnMidiList : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_OnMidiList)) . as_ptr ())) , kbd_ProcessActionsMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_ProcessActionsMenu)) . as_ptr ())) , kbd_processMidiEventActionEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_processMidiEventActionEx)) . as_ptr ())) , kbd_reprocessMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_reprocessMenu)) . as_ptr ())) , kbd_RunCommandThroughHooks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_RunCommandThroughHooks)) . as_ptr ())) , kbd_translateAccelerator : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_translateAccelerator)) . as_ptr ())) , kbd_translateMouse : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (kbd_translateMouse)) . as_ptr ())) , LICE__Destroy : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__Destroy)) . as_ptr ())) , LICE__DestroyFont : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__DestroyFont)) . as_ptr ())) , LICE__DrawText : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__DrawText)) . as_ptr ())) , LICE__GetBits : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__GetBits)) . as_ptr ())) , LICE__GetDC : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__GetDC)) . as_ptr ())) , LICE__GetHeight : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__GetHeight)) . as_ptr ())) , LICE__GetRowSpan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__GetRowSpan)) . as_ptr ())) , LICE__GetWidth : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__GetWidth)) . as_ptr ())) , LICE__IsFlipped : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__IsFlipped)) . as_ptr ())) , LICE__resize : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__resize)) . as_ptr ())) , LICE__SetBkColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__SetBkColor)) . as_ptr ())) , LICE__SetFromHFont : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__SetFromHFont)) . as_ptr ())) , LICE__SetTextColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__SetTextColor)) . as_ptr ())) , LICE__SetTextCombineMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE__SetTextCombineMode)) . as_ptr ())) , LICE_Arc : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Arc)) . as_ptr ())) , LICE_Blit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Blit)) . as_ptr ())) , LICE_Blur : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Blur)) . as_ptr ())) , LICE_BorderedRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_BorderedRect)) . as_ptr ())) , LICE_Circle : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Circle)) . as_ptr ())) , LICE_Clear : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Clear)) . as_ptr ())) , LICE_ClearRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_ClearRect)) . as_ptr ())) , LICE_ClipLine : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_ClipLine)) . as_ptr ())) , LICE_Copy : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Copy)) . as_ptr ())) , LICE_CreateBitmap : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_CreateBitmap)) . as_ptr ())) , LICE_CreateFont : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_CreateFont)) . as_ptr ())) , LICE_DrawCBezier : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_DrawCBezier)) . as_ptr ())) , LICE_DrawChar : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_DrawChar)) . as_ptr ())) , LICE_DrawGlyph : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_DrawGlyph)) . as_ptr ())) , LICE_DrawRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_DrawRect)) . as_ptr ())) , LICE_DrawText : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_DrawText)) . as_ptr ())) , LICE_FillCBezier : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_FillCBezier)) . as_ptr ())) , LICE_FillCircle : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_FillCircle)) . as_ptr ())) , LICE_FillConvexPolygon : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_FillConvexPolygon)) . as_ptr ())) , LICE_FillRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_FillRect)) . as_ptr ())) , LICE_FillTrapezoid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_FillTrapezoid)) . as_ptr ())) , LICE_FillTriangle : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_FillTriangle)) . as_ptr ())) , LICE_GetPixel : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_GetPixel)) . as_ptr ())) , LICE_GradRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_GradRect)) . as_ptr ())) , LICE_Line : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_Line)) . as_ptr ())) , LICE_LineInt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_LineInt)) . as_ptr ())) , LICE_LoadPNG : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_LoadPNG)) . as_ptr ())) , LICE_LoadPNGFromResource : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_LoadPNGFromResource)) . as_ptr ())) , LICE_MeasureText : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_MeasureText)) . as_ptr ())) , LICE_MultiplyAddRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_MultiplyAddRect)) . as_ptr ())) , LICE_PutPixel : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_PutPixel)) . as_ptr ())) , LICE_RotatedBlit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_RotatedBlit)) . as_ptr ())) , LICE_RoundRect : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_RoundRect)) . as_ptr ())) , LICE_ScaledBlit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_ScaledBlit)) . as_ptr ())) , LICE_SimpleFill : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_SimpleFill)) . as_ptr ())) , LICE_ThickFLine : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LICE_ThickFLine)) . as_ptr ())) , LocalizeString : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (LocalizeString)) . as_ptr ())) , Loop_OnArrow : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Loop_OnArrow)) . as_ptr ())) , Main_OnCommand : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Main_OnCommand)) . as_ptr ())) , Main_OnCommandEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Main_OnCommandEx)) . as_ptr ())) , Main_openProject : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Main_openProject)) . as_ptr ())) , Main_SaveProject : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Main_SaveProject)) . as_ptr ())) , Main_SaveProjectEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Main_SaveProjectEx)) . as_ptr ())) , Main_UpdateLoopInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Main_UpdateLoopInfo)) . as_ptr ())) , MarkProjectDirty : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MarkProjectDirty)) . as_ptr ())) , MarkTrackItemsDirty : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MarkTrackItemsDirty)) . as_ptr ())) , Master_GetPlayRate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Master_GetPlayRate)) . as_ptr ())) , Master_GetPlayRateAtTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Master_GetPlayRateAtTime)) . as_ptr ())) , Master_GetTempo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Master_GetTempo)) . as_ptr ())) , Master_NormalizePlayRate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Master_NormalizePlayRate)) . as_ptr ())) , Master_NormalizeTempo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Master_NormalizeTempo)) . as_ptr ())) , MB : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MB)) . as_ptr ())) , MediaItemDescendsFromTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MediaItemDescendsFromTrack)) . as_ptr ())) , MIDI_CountEvts : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_CountEvts)) . as_ptr ())) , MIDI_DeleteCC : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_DeleteCC)) . as_ptr ())) , MIDI_DeleteEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_DeleteEvt)) . as_ptr ())) , MIDI_DeleteNote : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_DeleteNote)) . as_ptr ())) , MIDI_DeleteTextSysexEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_DeleteTextSysexEvt)) . as_ptr ())) , MIDI_DisableSort : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_DisableSort)) . as_ptr ())) , MIDI_EnumSelCC : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_EnumSelCC)) . as_ptr ())) , MIDI_EnumSelEvts : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_EnumSelEvts)) . as_ptr ())) , MIDI_EnumSelNotes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_EnumSelNotes)) . as_ptr ())) , MIDI_EnumSelTextSysexEvts : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_EnumSelTextSysexEvts)) . as_ptr ())) , MIDI_eventlist_Create : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_eventlist_Create)) . as_ptr ())) , MIDI_eventlist_Destroy : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_eventlist_Destroy)) . as_ptr ())) , MIDI_GetAllEvts : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetAllEvts)) . as_ptr ())) , MIDI_GetCC : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetCC)) . as_ptr ())) , MIDI_GetCCShape : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetCCShape)) . as_ptr ())) , MIDI_GetEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetEvt)) . as_ptr ())) , MIDI_GetGrid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetGrid)) . as_ptr ())) , MIDI_GetHash : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetHash)) . as_ptr ())) , MIDI_GetNote : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetNote)) . as_ptr ())) , MIDI_GetPPQPos_EndOfMeasure : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetPPQPos_EndOfMeasure)) . as_ptr ())) , MIDI_GetPPQPos_StartOfMeasure : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetPPQPos_StartOfMeasure)) . as_ptr ())) , MIDI_GetPPQPosFromProjQN : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetPPQPosFromProjQN)) . as_ptr ())) , MIDI_GetPPQPosFromProjTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetPPQPosFromProjTime)) . as_ptr ())) , MIDI_GetProjQNFromPPQPos : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetProjQNFromPPQPos)) . as_ptr ())) , MIDI_GetProjTimeFromPPQPos : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetProjTimeFromPPQPos)) . as_ptr ())) , MIDI_GetRecentInputEvent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetRecentInputEvent)) . as_ptr ())) , MIDI_GetScale : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetScale)) . as_ptr ())) , MIDI_GetTextSysexEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetTextSysexEvt)) . as_ptr ())) , MIDI_GetTrackHash : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_GetTrackHash)) . as_ptr ())) , midi_init : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (midi_init)) . as_ptr ())) , MIDI_InsertCC : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_InsertCC)) . as_ptr ())) , MIDI_InsertEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_InsertEvt)) . as_ptr ())) , MIDI_InsertNote : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_InsertNote)) . as_ptr ())) , MIDI_InsertTextSysexEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_InsertTextSysexEvt)) . as_ptr ())) , midi_reinit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (midi_reinit)) . as_ptr ())) , MIDI_SelectAll : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SelectAll)) . as_ptr ())) , MIDI_SetAllEvts : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetAllEvts)) . as_ptr ())) , MIDI_SetCC : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetCC)) . as_ptr ())) , MIDI_SetCCShape : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetCCShape)) . as_ptr ())) , MIDI_SetEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetEvt)) . as_ptr ())) , MIDI_SetItemExtents : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetItemExtents)) . as_ptr ())) , MIDI_SetNote : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetNote)) . as_ptr ())) , MIDI_SetTextSysexEvt : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_SetTextSysexEvt)) . as_ptr ())) , MIDI_Sort : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDI_Sort)) . as_ptr ())) , MIDIEditor_EnumTakes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_EnumTakes)) . as_ptr ())) , MIDIEditor_GetActive : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_GetActive)) . as_ptr ())) , MIDIEditor_GetMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_GetMode)) . as_ptr ())) , MIDIEditor_GetSetting_int : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_GetSetting_int)) . as_ptr ())) , MIDIEditor_GetSetting_str : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_GetSetting_str)) . as_ptr ())) , MIDIEditor_GetTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_GetTake)) . as_ptr ())) , MIDIEditor_LastFocused_OnCommand : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_LastFocused_OnCommand)) . as_ptr ())) , MIDIEditor_OnCommand : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_OnCommand)) . as_ptr ())) , MIDIEditor_SetSetting_int : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MIDIEditor_SetSetting_int)) . as_ptr ())) , mkpanstr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (mkpanstr)) . as_ptr ())) , mkvolpanstr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (mkvolpanstr)) . as_ptr ())) , mkvolstr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (mkvolstr)) . as_ptr ())) , MoveEditCursor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MoveEditCursor)) . as_ptr ())) , MoveMediaItemToTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MoveMediaItemToTrack)) . as_ptr ())) , MuteAllTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (MuteAllTracks)) . as_ptr ())) , my_getViewport : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (my_getViewport)) . as_ptr ())) , NamedCommandLookup : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (NamedCommandLookup)) . as_ptr ())) , OnPauseButton : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OnPauseButton)) . as_ptr ())) , OnPauseButtonEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OnPauseButtonEx)) . as_ptr ())) , OnPlayButton : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OnPlayButton)) . as_ptr ())) , OnPlayButtonEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OnPlayButtonEx)) . as_ptr ())) , OnStopButton : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OnStopButton)) . as_ptr ())) , OnStopButtonEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OnStopButtonEx)) . as_ptr ())) , OpenColorThemeFile : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OpenColorThemeFile)) . as_ptr ())) , OpenMediaExplorer : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OpenMediaExplorer)) . as_ptr ())) , OscLocalMessageToHost : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (OscLocalMessageToHost)) . as_ptr ())) , parse_timestr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (parse_timestr)) . as_ptr ())) , parse_timestr_len : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (parse_timestr_len)) . as_ptr ())) , parse_timestr_pos : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (parse_timestr_pos)) . as_ptr ())) , parsepanstr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (parsepanstr)) . as_ptr ())) , PCM_Sink_Create : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_Create)) . as_ptr ())) , PCM_Sink_CreateEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_CreateEx)) . as_ptr ())) , PCM_Sink_CreateMIDIFile : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_CreateMIDIFile)) . as_ptr ())) , PCM_Sink_CreateMIDIFileEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_CreateMIDIFileEx)) . as_ptr ())) , PCM_Sink_Enum : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_Enum)) . as_ptr ())) , PCM_Sink_GetExtension : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_GetExtension)) . as_ptr ())) , PCM_Sink_ShowConfig : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Sink_ShowConfig)) . as_ptr ())) , PCM_Source_BuildPeaks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_BuildPeaks)) . as_ptr ())) , PCM_Source_CreateFromFile : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_CreateFromFile)) . as_ptr ())) , PCM_Source_CreateFromFileEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_CreateFromFileEx)) . as_ptr ())) , PCM_Source_CreateFromSimple : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_CreateFromSimple)) . as_ptr ())) , PCM_Source_CreateFromType : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_CreateFromType)) . as_ptr ())) , PCM_Source_Destroy : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_Destroy)) . as_ptr ())) , PCM_Source_GetPeaks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_GetPeaks)) . as_ptr ())) , PCM_Source_GetSectionInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PCM_Source_GetSectionInfo)) . as_ptr ())) , PeakBuild_Create : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PeakBuild_Create)) . as_ptr ())) , PeakBuild_CreateEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PeakBuild_CreateEx)) . as_ptr ())) , PeakGet_Create : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PeakGet_Create)) . as_ptr ())) , PitchShiftSubModeMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PitchShiftSubModeMenu)) . as_ptr ())) , PlayPreview : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PlayPreview)) . as_ptr ())) , PlayPreviewEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PlayPreviewEx)) . as_ptr ())) , PlayTrackPreview : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PlayTrackPreview)) . as_ptr ())) , PlayTrackPreview2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PlayTrackPreview2)) . as_ptr ())) , PlayTrackPreview2Ex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PlayTrackPreview2Ex)) . as_ptr ())) , plugin_getapi : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (plugin_getapi)) . as_ptr ())) , plugin_getFilterList : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (plugin_getFilterList)) . as_ptr ())) , plugin_getImportableProjectFilterList : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (plugin_getImportableProjectFilterList)) . as_ptr ())) , plugin_register : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (plugin_register)) . as_ptr ())) , PluginWantsAlwaysRunFx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PluginWantsAlwaysRunFx)) . as_ptr ())) , PreventUIRefresh : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PreventUIRefresh)) . as_ptr ())) , projectconfig_var_addr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (projectconfig_var_addr)) . as_ptr ())) , projectconfig_var_getoffs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (projectconfig_var_getoffs)) . as_ptr ())) , PromptForAction : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (PromptForAction)) . as_ptr ())) , realloc_cmd_clear : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (realloc_cmd_clear)) . as_ptr ())) , realloc_cmd_ptr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (realloc_cmd_ptr)) . as_ptr ())) , realloc_cmd_register_buf : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (realloc_cmd_register_buf)) . as_ptr ())) , ReaperGetPitchShiftAPI : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ReaperGetPitchShiftAPI)) . as_ptr ())) , ReaScriptError : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ReaScriptError)) . as_ptr ())) , RecursiveCreateDirectory : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (RecursiveCreateDirectory)) . as_ptr ())) , reduce_open_files : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (reduce_open_files)) . as_ptr ())) , RefreshToolbar : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (RefreshToolbar)) . as_ptr ())) , RefreshToolbar2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (RefreshToolbar2)) . as_ptr ())) , relative_fn : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (relative_fn)) . as_ptr ())) , RemoveTrackSend : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (RemoveTrackSend)) . as_ptr ())) , RenderFileSection : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (RenderFileSection)) . as_ptr ())) , ReorderSelectedTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ReorderSelectedTracks)) . as_ptr ())) , Resample_EnumModes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Resample_EnumModes)) . as_ptr ())) , Resampler_Create : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Resampler_Create)) . as_ptr ())) , resolve_fn : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (resolve_fn)) . as_ptr ())) , resolve_fn2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (resolve_fn2)) . as_ptr ())) , ResolveRenderPattern : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ResolveRenderPattern)) . as_ptr ())) , ReverseNamedCommandLookup : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ReverseNamedCommandLookup)) . as_ptr ())) , ScaleFromEnvelopeMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ScaleFromEnvelopeMode)) . as_ptr ())) , ScaleToEnvelopeMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ScaleToEnvelopeMode)) . as_ptr ())) , screenset_register : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (screenset_register)) . as_ptr ())) , screenset_registerNew : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (screenset_registerNew)) . as_ptr ())) , screenset_unregister : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (screenset_unregister)) . as_ptr ())) , screenset_unregisterByParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (screenset_unregisterByParam)) . as_ptr ())) , screenset_updateLastFocus : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (screenset_updateLastFocus)) . as_ptr ())) , SectionFromUniqueID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SectionFromUniqueID)) . as_ptr ())) , SelectAllMediaItems : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SelectAllMediaItems)) . as_ptr ())) , SelectProjectInstance : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SelectProjectInstance)) . as_ptr ())) , SendLocalOscMessage : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SendLocalOscMessage)) . as_ptr ())) , SetActiveTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetActiveTake)) . as_ptr ())) , SetAutomationMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetAutomationMode)) . as_ptr ())) , SetCurrentBPM : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetCurrentBPM)) . as_ptr ())) , SetCursorContext : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetCursorContext)) . as_ptr ())) , SetEditCurPos : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetEditCurPos)) . as_ptr ())) , SetEditCurPos2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetEditCurPos2)) . as_ptr ())) , SetEnvelopePoint : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetEnvelopePoint)) . as_ptr ())) , SetEnvelopePointEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetEnvelopePointEx)) . as_ptr ())) , SetEnvelopeStateChunk : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetEnvelopeStateChunk)) . as_ptr ())) , SetExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetExtState)) . as_ptr ())) , SetGlobalAutomationOverride : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetGlobalAutomationOverride)) . as_ptr ())) , SetItemStateChunk : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetItemStateChunk)) . as_ptr ())) , SetMasterTrackVisibility : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMasterTrackVisibility)) . as_ptr ())) , SetMediaItemInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaItemInfo_Value)) . as_ptr ())) , SetMediaItemLength : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaItemLength)) . as_ptr ())) , SetMediaItemPosition : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaItemPosition)) . as_ptr ())) , SetMediaItemSelected : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaItemSelected)) . as_ptr ())) , SetMediaItemTake_Source : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaItemTake_Source)) . as_ptr ())) , SetMediaItemTakeInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaItemTakeInfo_Value)) . as_ptr ())) , SetMediaTrackInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMediaTrackInfo_Value)) . as_ptr ())) , SetMIDIEditorGrid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMIDIEditorGrid)) . as_ptr ())) , SetMixerScroll : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMixerScroll)) . as_ptr ())) , SetMouseModifier : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetMouseModifier)) . as_ptr ())) , SetOnlyTrackSelected : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetOnlyTrackSelected)) . as_ptr ())) , SetProjectGrid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectGrid)) . as_ptr ())) , SetProjectMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectMarker)) . as_ptr ())) , SetProjectMarker2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectMarker2)) . as_ptr ())) , SetProjectMarker3 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectMarker3)) . as_ptr ())) , SetProjectMarker4 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectMarker4)) . as_ptr ())) , SetProjectMarkerByIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectMarkerByIndex)) . as_ptr ())) , SetProjectMarkerByIndex2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjectMarkerByIndex2)) . as_ptr ())) , SetProjExtState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetProjExtState)) . as_ptr ())) , SetRegionRenderMatrix : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetRegionRenderMatrix)) . as_ptr ())) , SetRenderLastError : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetRenderLastError)) . as_ptr ())) , SetTakeMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTakeMarker)) . as_ptr ())) , SetTakeStretchMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTakeStretchMarker)) . as_ptr ())) , SetTakeStretchMarkerSlope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTakeStretchMarkerSlope)) . as_ptr ())) , SetTempoTimeSigMarker : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTempoTimeSigMarker)) . as_ptr ())) , SetThemeColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetThemeColor)) . as_ptr ())) , SetToggleCommandState : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetToggleCommandState)) . as_ptr ())) , SetTrackAutomationMode : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackAutomationMode)) . as_ptr ())) , SetTrackColor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackColor)) . as_ptr ())) , SetTrackMIDILyrics : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackMIDILyrics)) . as_ptr ())) , SetTrackMIDINoteName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackMIDINoteName)) . as_ptr ())) , SetTrackMIDINoteNameEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackMIDINoteNameEx)) . as_ptr ())) , SetTrackSelected : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackSelected)) . as_ptr ())) , SetTrackSendInfo_Value : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackSendInfo_Value)) . as_ptr ())) , SetTrackSendUIPan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackSendUIPan)) . as_ptr ())) , SetTrackSendUIVol : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackSendUIVol)) . as_ptr ())) , SetTrackStateChunk : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackStateChunk)) . as_ptr ())) , SetTrackUIInputMonitor : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIInputMonitor)) . as_ptr ())) , SetTrackUIMute : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIMute)) . as_ptr ())) , SetTrackUIPan : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIPan)) . as_ptr ())) , SetTrackUIPolarity : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIPolarity)) . as_ptr ())) , SetTrackUIRecArm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIRecArm)) . as_ptr ())) , SetTrackUISolo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUISolo)) . as_ptr ())) , SetTrackUIVolume : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIVolume)) . as_ptr ())) , SetTrackUIWidth : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SetTrackUIWidth)) . as_ptr ())) , ShowActionList : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ShowActionList)) . as_ptr ())) , ShowConsoleMsg : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ShowConsoleMsg)) . as_ptr ())) , ShowMessageBox : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ShowMessageBox)) . as_ptr ())) , ShowPopupMenu : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ShowPopupMenu)) . as_ptr ())) , SLIDER2DB : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SLIDER2DB)) . as_ptr ())) , SnapToGrid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SnapToGrid)) . as_ptr ())) , SoloAllTracks : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SoloAllTracks)) . as_ptr ())) , Splash_GetWnd : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Splash_GetWnd)) . as_ptr ())) , SplitMediaItem : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (SplitMediaItem)) . as_ptr ())) , StopPreview : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (StopPreview)) . as_ptr ())) , StopTrackPreview : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (StopTrackPreview)) . as_ptr ())) , StopTrackPreview2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (StopTrackPreview2)) . as_ptr ())) , stringToGuid : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (stringToGuid)) . as_ptr ())) , StuffMIDIMessage : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (StuffMIDIMessage)) . as_ptr ())) , TakeFX_AddByName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_AddByName)) . as_ptr ())) , TakeFX_CopyToTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_CopyToTake)) . as_ptr ())) , TakeFX_CopyToTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_CopyToTrack)) . as_ptr ())) , TakeFX_Delete : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_Delete)) . as_ptr ())) , TakeFX_EndParamEdit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_EndParamEdit)) . as_ptr ())) , TakeFX_FormatParamValue : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_FormatParamValue)) . as_ptr ())) , TakeFX_FormatParamValueNormalized : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_FormatParamValueNormalized)) . as_ptr ())) , TakeFX_GetChainVisible : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetChainVisible)) . as_ptr ())) , TakeFX_GetCount : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetCount)) . as_ptr ())) , TakeFX_GetEnabled : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetEnabled)) . as_ptr ())) , TakeFX_GetEnvelope : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetEnvelope)) . as_ptr ())) , TakeFX_GetFloatingWindow : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetFloatingWindow)) . as_ptr ())) , TakeFX_GetFormattedParamValue : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetFormattedParamValue)) . as_ptr ())) , TakeFX_GetFXGUID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetFXGUID)) . as_ptr ())) , TakeFX_GetFXName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetFXName)) . as_ptr ())) , TakeFX_GetIOSize : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetIOSize)) . as_ptr ())) , TakeFX_GetNamedConfigParm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetNamedConfigParm)) . as_ptr ())) , TakeFX_GetNumParams : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetNumParams)) . as_ptr ())) , TakeFX_GetOffline : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetOffline)) . as_ptr ())) , TakeFX_GetOpen : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetOpen)) . as_ptr ())) , TakeFX_GetParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParam)) . as_ptr ())) , TakeFX_GetParameterStepSizes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParameterStepSizes)) . as_ptr ())) , TakeFX_GetParamEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParamEx)) . as_ptr ())) , TakeFX_GetParamFromIdent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParamFromIdent)) . as_ptr ())) , TakeFX_GetParamIdent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParamIdent)) . as_ptr ())) , TakeFX_GetParamName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParamName)) . as_ptr ())) , TakeFX_GetParamNormalized : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetParamNormalized)) . as_ptr ())) , TakeFX_GetPinMappings : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetPinMappings)) . as_ptr ())) , TakeFX_GetPreset : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetPreset)) . as_ptr ())) , TakeFX_GetPresetIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetPresetIndex)) . as_ptr ())) , TakeFX_GetUserPresetFilename : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_GetUserPresetFilename)) . as_ptr ())) , TakeFX_NavigatePresets : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_NavigatePresets)) . as_ptr ())) , TakeFX_SetEnabled : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetEnabled)) . as_ptr ())) , TakeFX_SetNamedConfigParm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetNamedConfigParm)) . as_ptr ())) , TakeFX_SetOffline : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetOffline)) . as_ptr ())) , TakeFX_SetOpen : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetOpen)) . as_ptr ())) , TakeFX_SetParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetParam)) . as_ptr ())) , TakeFX_SetParamNormalized : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetParamNormalized)) . as_ptr ())) , TakeFX_SetPinMappings : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetPinMappings)) . as_ptr ())) , TakeFX_SetPreset : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetPreset)) . as_ptr ())) , TakeFX_SetPresetByIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_SetPresetByIndex)) . as_ptr ())) , TakeFX_Show : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeFX_Show)) . as_ptr ())) , TakeIsMIDI : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TakeIsMIDI)) . as_ptr ())) , ThemeLayout_GetLayout : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ThemeLayout_GetLayout)) . as_ptr ())) , ThemeLayout_GetParameter : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ThemeLayout_GetParameter)) . as_ptr ())) , ThemeLayout_RefreshAll : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ThemeLayout_RefreshAll)) . as_ptr ())) , ThemeLayout_SetLayout : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ThemeLayout_SetLayout)) . as_ptr ())) , ThemeLayout_SetParameter : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ThemeLayout_SetParameter)) . as_ptr ())) , time_precise : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (time_precise)) . as_ptr ())) , TimeMap2_beatsToTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap2_beatsToTime)) . as_ptr ())) , TimeMap2_GetDividedBpmAtTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap2_GetDividedBpmAtTime)) . as_ptr ())) , TimeMap2_GetNextChangeTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap2_GetNextChangeTime)) . as_ptr ())) , TimeMap2_QNToTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap2_QNToTime)) . as_ptr ())) , TimeMap2_timeToBeats : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap2_timeToBeats)) . as_ptr ())) , TimeMap2_timeToQN : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap2_timeToQN)) . as_ptr ())) , TimeMap_curFrameRate : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_curFrameRate)) . as_ptr ())) , TimeMap_GetDividedBpmAtTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_GetDividedBpmAtTime)) . as_ptr ())) , TimeMap_GetMeasureInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_GetMeasureInfo)) . as_ptr ())) , TimeMap_GetMetronomePattern : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_GetMetronomePattern)) . as_ptr ())) , TimeMap_GetTimeSigAtTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_GetTimeSigAtTime)) . as_ptr ())) , TimeMap_QNToMeasures : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_QNToMeasures)) . as_ptr ())) , TimeMap_QNToTime : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_QNToTime)) . as_ptr ())) , TimeMap_QNToTime_abs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_QNToTime_abs)) . as_ptr ())) , TimeMap_timeToQN : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_timeToQN)) . as_ptr ())) , TimeMap_timeToQN_abs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TimeMap_timeToQN_abs)) . as_ptr ())) , ToggleTrackSendUIMute : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ToggleTrackSendUIMute)) . as_ptr ())) , Track_GetPeakHoldDB : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Track_GetPeakHoldDB)) . as_ptr ())) , Track_GetPeakInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Track_GetPeakInfo)) . as_ptr ())) , TrackCtl_SetToolTip : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackCtl_SetToolTip)) . as_ptr ())) , TrackFX_AddByName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_AddByName)) . as_ptr ())) , TrackFX_CopyToTake : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_CopyToTake)) . as_ptr ())) , TrackFX_CopyToTrack : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_CopyToTrack)) . as_ptr ())) , TrackFX_Delete : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_Delete)) . as_ptr ())) , TrackFX_EndParamEdit : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_EndParamEdit)) . as_ptr ())) , TrackFX_FormatParamValue : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_FormatParamValue)) . as_ptr ())) , TrackFX_FormatParamValueNormalized : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_FormatParamValueNormalized)) . as_ptr ())) , TrackFX_GetByName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetByName)) . as_ptr ())) , TrackFX_GetChainVisible : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetChainVisible)) . as_ptr ())) , TrackFX_GetCount : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetCount)) . as_ptr ())) , TrackFX_GetEnabled : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetEnabled)) . as_ptr ())) , TrackFX_GetEQ : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetEQ)) . as_ptr ())) , TrackFX_GetEQBandEnabled : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetEQBandEnabled)) . as_ptr ())) , TrackFX_GetEQParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetEQParam)) . as_ptr ())) , TrackFX_GetFloatingWindow : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetFloatingWindow)) . as_ptr ())) , TrackFX_GetFormattedParamValue : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetFormattedParamValue)) . as_ptr ())) , TrackFX_GetFXGUID : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetFXGUID)) . as_ptr ())) , TrackFX_GetFXName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetFXName)) . as_ptr ())) , TrackFX_GetInstrument : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetInstrument)) . as_ptr ())) , TrackFX_GetIOSize : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetIOSize)) . as_ptr ())) , TrackFX_GetNamedConfigParm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetNamedConfigParm)) . as_ptr ())) , TrackFX_GetNumParams : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetNumParams)) . as_ptr ())) , TrackFX_GetOffline : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetOffline)) . as_ptr ())) , TrackFX_GetOpen : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetOpen)) . as_ptr ())) , TrackFX_GetParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParam)) . as_ptr ())) , TrackFX_GetParameterStepSizes : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParameterStepSizes)) . as_ptr ())) , TrackFX_GetParamEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParamEx)) . as_ptr ())) , TrackFX_GetParamFromIdent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParamFromIdent)) . as_ptr ())) , TrackFX_GetParamIdent : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParamIdent)) . as_ptr ())) , TrackFX_GetParamName : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParamName)) . as_ptr ())) , TrackFX_GetParamNormalized : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetParamNormalized)) . as_ptr ())) , TrackFX_GetPinMappings : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetPinMappings)) . as_ptr ())) , TrackFX_GetPreset : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetPreset)) . as_ptr ())) , TrackFX_GetPresetIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetPresetIndex)) . as_ptr ())) , TrackFX_GetRecChainVisible : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetRecChainVisible)) . as_ptr ())) , TrackFX_GetRecCount : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetRecCount)) . as_ptr ())) , TrackFX_GetUserPresetFilename : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_GetUserPresetFilename)) . as_ptr ())) , TrackFX_NavigatePresets : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_NavigatePresets)) . as_ptr ())) , TrackFX_SetEnabled : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetEnabled)) . as_ptr ())) , TrackFX_SetEQBandEnabled : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetEQBandEnabled)) . as_ptr ())) , TrackFX_SetEQParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetEQParam)) . as_ptr ())) , TrackFX_SetNamedConfigParm : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetNamedConfigParm)) . as_ptr ())) , TrackFX_SetOffline : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetOffline)) . as_ptr ())) , TrackFX_SetOpen : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetOpen)) . as_ptr ())) , TrackFX_SetParam : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetParam)) . as_ptr ())) , TrackFX_SetParamNormalized : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetParamNormalized)) . as_ptr ())) , TrackFX_SetPinMappings : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetPinMappings)) . as_ptr ())) , TrackFX_SetPreset : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetPreset)) . as_ptr ())) , TrackFX_SetPresetByIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_SetPresetByIndex)) . as_ptr ())) , TrackFX_Show : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackFX_Show)) . as_ptr ())) , TrackList_AdjustWindows : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackList_AdjustWindows)) . as_ptr ())) , TrackList_UpdateAllExternalSurfaces : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (TrackList_UpdateAllExternalSurfaces)) . as_ptr ())) , Undo_BeginBlock : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_BeginBlock)) . as_ptr ())) , Undo_BeginBlock2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_BeginBlock2)) . as_ptr ())) , Undo_CanRedo2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_CanRedo2)) . as_ptr ())) , Undo_CanUndo2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_CanUndo2)) . as_ptr ())) , Undo_DoRedo2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_DoRedo2)) . as_ptr ())) , Undo_DoUndo2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_DoUndo2)) . as_ptr ())) , Undo_EndBlock : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_EndBlock)) . as_ptr ())) , Undo_EndBlock2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_EndBlock2)) . as_ptr ())) , Undo_OnStateChange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_OnStateChange)) . as_ptr ())) , Undo_OnStateChange2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_OnStateChange2)) . as_ptr ())) , Undo_OnStateChange_Item : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_OnStateChange_Item)) . as_ptr ())) , Undo_OnStateChangeEx : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_OnStateChangeEx)) . as_ptr ())) , Undo_OnStateChangeEx2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (Undo_OnStateChangeEx2)) . as_ptr ())) , update_disk_counters : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (update_disk_counters)) . as_ptr ())) , UpdateArrange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (UpdateArrange)) . as_ptr ())) , UpdateItemInProject : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (UpdateItemInProject)) . as_ptr ())) , UpdateTimeline : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (UpdateTimeline)) . as_ptr ())) , ValidatePtr : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ValidatePtr)) . as_ptr ())) , ValidatePtr2 : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ValidatePtr2)) . as_ptr ())) , ViewPrefs : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (ViewPrefs)) . as_ptr ())) , WDL_VirtualWnd_ScaledBlitBG : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (WDL_VirtualWnd_ScaledBlitBG)) . as_ptr ())) , GetMidiInput : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMidiInput)) . as_ptr ())) , GetMidiOutput : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (GetMidiOutput)) . as_ptr ())) , InitializeCoolSB : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (InitializeCoolSB)) . as_ptr ())) , UninitializeCoolSB : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (UninitializeCoolSB)) . as_ptr ())) , CoolSB_SetMinThumbSize : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_SetMinThumbSize)) . as_ptr ())) , CoolSB_GetScrollInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_GetScrollInfo)) . as_ptr ())) , CoolSB_SetScrollInfo : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_SetScrollInfo)) . as_ptr ())) , CoolSB_SetScrollPos : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_SetScrollPos)) . as_ptr ())) , CoolSB_SetScrollRange : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_SetScrollRange)) . as_ptr ())) , CoolSB_ShowScrollBar : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_ShowScrollBar)) . as_ptr ())) , CoolSB_SetResizingThumb : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_SetResizingThumb)) . as_ptr ())) , CoolSB_SetThemeIndex : std :: mem :: transmute (plugin_context . GetFunc (c_str_macro :: c_str ! (stringify ! (CoolSB_SetThemeIndex)) . as_ptr ())) , } } ; if pointers . __mergesort . is_some () { loaded_count += 1 ; } if pointers . AddCustomizableMenu . is_some () { loaded_count += 1 ; } if pointers . AddExtensionsMainMenu . is_some () { loaded_count += 1 ; } if pointers . AddMediaItemToTrack . is_some () { loaded_count += 1 ; } if pointers . AddProjectMarker . is_some () { loaded_count += 1 ; } if pointers . AddProjectMarker2 . is_some () { loaded_count += 1 ; } if pointers . AddRemoveReaScript . is_some () { loaded_count += 1 ; } if pointers . AddTakeToMediaItem . is_some () { loaded_count += 1 ; } if pointers . AddTempoTimeSigMarker . is_some () { loaded_count += 1 ; } if pointers . adjustZoom . is_some () { loaded_count += 1 ; } if pointers . AnyTrackSolo . is_some () { loaded_count += 1 ; } if pointers . APIExists . is_some () { loaded_count += 1 ; } if pointers . APITest . is_some () { loaded_count += 1 ; } if pointers . ApplyNudge . is_some () { loaded_count += 1 ; } if pointers . ArmCommand . is_some () { loaded_count += 1 ; } if pointers . Audio_Init . is_some () { loaded_count += 1 ; } if pointers . Audio_IsPreBuffer . is_some () { loaded_count += 1 ; } if pointers . Audio_IsRunning . is_some () { loaded_count += 1 ; } if pointers . Audio_Quit . is_some () { loaded_count += 1 ; } if pointers . Audio_RegHardwareHook . is_some () { loaded_count += 1 ; } if pointers . AudioAccessorStateChanged . is_some () { loaded_count += 1 ; } if pointers . AudioAccessorUpdate . is_some () { loaded_count += 1 ; } if pointers . AudioAccessorValidateState . is_some () { loaded_count += 1 ; } if pointers . BypassFxAllTracks . is_some () { loaded_count += 1 ; } if pointers . CalcMediaSrcLoudness . is_some () { loaded_count += 1 ; } if pointers . CalculateNormalization . is_some () { loaded_count += 1 ; } if pointers . CalculatePeaks . is_some () { loaded_count += 1 ; } if pointers . CalculatePeaksFloatSrcPtr . is_some () { loaded_count += 1 ; } if pointers . ClearAllRecArmed . is_some () { loaded_count += 1 ; } if pointers . ClearConsole . is_some () { loaded_count += 1 ; } if pointers . ClearPeakCache . is_some () { loaded_count += 1 ; } if pointers . ColorFromNative . is_some () { loaded_count += 1 ; } if pointers . ColorToNative . is_some () { loaded_count += 1 ; } if pointers . CountActionShortcuts . is_some () { loaded_count += 1 ; } if pointers . CountAutomationItems . is_some () { loaded_count += 1 ; } if pointers . CountEnvelopePoints . is_some () { loaded_count += 1 ; } if pointers . CountEnvelopePointsEx . is_some () { loaded_count += 1 ; } if pointers . CountMediaItems . is_some () { loaded_count += 1 ; } if pointers . CountProjectMarkers . is_some () { loaded_count += 1 ; } if pointers . CountSelectedMediaItems . is_some () { loaded_count += 1 ; } if pointers . CountSelectedTracks . is_some () { loaded_count += 1 ; } if pointers . CountSelectedTracks2 . is_some () { loaded_count += 1 ; } if pointers . CountTakeEnvelopes . is_some () { loaded_count += 1 ; } if pointers . CountTakes . is_some () { loaded_count += 1 ; } if pointers . CountTCPFXParms . is_some () { loaded_count += 1 ; } if pointers . CountTempoTimeSigMarkers . is_some () { loaded_count += 1 ; } if pointers . CountTrackEnvelopes . is_some () { loaded_count += 1 ; } if pointers . CountTrackMediaItems . is_some () { loaded_count += 1 ; } if pointers . CountTracks . is_some () { loaded_count += 1 ; } if pointers . CreateLocalOscHandler . is_some () { loaded_count += 1 ; } if pointers . CreateMIDIInput . is_some () { loaded_count += 1 ; } if pointers . CreateMIDIOutput . is_some () { loaded_count += 1 ; } if pointers . CreateNewMIDIItemInProj . is_some () { loaded_count += 1 ; } if pointers . CreateTakeAudioAccessor . is_some () { loaded_count += 1 ; } if pointers . CreateTrackAudioAccessor . is_some () { loaded_count += 1 ; } if pointers . CreateTrackSend . is_some () { loaded_count += 1 ; } if pointers . CSurf_FlushUndo . is_some () { loaded_count += 1 ; } if pointers . CSurf_GetTouchState . is_some () { loaded_count += 1 ; } if pointers . CSurf_GoEnd . is_some () { loaded_count += 1 ; } if pointers . CSurf_GoStart . is_some () { loaded_count += 1 ; } if pointers . CSurf_NumTracks . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnArrow . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnFwd . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnFXChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnInputMonitorChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnInputMonitorChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnMuteChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnMuteChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnOscControlMessage . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnOscControlMessage2 . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnPanChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnPanChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnPause . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnPlay . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnPlayRateChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRecArmChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRecArmChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRecord . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRecvPanChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRecvVolumeChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRew . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnRewFwd . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnScroll . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnSelectedChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnSendPanChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnSendVolumeChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnSoloChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnSoloChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnStop . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnTempoChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnTrackSelection . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnVolumeChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnVolumeChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnWidthChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnWidthChangeEx . is_some () { loaded_count += 1 ; } if pointers . CSurf_OnZoom . is_some () { loaded_count += 1 ; } if pointers . CSurf_ResetAllCachedVolPanStates . is_some () { loaded_count += 1 ; } if pointers . CSurf_ScrubAmt . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetAutoMode . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetPlayState . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetRepeatState . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetSurfaceMute . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetSurfacePan . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetSurfaceRecArm . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetSurfaceSelected . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetSurfaceSolo . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetSurfaceVolume . is_some () { loaded_count += 1 ; } if pointers . CSurf_SetTrackListChange . is_some () { loaded_count += 1 ; } if pointers . CSurf_TrackFromID . is_some () { loaded_count += 1 ; } if pointers . CSurf_TrackToID . is_some () { loaded_count += 1 ; } if pointers . DB2SLIDER . is_some () { loaded_count += 1 ; } if pointers . DeleteActionShortcut . is_some () { loaded_count += 1 ; } if pointers . DeleteEnvelopePointEx . is_some () { loaded_count += 1 ; } if pointers . DeleteEnvelopePointRange . is_some () { loaded_count += 1 ; } if pointers . DeleteEnvelopePointRangeEx . is_some () { loaded_count += 1 ; } if pointers . DeleteExtState . is_some () { loaded_count += 1 ; } if pointers . DeleteProjectMarker . is_some () { loaded_count += 1 ; } if pointers . DeleteProjectMarkerByIndex . is_some () { loaded_count += 1 ; } if pointers . DeleteTakeMarker . is_some () { loaded_count += 1 ; } if pointers . DeleteTakeStretchMarkers . is_some () { loaded_count += 1 ; } if pointers . DeleteTempoTimeSigMarker . is_some () { loaded_count += 1 ; } if pointers . DeleteTrack . is_some () { loaded_count += 1 ; } if pointers . DeleteTrackMediaItem . is_some () { loaded_count += 1 ; } if pointers . DestroyAudioAccessor . is_some () { loaded_count += 1 ; } if pointers . DestroyLocalOscHandler . is_some () { loaded_count += 1 ; } if pointers . DoActionShortcutDialog . is_some () { loaded_count += 1 ; } if pointers . Dock_UpdateDockID . is_some () { loaded_count += 1 ; } if pointers . DockGetPosition . is_some () { loaded_count += 1 ; } if pointers . DockIsChildOfDock . is_some () { loaded_count += 1 ; } if pointers . DockWindowActivate . is_some () { loaded_count += 1 ; } if pointers . DockWindowAdd . is_some () { loaded_count += 1 ; } if pointers . DockWindowAddEx . is_some () { loaded_count += 1 ; } if pointers . DockWindowRefresh . is_some () { loaded_count += 1 ; } if pointers . DockWindowRefreshForHWND . is_some () { loaded_count += 1 ; } if pointers . DockWindowRemove . is_some () { loaded_count += 1 ; } if pointers . DuplicateCustomizableMenu . is_some () { loaded_count += 1 ; } if pointers . EditTempoTimeSigMarker . is_some () { loaded_count += 1 ; } if pointers . EnsureNotCompletelyOffscreen . is_some () { loaded_count += 1 ; } if pointers . EnumerateFiles . is_some () { loaded_count += 1 ; } if pointers . EnumerateSubdirectories . is_some () { loaded_count += 1 ; } if pointers . EnumPitchShiftModes . is_some () { loaded_count += 1 ; } if pointers . EnumPitchShiftSubModes . is_some () { loaded_count += 1 ; } if pointers . EnumProjectMarkers . is_some () { loaded_count += 1 ; } if pointers . EnumProjectMarkers2 . is_some () { loaded_count += 1 ; } if pointers . EnumProjectMarkers3 . is_some () { loaded_count += 1 ; } if pointers . EnumProjects . is_some () { loaded_count += 1 ; } if pointers . EnumProjExtState . is_some () { loaded_count += 1 ; } if pointers . EnumRegionRenderMatrix . is_some () { loaded_count += 1 ; } if pointers . EnumTrackMIDIProgramNames . is_some () { loaded_count += 1 ; } if pointers . EnumTrackMIDIProgramNamesEx . is_some () { loaded_count += 1 ; } if pointers . Envelope_Evaluate . is_some () { loaded_count += 1 ; } if pointers . Envelope_FormatValue . is_some () { loaded_count += 1 ; } if pointers . Envelope_GetParentTake . is_some () { loaded_count += 1 ; } if pointers . Envelope_GetParentTrack . is_some () { loaded_count += 1 ; } if pointers . Envelope_SortPoints . is_some () { loaded_count += 1 ; } if pointers . Envelope_SortPointsEx . is_some () { loaded_count += 1 ; } if pointers . ExecProcess . is_some () { loaded_count += 1 ; } if pointers . file_exists . is_some () { loaded_count += 1 ; } if pointers . FindTempoTimeSigMarker . is_some () { loaded_count += 1 ; } if pointers . format_timestr . is_some () { loaded_count += 1 ; } if pointers . format_timestr_len . is_some () { loaded_count += 1 ; } if pointers . format_timestr_pos . is_some () { loaded_count += 1 ; } if pointers . FreeHeapPtr . is_some () { loaded_count += 1 ; } if pointers . genGuid . is_some () { loaded_count += 1 ; } if pointers . get_config_var . is_some () { loaded_count += 1 ; } if pointers . get_config_var_string . is_some () { loaded_count += 1 ; } if pointers . get_ini_file . is_some () { loaded_count += 1 ; } if pointers . get_midi_config_var . is_some () { loaded_count += 1 ; } if pointers . GetActionShortcutDesc . is_some () { loaded_count += 1 ; } if pointers . GetActiveTake . is_some () { loaded_count += 1 ; } if pointers . GetAllProjectPlayStates . is_some () { loaded_count += 1 ; } if pointers . GetAppVersion . is_some () { loaded_count += 1 ; } if pointers . GetArmedCommand . is_some () { loaded_count += 1 ; } if pointers . GetAudioAccessorEndTime . is_some () { loaded_count += 1 ; } if pointers . GetAudioAccessorHash . is_some () { loaded_count += 1 ; } if pointers . GetAudioAccessorSamples . is_some () { loaded_count += 1 ; } if pointers . GetAudioAccessorStartTime . is_some () { loaded_count += 1 ; } if pointers . GetAudioDeviceInfo . is_some () { loaded_count += 1 ; } if pointers . GetColorTheme . is_some () { loaded_count += 1 ; } if pointers . GetColorThemeStruct . is_some () { loaded_count += 1 ; } if pointers . GetConfigWantsDock . is_some () { loaded_count += 1 ; } if pointers . GetContextMenu . is_some () { loaded_count += 1 ; } if pointers . GetCurrentProjectInLoadSave . is_some () { loaded_count += 1 ; } if pointers . GetCursorContext . is_some () { loaded_count += 1 ; } if pointers . GetCursorContext2 . is_some () { loaded_count += 1 ; } if pointers . GetCursorPosition . is_some () { loaded_count += 1 ; } if pointers . GetCursorPositionEx . is_some () { loaded_count += 1 ; } if pointers . GetDisplayedMediaItemColor . is_some () { loaded_count += 1 ; } if pointers . GetDisplayedMediaItemColor2 . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopeInfo_Value . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopeName . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopePoint . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopePointByTime . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopePointByTimeEx . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopePointEx . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopeScalingMode . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopeStateChunk . is_some () { loaded_count += 1 ; } if pointers . GetEnvelopeUIState . is_some () { loaded_count += 1 ; } if pointers . GetExePath . is_some () { loaded_count += 1 ; } if pointers . GetExtState . is_some () { loaded_count += 1 ; } if pointers . GetFocusedFX . is_some () { loaded_count += 1 ; } if pointers . GetFocusedFX2 . is_some () { loaded_count += 1 ; } if pointers . GetFreeDiskSpaceForRecordPath . is_some () { loaded_count += 1 ; } if pointers . GetFXEnvelope . is_some () { loaded_count += 1 ; } if pointers . GetGlobalAutomationOverride . is_some () { loaded_count += 1 ; } if pointers . GetHZoomLevel . is_some () { loaded_count += 1 ; } if pointers . GetIconThemePointer . is_some () { loaded_count += 1 ; } if pointers . GetIconThemePointerForDPI . is_some () { loaded_count += 1 ; } if pointers . GetIconThemeStruct . is_some () { loaded_count += 1 ; } if pointers . GetInputChannelName . is_some () { loaded_count += 1 ; } if pointers . GetInputOutputLatency . is_some () { loaded_count += 1 ; } if pointers . GetItemEditingTime2 . is_some () { loaded_count += 1 ; } if pointers . GetItemFromPoint . is_some () { loaded_count += 1 ; } if pointers . GetItemProjectContext . is_some () { loaded_count += 1 ; } if pointers . GetItemStateChunk . is_some () { loaded_count += 1 ; } if pointers . GetLastColorThemeFile . is_some () { loaded_count += 1 ; } if pointers . GetLastMarkerAndCurRegion . is_some () { loaded_count += 1 ; } if pointers . GetLastTouchedFX . is_some () { loaded_count += 1 ; } if pointers . GetLastTouchedTrack . is_some () { loaded_count += 1 ; } if pointers . GetMainHwnd . is_some () { loaded_count += 1 ; } if pointers . GetMasterMuteSoloFlags . is_some () { loaded_count += 1 ; } if pointers . GetMasterTrack . is_some () { loaded_count += 1 ; } if pointers . GetMasterTrackVisibility . is_some () { loaded_count += 1 ; } if pointers . GetMaxMidiInputs . is_some () { loaded_count += 1 ; } if pointers . GetMaxMidiOutputs . is_some () { loaded_count += 1 ; } if pointers . GetMediaFileMetadata . is_some () { loaded_count += 1 ; } if pointers . GetMediaItem . is_some () { loaded_count += 1 ; } if pointers . GetMediaItem_Track . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemInfo_Value . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemNumTakes . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTake . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTake_Item . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTake_Peaks . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTake_Source . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTake_Track . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTakeByGUID . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTakeInfo_Value . is_some () { loaded_count += 1 ; } if pointers . GetMediaItemTrack . is_some () { loaded_count += 1 ; } if pointers . GetMediaSourceFileName . is_some () { loaded_count += 1 ; } if pointers . GetMediaSourceLength . is_some () { loaded_count += 1 ; } if pointers . GetMediaSourceNumChannels . is_some () { loaded_count += 1 ; } if pointers . GetMediaSourceParent . is_some () { loaded_count += 1 ; } if pointers . GetMediaSourceSampleRate . is_some () { loaded_count += 1 ; } if pointers . GetMediaSourceType . is_some () { loaded_count += 1 ; } if pointers . GetMediaTrackInfo_Value . is_some () { loaded_count += 1 ; } if pointers . GetMIDIInputName . is_some () { loaded_count += 1 ; } if pointers . GetMIDIOutputName . is_some () { loaded_count += 1 ; } if pointers . GetMixerScroll . is_some () { loaded_count += 1 ; } if pointers . GetMouseModifier . is_some () { loaded_count += 1 ; } if pointers . GetMousePosition . is_some () { loaded_count += 1 ; } if pointers . GetNumAudioInputs . is_some () { loaded_count += 1 ; } if pointers . GetNumAudioOutputs . is_some () { loaded_count += 1 ; } if pointers . GetNumMIDIInputs . is_some () { loaded_count += 1 ; } if pointers . GetNumMIDIOutputs . is_some () { loaded_count += 1 ; } if pointers . GetNumTakeMarkers . is_some () { loaded_count += 1 ; } if pointers . GetNumTracks . is_some () { loaded_count += 1 ; } if pointers . GetOS . is_some () { loaded_count += 1 ; } if pointers . GetOutputChannelName . is_some () { loaded_count += 1 ; } if pointers . GetOutputLatency . is_some () { loaded_count += 1 ; } if pointers . GetParentTrack . is_some () { loaded_count += 1 ; } if pointers . GetPeakFileName . is_some () { loaded_count += 1 ; } if pointers . GetPeakFileNameEx . is_some () { loaded_count += 1 ; } if pointers . GetPeakFileNameEx2 . is_some () { loaded_count += 1 ; } if pointers . GetPeaksBitmap . is_some () { loaded_count += 1 ; } if pointers . GetPlayPosition . is_some () { loaded_count += 1 ; } if pointers . GetPlayPosition2 . is_some () { loaded_count += 1 ; } if pointers . GetPlayPosition2Ex . is_some () { loaded_count += 1 ; } if pointers . GetPlayPositionEx . is_some () { loaded_count += 1 ; } if pointers . GetPlayState . is_some () { loaded_count += 1 ; } if pointers . GetPlayStateEx . is_some () { loaded_count += 1 ; } if pointers . GetPreferredDiskReadMode . is_some () { loaded_count += 1 ; } if pointers . GetPreferredDiskReadModePeak . is_some () { loaded_count += 1 ; } if pointers . GetPreferredDiskWriteMode . is_some () { loaded_count += 1 ; } if pointers . GetProjectLength . is_some () { loaded_count += 1 ; } if pointers . GetProjectName . is_some () { loaded_count += 1 ; } if pointers . GetProjectPath . is_some () { loaded_count += 1 ; } if pointers . GetProjectPathEx . is_some () { loaded_count += 1 ; } if pointers . GetProjectStateChangeCount . is_some () { loaded_count += 1 ; } if pointers . GetProjectTimeOffset . is_some () { loaded_count += 1 ; } if pointers . GetProjectTimeSignature . is_some () { loaded_count += 1 ; } if pointers . GetProjectTimeSignature2 . is_some () { loaded_count += 1 ; } if pointers . GetProjExtState . is_some () { loaded_count += 1 ; } if pointers . GetResourcePath . is_some () { loaded_count += 1 ; } if pointers . GetSelectedEnvelope . is_some () { loaded_count += 1 ; } if pointers . GetSelectedMediaItem . is_some () { loaded_count += 1 ; } if pointers . GetSelectedTrack . is_some () { loaded_count += 1 ; } if pointers . GetSelectedTrack2 . is_some () { loaded_count += 1 ; } if pointers . GetSelectedTrackEnvelope . is_some () { loaded_count += 1 ; } if pointers . GetSet_ArrangeView2 . is_some () { loaded_count += 1 ; } if pointers . GetSet_LoopTimeRange . is_some () { loaded_count += 1 ; } if pointers . GetSet_LoopTimeRange2 . is_some () { loaded_count += 1 ; } if pointers . GetSetAutomationItemInfo . is_some () { loaded_count += 1 ; } if pointers . GetSetAutomationItemInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetEnvelopeInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetEnvelopeState . is_some () { loaded_count += 1 ; } if pointers . GetSetEnvelopeState2 . is_some () { loaded_count += 1 ; } if pointers . GetSetItemState . is_some () { loaded_count += 1 ; } if pointers . GetSetItemState2 . is_some () { loaded_count += 1 ; } if pointers . GetSetMediaItemInfo . is_some () { loaded_count += 1 ; } if pointers . GetSetMediaItemInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetMediaItemTakeInfo . is_some () { loaded_count += 1 ; } if pointers . GetSetMediaItemTakeInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetMediaTrackInfo . is_some () { loaded_count += 1 ; } if pointers . GetSetMediaTrackInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetObjectState . is_some () { loaded_count += 1 ; } if pointers . GetSetObjectState2 . is_some () { loaded_count += 1 ; } if pointers . GetSetProjectAuthor . is_some () { loaded_count += 1 ; } if pointers . GetSetProjectGrid . is_some () { loaded_count += 1 ; } if pointers . GetSetProjectInfo . is_some () { loaded_count += 1 ; } if pointers . GetSetProjectInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetProjectNotes . is_some () { loaded_count += 1 ; } if pointers . GetSetRepeat . is_some () { loaded_count += 1 ; } if pointers . GetSetRepeatEx . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackGroupMembership . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackGroupMembershipHigh . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackMIDISupportFile . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackSendInfo . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackSendInfo_String . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackState . is_some () { loaded_count += 1 ; } if pointers . GetSetTrackState2 . is_some () { loaded_count += 1 ; } if pointers . GetSubProjectFromSource . is_some () { loaded_count += 1 ; } if pointers . GetTake . is_some () { loaded_count += 1 ; } if pointers . GetTakeEnvelope . is_some () { loaded_count += 1 ; } if pointers . GetTakeEnvelopeByName . is_some () { loaded_count += 1 ; } if pointers . GetTakeMarker . is_some () { loaded_count += 1 ; } if pointers . GetTakeName . is_some () { loaded_count += 1 ; } if pointers . GetTakeNumStretchMarkers . is_some () { loaded_count += 1 ; } if pointers . GetTakeStretchMarker . is_some () { loaded_count += 1 ; } if pointers . GetTakeStretchMarkerSlope . is_some () { loaded_count += 1 ; } if pointers . GetTCPFXParm . is_some () { loaded_count += 1 ; } if pointers . GetTempoMatchPlayRate . is_some () { loaded_count += 1 ; } if pointers . GetTempoTimeSigMarker . is_some () { loaded_count += 1 ; } if pointers . GetThemeColor . is_some () { loaded_count += 1 ; } if pointers . GetThingFromPoint . is_some () { loaded_count += 1 ; } if pointers . GetToggleCommandState . is_some () { loaded_count += 1 ; } if pointers . GetToggleCommandState2 . is_some () { loaded_count += 1 ; } if pointers . GetToggleCommandStateEx . is_some () { loaded_count += 1 ; } if pointers . GetToggleCommandStateThroughHooks . is_some () { loaded_count += 1 ; } if pointers . GetTooltipWindow . is_some () { loaded_count += 1 ; } if pointers . GetTrack . is_some () { loaded_count += 1 ; } if pointers . GetTrackAutomationMode . is_some () { loaded_count += 1 ; } if pointers . GetTrackColor . is_some () { loaded_count += 1 ; } if pointers . GetTrackDepth . is_some () { loaded_count += 1 ; } if pointers . GetTrackEnvelope . is_some () { loaded_count += 1 ; } if pointers . GetTrackEnvelopeByChunkName . is_some () { loaded_count += 1 ; } if pointers . GetTrackEnvelopeByName . is_some () { loaded_count += 1 ; } if pointers . GetTrackFromPoint . is_some () { loaded_count += 1 ; } if pointers . GetTrackGUID . is_some () { loaded_count += 1 ; } if pointers . GetTrackInfo . is_some () { loaded_count += 1 ; } if pointers . GetTrackMediaItem . is_some () { loaded_count += 1 ; } if pointers . GetTrackMIDILyrics . is_some () { loaded_count += 1 ; } if pointers . GetTrackMIDINoteName . is_some () { loaded_count += 1 ; } if pointers . GetTrackMIDINoteNameEx . is_some () { loaded_count += 1 ; } if pointers . GetTrackMIDINoteRange . is_some () { loaded_count += 1 ; } if pointers . GetTrackName . is_some () { loaded_count += 1 ; } if pointers . GetTrackNumMediaItems . is_some () { loaded_count += 1 ; } if pointers . GetTrackNumSends . is_some () { loaded_count += 1 ; } if pointers . GetTrackReceiveName . is_some () { loaded_count += 1 ; } if pointers . GetTrackReceiveUIMute . is_some () { loaded_count += 1 ; } if pointers . GetTrackReceiveUIVolPan . is_some () { loaded_count += 1 ; } if pointers . GetTrackSendInfo_Value . is_some () { loaded_count += 1 ; } if pointers . GetTrackSendName . is_some () { loaded_count += 1 ; } if pointers . GetTrackSendUIMute . is_some () { loaded_count += 1 ; } if pointers . GetTrackSendUIVolPan . is_some () { loaded_count += 1 ; } if pointers . GetTrackState . is_some () { loaded_count += 1 ; } if pointers . GetTrackStateChunk . is_some () { loaded_count += 1 ; } if pointers . GetTrackUIMute . is_some () { loaded_count += 1 ; } if pointers . GetTrackUIPan . is_some () { loaded_count += 1 ; } if pointers . GetTrackUIVolPan . is_some () { loaded_count += 1 ; } if pointers . GetUnderrunTime . is_some () { loaded_count += 1 ; } if pointers . GetUserFileNameForRead . is_some () { loaded_count += 1 ; } if pointers . GetUserInputs . is_some () { loaded_count += 1 ; } if pointers . GoToMarker . is_some () { loaded_count += 1 ; } if pointers . GoToRegion . is_some () { loaded_count += 1 ; } if pointers . GR_SelectColor . is_some () { loaded_count += 1 ; } if pointers . GSC_mainwnd . is_some () { loaded_count += 1 ; } if pointers . guidToString . is_some () { loaded_count += 1 ; } if pointers . HasExtState . is_some () { loaded_count += 1 ; } if pointers . HasTrackMIDIPrograms . is_some () { loaded_count += 1 ; } if pointers . HasTrackMIDIProgramsEx . is_some () { loaded_count += 1 ; } if pointers . Help_Set . is_some () { loaded_count += 1 ; } if pointers . HiresPeaksFromSource . is_some () { loaded_count += 1 ; } if pointers . image_resolve_fn . is_some () { loaded_count += 1 ; } if pointers . InsertAutomationItem . is_some () { loaded_count += 1 ; } if pointers . InsertEnvelopePoint . is_some () { loaded_count += 1 ; } if pointers . InsertEnvelopePointEx . is_some () { loaded_count += 1 ; } if pointers . InsertMedia . is_some () { loaded_count += 1 ; } if pointers . InsertMediaSection . is_some () { loaded_count += 1 ; } if pointers . InsertTrackAtIndex . is_some () { loaded_count += 1 ; } if pointers . IsInRealTimeAudio . is_some () { loaded_count += 1 ; } if pointers . IsItemTakeActiveForPlayback . is_some () { loaded_count += 1 ; } if pointers . IsMediaExtension . is_some () { loaded_count += 1 ; } if pointers . IsMediaItemSelected . is_some () { loaded_count += 1 ; } if pointers . IsProjectDirty . is_some () { loaded_count += 1 ; } if pointers . IsREAPER . is_some () { loaded_count += 1 ; } if pointers . IsTrackSelected . is_some () { loaded_count += 1 ; } if pointers . IsTrackVisible . is_some () { loaded_count += 1 ; } if pointers . joystick_create . is_some () { loaded_count += 1 ; } if pointers . joystick_destroy . is_some () { loaded_count += 1 ; } if pointers . joystick_enum . is_some () { loaded_count += 1 ; } if pointers . joystick_getaxis . is_some () { loaded_count += 1 ; } if pointers . joystick_getbuttonmask . is_some () { loaded_count += 1 ; } if pointers . joystick_getinfo . is_some () { loaded_count += 1 ; } if pointers . joystick_getpov . is_some () { loaded_count += 1 ; } if pointers . joystick_update . is_some () { loaded_count += 1 ; } if pointers . kbd_enumerateActions . is_some () { loaded_count += 1 ; } if pointers . kbd_formatKeyName . is_some () { loaded_count += 1 ; } if pointers . kbd_getCommandName . is_some () { loaded_count += 1 ; } if pointers . kbd_getTextFromCmd . is_some () { loaded_count += 1 ; } if pointers . KBD_OnMainActionEx . is_some () { loaded_count += 1 ; } if pointers . kbd_OnMidiEvent . is_some () { loaded_count += 1 ; } if pointers . kbd_OnMidiList . is_some () { loaded_count += 1 ; } if pointers . kbd_ProcessActionsMenu . is_some () { loaded_count += 1 ; } if pointers . kbd_processMidiEventActionEx . is_some () { loaded_count += 1 ; } if pointers . kbd_reprocessMenu . is_some () { loaded_count += 1 ; } if pointers . kbd_RunCommandThroughHooks . is_some () { loaded_count += 1 ; } if pointers . kbd_translateAccelerator . is_some () { loaded_count += 1 ; } if pointers . kbd_translateMouse . is_some () { loaded_count += 1 ; } if pointers . LICE__Destroy . is_some () { loaded_count += 1 ; } if pointers . LICE__DestroyFont . is_some () { loaded_count += 1 ; } if pointers . LICE__DrawText . is_some () { loaded_count += 1 ; } if pointers . LICE__GetBits . is_some () { loaded_count += 1 ; } if pointers . LICE__GetDC . is_some () { loaded_count += 1 ; } if pointers . LICE__GetHeight . is_some () { loaded_count += 1 ; } if pointers . LICE__GetRowSpan . is_some () { loaded_count += 1 ; } if pointers . LICE__GetWidth . is_some () { loaded_count += 1 ; } if pointers . LICE__IsFlipped . is_some () { loaded_count += 1 ; } if pointers . LICE__resize . is_some () { loaded_count += 1 ; } if pointers . LICE__SetBkColor . is_some () { loaded_count += 1 ; } if pointers . LICE__SetFromHFont . is_some () { loaded_count += 1 ; } if pointers . LICE__SetTextColor . is_some () { loaded_count += 1 ; } if pointers . LICE__SetTextCombineMode . is_some () { loaded_count += 1 ; } if pointers . LICE_Arc . is_some () { loaded_count += 1 ; } if pointers . LICE_Blit . is_some () { loaded_count += 1 ; } if pointers . LICE_Blur . is_some () { loaded_count += 1 ; } if pointers . LICE_BorderedRect . is_some () { loaded_count += 1 ; } if pointers . LICE_Circle . is_some () { loaded_count += 1 ; } if pointers . LICE_Clear . is_some () { loaded_count += 1 ; } if pointers . LICE_ClearRect . is_some () { loaded_count += 1 ; } if pointers . LICE_ClipLine . is_some () { loaded_count += 1 ; } if pointers . LICE_Copy . is_some () { loaded_count += 1 ; } if pointers . LICE_CreateBitmap . is_some () { loaded_count += 1 ; } if pointers . LICE_CreateFont . is_some () { loaded_count += 1 ; } if pointers . LICE_DrawCBezier . is_some () { loaded_count += 1 ; } if pointers . LICE_DrawChar . is_some () { loaded_count += 1 ; } if pointers . LICE_DrawGlyph . is_some () { loaded_count += 1 ; } if pointers . LICE_DrawRect . is_some () { loaded_count += 1 ; } if pointers . LICE_DrawText . is_some () { loaded_count += 1 ; } if pointers . LICE_FillCBezier . is_some () { loaded_count += 1 ; } if pointers . LICE_FillCircle . is_some () { loaded_count += 1 ; } if pointers . LICE_FillConvexPolygon . is_some () { loaded_count += 1 ; } if pointers . LICE_FillRect . is_some () { loaded_count += 1 ; } if pointers . LICE_FillTrapezoid . is_some () { loaded_count += 1 ; } if pointers . LICE_FillTriangle . is_some () { loaded_count += 1 ; } if pointers . LICE_GetPixel . is_some () { loaded_count += 1 ; } if pointers . LICE_GradRect . is_some () { loaded_count += 1 ; } if pointers . LICE_Line . is_some () { loaded_count += 1 ; } if pointers . LICE_LineInt . is_some () { loaded_count += 1 ; } if pointers . LICE_LoadPNG . is_some () { loaded_count += 1 ; } if pointers . LICE_LoadPNGFromResource . is_some () { loaded_count += 1 ; } if pointers . LICE_MeasureText . is_some () { loaded_count += 1 ; } if pointers . LICE_MultiplyAddRect . is_some () { loaded_count += 1 ; } if pointers . LICE_PutPixel . is_some () { loaded_count += 1 ; } if pointers . LICE_RotatedBlit . is_some () { loaded_count += 1 ; } if pointers . LICE_RoundRect . is_some () { loaded_count += 1 ; } if pointers . LICE_ScaledBlit . is_some () { loaded_count += 1 ; } if pointers . LICE_SimpleFill . is_some () { loaded_count += 1 ; } if pointers . LICE_ThickFLine . is_some () { loaded_count += 1 ; } if pointers . LocalizeString . is_some () { loaded_count += 1 ; } if pointers . Loop_OnArrow . is_some () { loaded_count += 1 ; } if pointers . Main_OnCommand . is_some () { loaded_count += 1 ; } if pointers . Main_OnCommandEx . is_some () { loaded_count += 1 ; } if pointers . Main_openProject . is_some () { loaded_count += 1 ; } if pointers . Main_SaveProject . is_some () { loaded_count += 1 ; } if pointers . Main_SaveProjectEx . is_some () { loaded_count += 1 ; } if pointers . Main_UpdateLoopInfo . is_some () { loaded_count += 1 ; } if pointers . MarkProjectDirty . is_some () { loaded_count += 1 ; } if pointers . MarkTrackItemsDirty . is_some () { loaded_count += 1 ; } if pointers . Master_GetPlayRate . is_some () { loaded_count += 1 ; } if pointers . Master_GetPlayRateAtTime . is_some () { loaded_count += 1 ; } if pointers . Master_GetTempo . is_some () { loaded_count += 1 ; } if pointers . Master_NormalizePlayRate . is_some () { loaded_count += 1 ; } if pointers . Master_NormalizeTempo . is_some () { loaded_count += 1 ; } if pointers . MB . is_some () { loaded_count += 1 ; } if pointers . MediaItemDescendsFromTrack . is_some () { loaded_count += 1 ; } if pointers . MIDI_CountEvts . is_some () { loaded_count += 1 ; } if pointers . MIDI_DeleteCC . is_some () { loaded_count += 1 ; } if pointers . MIDI_DeleteEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_DeleteNote . is_some () { loaded_count += 1 ; } if pointers . MIDI_DeleteTextSysexEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_DisableSort . is_some () { loaded_count += 1 ; } if pointers . MIDI_EnumSelCC . is_some () { loaded_count += 1 ; } if pointers . MIDI_EnumSelEvts . is_some () { loaded_count += 1 ; } if pointers . MIDI_EnumSelNotes . is_some () { loaded_count += 1 ; } if pointers . MIDI_EnumSelTextSysexEvts . is_some () { loaded_count += 1 ; } if pointers . MIDI_eventlist_Create . is_some () { loaded_count += 1 ; } if pointers . MIDI_eventlist_Destroy . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetAllEvts . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetCC . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetCCShape . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetGrid . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetHash . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetNote . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetPPQPos_EndOfMeasure . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetPPQPos_StartOfMeasure . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetPPQPosFromProjQN . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetPPQPosFromProjTime . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetProjQNFromPPQPos . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetProjTimeFromPPQPos . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetRecentInputEvent . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetScale . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetTextSysexEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_GetTrackHash . is_some () { loaded_count += 1 ; } if pointers . midi_init . is_some () { loaded_count += 1 ; } if pointers . MIDI_InsertCC . is_some () { loaded_count += 1 ; } if pointers . MIDI_InsertEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_InsertNote . is_some () { loaded_count += 1 ; } if pointers . MIDI_InsertTextSysexEvt . is_some () { loaded_count += 1 ; } if pointers . midi_reinit . is_some () { loaded_count += 1 ; } if pointers . MIDI_SelectAll . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetAllEvts . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetCC . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetCCShape . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetItemExtents . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetNote . is_some () { loaded_count += 1 ; } if pointers . MIDI_SetTextSysexEvt . is_some () { loaded_count += 1 ; } if pointers . MIDI_Sort . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_EnumTakes . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_GetActive . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_GetMode . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_GetSetting_int . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_GetSetting_str . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_GetTake . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_LastFocused_OnCommand . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_OnCommand . is_some () { loaded_count += 1 ; } if pointers . MIDIEditor_SetSetting_int . is_some () { loaded_count += 1 ; } if pointers . mkpanstr . is_some () { loaded_count += 1 ; } if pointers . mkvolpanstr . is_some () { loaded_count += 1 ; } if pointers . mkvolstr . is_some () { loaded_count += 1 ; } if pointers . MoveEditCursor . is_some () { loaded_count += 1 ; } if pointers . MoveMediaItemToTrack . is_some () { loaded_count += 1 ; } if pointers . MuteAllTracks . is_some () { loaded_count += 1 ; } if pointers . my_getViewport . is_some () { loaded_count += 1 ; } if pointers . NamedCommandLookup . is_some () { loaded_count += 1 ; } if pointers . OnPauseButton . is_some () { loaded_count += 1 ; } if pointers . OnPauseButtonEx . is_some () { loaded_count += 1 ; } if pointers . OnPlayButton . is_some () { loaded_count += 1 ; } if pointers . OnPlayButtonEx . is_some () { loaded_count += 1 ; } if pointers . OnStopButton . is_some () { loaded_count += 1 ; } if pointers . OnStopButtonEx . is_some () { loaded_count += 1 ; } if pointers . OpenColorThemeFile . is_some () { loaded_count += 1 ; } if pointers . OpenMediaExplorer . is_some () { loaded_count += 1 ; } if pointers . OscLocalMessageToHost . is_some () { loaded_count += 1 ; } if pointers . parse_timestr . is_some () { loaded_count += 1 ; } if pointers . parse_timestr_len . is_some () { loaded_count += 1 ; } if pointers . parse_timestr_pos . is_some () { loaded_count += 1 ; } if pointers . parsepanstr . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_Create . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_CreateEx . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_CreateMIDIFile . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_CreateMIDIFileEx . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_Enum . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_GetExtension . is_some () { loaded_count += 1 ; } if pointers . PCM_Sink_ShowConfig . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_BuildPeaks . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_CreateFromFile . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_CreateFromFileEx . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_CreateFromSimple . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_CreateFromType . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_Destroy . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_GetPeaks . is_some () { loaded_count += 1 ; } if pointers . PCM_Source_GetSectionInfo . is_some () { loaded_count += 1 ; } if pointers . PeakBuild_Create . is_some () { loaded_count += 1 ; } if pointers . PeakBuild_CreateEx . is_some () { loaded_count += 1 ; } if pointers . PeakGet_Create . is_some () { loaded_count += 1 ; } if pointers . PitchShiftSubModeMenu . is_some () { loaded_count += 1 ; } if pointers . PlayPreview . is_some () { loaded_count += 1 ; } if pointers . PlayPreviewEx . is_some () { loaded_count += 1 ; } if pointers . PlayTrackPreview . is_some () { loaded_count += 1 ; } if pointers . PlayTrackPreview2 . is_some () { loaded_count += 1 ; } if pointers . PlayTrackPreview2Ex . is_some () { loaded_count += 1 ; } if pointers . plugin_getapi . is_some () { loaded_count += 1 ; } if pointers . plugin_getFilterList . is_some () { loaded_count += 1 ; } if pointers . plugin_getImportableProjectFilterList . is_some () { loaded_count += 1 ; } if pointers . plugin_register . is_some () { loaded_count += 1 ; } if pointers . PluginWantsAlwaysRunFx . is_some () { loaded_count += 1 ; } if pointers . PreventUIRefresh . is_some () { loaded_count += 1 ; } if pointers . projectconfig_var_addr . is_some () { loaded_count += 1 ; } if pointers . projectconfig_var_getoffs . is_some () { loaded_count += 1 ; } if pointers . PromptForAction . is_some () { loaded_count += 1 ; } if pointers . realloc_cmd_clear . is_some () { loaded_count += 1 ; } if pointers . realloc_cmd_ptr . is_some () { loaded_count += 1 ; } if pointers . realloc_cmd_register_buf . is_some () { loaded_count += 1 ; } if pointers . ReaperGetPitchShiftAPI . is_some () { loaded_count += 1 ; } if pointers . ReaScriptError . is_some () { loaded_count += 1 ; } if pointers . RecursiveCreateDirectory . is_some () { loaded_count += 1 ; } if pointers . reduce_open_files . is_some () { loaded_count += 1 ; } if pointers . RefreshToolbar . is_some () { loaded_count += 1 ; } if pointers . RefreshToolbar2 . is_some () { loaded_count += 1 ; } if pointers . relative_fn . is_some () { loaded_count += 1 ; } if pointers . RemoveTrackSend . is_some () { loaded_count += 1 ; } if pointers . RenderFileSection . is_some () { loaded_count += 1 ; } if pointers . ReorderSelectedTracks . is_some () { loaded_count += 1 ; } if pointers . Resample_EnumModes . is_some () { loaded_count += 1 ; } if pointers . Resampler_Create . is_some () { loaded_count += 1 ; } if pointers . resolve_fn . is_some () { loaded_count += 1 ; } if pointers . resolve_fn2 . is_some () { loaded_count += 1 ; } if pointers . ResolveRenderPattern . is_some () { loaded_count += 1 ; } if pointers . ReverseNamedCommandLookup . is_some () { loaded_count += 1 ; } if pointers . ScaleFromEnvelopeMode . is_some () { loaded_count += 1 ; } if pointers . ScaleToEnvelopeMode . is_some () { loaded_count += 1 ; } if pointers . screenset_register . is_some () { loaded_count += 1 ; } if pointers . screenset_registerNew . is_some () { loaded_count += 1 ; } if pointers . screenset_unregister . is_some () { loaded_count += 1 ; } if pointers . screenset_unregisterByParam . is_some () { loaded_count += 1 ; } if pointers . screenset_updateLastFocus . is_some () { loaded_count += 1 ; } if pointers . SectionFromUniqueID . is_some () { loaded_count += 1 ; } if pointers . SelectAllMediaItems . is_some () { loaded_count += 1 ; } if pointers . SelectProjectInstance . is_some () { loaded_count += 1 ; } if pointers . SendLocalOscMessage . is_some () { loaded_count += 1 ; } if pointers . SetActiveTake . is_some () { loaded_count += 1 ; } if pointers . SetAutomationMode . is_some () { loaded_count += 1 ; } if pointers . SetCurrentBPM . is_some () { loaded_count += 1 ; } if pointers . SetCursorContext . is_some () { loaded_count += 1 ; } if pointers . SetEditCurPos . is_some () { loaded_count += 1 ; } if pointers . SetEditCurPos2 . is_some () { loaded_count += 1 ; } if pointers . SetEnvelopePoint . is_some () { loaded_count += 1 ; } if pointers . SetEnvelopePointEx . is_some () { loaded_count += 1 ; } if pointers . SetEnvelopeStateChunk . is_some () { loaded_count += 1 ; } if pointers . SetExtState . is_some () { loaded_count += 1 ; } if pointers . SetGlobalAutomationOverride . is_some () { loaded_count += 1 ; } if pointers . SetItemStateChunk . is_some () { loaded_count += 1 ; } if pointers . SetMasterTrackVisibility . is_some () { loaded_count += 1 ; } if pointers . SetMediaItemInfo_Value . is_some () { loaded_count += 1 ; } if pointers . SetMediaItemLength . is_some () { loaded_count += 1 ; } if pointers . SetMediaItemPosition . is_some () { loaded_count += 1 ; } if pointers . SetMediaItemSelected . is_some () { loaded_count += 1 ; } if pointers . SetMediaItemTake_Source . is_some () { loaded_count += 1 ; } if pointers . SetMediaItemTakeInfo_Value . is_some () { loaded_count += 1 ; } if pointers . SetMediaTrackInfo_Value . is_some () { loaded_count += 1 ; } if pointers . SetMIDIEditorGrid . is_some () { loaded_count += 1 ; } if pointers . SetMixerScroll . is_some () { loaded_count += 1 ; } if pointers . SetMouseModifier . is_some () { loaded_count += 1 ; } if pointers . SetOnlyTrackSelected . is_some () { loaded_count += 1 ; } if pointers . SetProjectGrid . is_some () { loaded_count += 1 ; } if pointers . SetProjectMarker . is_some () { loaded_count += 1 ; } if pointers . SetProjectMarker2 . is_some () { loaded_count += 1 ; } if pointers . SetProjectMarker3 . is_some () { loaded_count += 1 ; } if pointers . SetProjectMarker4 . is_some () { loaded_count += 1 ; } if pointers . SetProjectMarkerByIndex . is_some () { loaded_count += 1 ; } if pointers . SetProjectMarkerByIndex2 . is_some () { loaded_count += 1 ; } if pointers . SetProjExtState . is_some () { loaded_count += 1 ; } if pointers . SetRegionRenderMatrix . is_some () { loaded_count += 1 ; } if pointers . SetRenderLastError . is_some () { loaded_count += 1 ; } if pointers . SetTakeMarker . is_some () { loaded_count += 1 ; } if pointers . SetTakeStretchMarker . is_some () { loaded_count += 1 ; } if pointers . SetTakeStretchMarkerSlope . is_some () { loaded_count += 1 ; } if pointers . SetTempoTimeSigMarker . is_some () { loaded_count += 1 ; } if pointers . SetThemeColor . is_some () { loaded_count += 1 ; } if pointers . SetToggleCommandState . is_some () { loaded_count += 1 ; } if pointers . SetTrackAutomationMode . is_some () { loaded_count += 1 ; } if pointers . SetTrackColor . is_some () { loaded_count += 1 ; } if pointers . SetTrackMIDILyrics . is_some () { loaded_count += 1 ; } if pointers . SetTrackMIDINoteName . is_some () { loaded_count += 1 ; } if pointers . SetTrackMIDINoteNameEx . is_some () { loaded_count += 1 ; } if pointers . SetTrackSelected . is_some () { loaded_count += 1 ; } if pointers . SetTrackSendInfo_Value . is_some () { loaded_count += 1 ; } if pointers . SetTrackSendUIPan . is_some () { loaded_count += 1 ; } if pointers . SetTrackSendUIVol . is_some () { loaded_count += 1 ; } if pointers . SetTrackStateChunk . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIInputMonitor . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIMute . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIPan . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIPolarity . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIRecArm . is_some () { loaded_count += 1 ; } if pointers . SetTrackUISolo . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIVolume . is_some () { loaded_count += 1 ; } if pointers . SetTrackUIWidth . is_some () { loaded_count += 1 ; } if pointers . ShowActionList . is_some () { loaded_count += 1 ; } if pointers . ShowConsoleMsg . is_some () { loaded_count += 1 ; } if pointers . ShowMessageBox . is_some () { loaded_count += 1 ; } if pointers . ShowPopupMenu . is_some () { loaded_count += 1 ; } if pointers . SLIDER2DB . is_some () { loaded_count += 1 ; } if pointers . SnapToGrid . is_some () { loaded_count += 1 ; } if pointers . SoloAllTracks . is_some () { loaded_count += 1 ; } if pointers . Splash_GetWnd . is_some () { loaded_count += 1 ; } if pointers . SplitMediaItem . is_some () { loaded_count += 1 ; } if pointers . StopPreview . is_some () { loaded_count += 1 ; } if pointers . StopTrackPreview . is_some () { loaded_count += 1 ; } if pointers . StopTrackPreview2 . is_some () { loaded_count += 1 ; } if pointers . stringToGuid . is_some () { loaded_count += 1 ; } if pointers . StuffMIDIMessage . is_some () { loaded_count += 1 ; } if pointers . TakeFX_AddByName . is_some () { loaded_count += 1 ; } if pointers . TakeFX_CopyToTake . is_some () { loaded_count += 1 ; } if pointers . TakeFX_CopyToTrack . is_some () { loaded_count += 1 ; } if pointers . TakeFX_Delete . is_some () { loaded_count += 1 ; } if pointers . TakeFX_EndParamEdit . is_some () { loaded_count += 1 ; } if pointers . TakeFX_FormatParamValue . is_some () { loaded_count += 1 ; } if pointers . TakeFX_FormatParamValueNormalized . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetChainVisible . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetCount . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetEnabled . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetEnvelope . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetFloatingWindow . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetFormattedParamValue . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetFXGUID . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetFXName . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetIOSize . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetNamedConfigParm . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetNumParams . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetOffline . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetOpen . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParam . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParameterStepSizes . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParamEx . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParamFromIdent . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParamIdent . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParamName . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetParamNormalized . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetPinMappings . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetPreset . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetPresetIndex . is_some () { loaded_count += 1 ; } if pointers . TakeFX_GetUserPresetFilename . is_some () { loaded_count += 1 ; } if pointers . TakeFX_NavigatePresets . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetEnabled . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetNamedConfigParm . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetOffline . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetOpen . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetParam . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetParamNormalized . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetPinMappings . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetPreset . is_some () { loaded_count += 1 ; } if pointers . TakeFX_SetPresetByIndex . is_some () { loaded_count += 1 ; } if pointers . TakeFX_Show . is_some () { loaded_count += 1 ; } if pointers . TakeIsMIDI . is_some () { loaded_count += 1 ; } if pointers . ThemeLayout_GetLayout . is_some () { loaded_count += 1 ; } if pointers . ThemeLayout_GetParameter . is_some () { loaded_count += 1 ; } if pointers . ThemeLayout_RefreshAll . is_some () { loaded_count += 1 ; } if pointers . ThemeLayout_SetLayout . is_some () { loaded_count += 1 ; } if pointers . ThemeLayout_SetParameter . is_some () { loaded_count += 1 ; } if pointers . time_precise . is_some () { loaded_count += 1 ; } if pointers . TimeMap2_beatsToTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap2_GetDividedBpmAtTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap2_GetNextChangeTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap2_QNToTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap2_timeToBeats . is_some () { loaded_count += 1 ; } if pointers . TimeMap2_timeToQN . is_some () { loaded_count += 1 ; } if pointers . TimeMap_curFrameRate . is_some () { loaded_count += 1 ; } if pointers . TimeMap_GetDividedBpmAtTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap_GetMeasureInfo . is_some () { loaded_count += 1 ; } if pointers . TimeMap_GetMetronomePattern . is_some () { loaded_count += 1 ; } if pointers . TimeMap_GetTimeSigAtTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap_QNToMeasures . is_some () { loaded_count += 1 ; } if pointers . TimeMap_QNToTime . is_some () { loaded_count += 1 ; } if pointers . TimeMap_QNToTime_abs . is_some () { loaded_count += 1 ; } if pointers . TimeMap_timeToQN . is_some () { loaded_count += 1 ; } if pointers . TimeMap_timeToQN_abs . is_some () { loaded_count += 1 ; } if pointers . ToggleTrackSendUIMute . is_some () { loaded_count += 1 ; } if pointers . Track_GetPeakHoldDB . is_some () { loaded_count += 1 ; } if pointers . Track_GetPeakInfo . is_some () { loaded_count += 1 ; } if pointers . TrackCtl_SetToolTip . is_some () { loaded_count += 1 ; } if pointers . TrackFX_AddByName . is_some () { loaded_count += 1 ; } if pointers . TrackFX_CopyToTake . is_some () { loaded_count += 1 ; } if pointers . TrackFX_CopyToTrack . is_some () { loaded_count += 1 ; } if pointers . TrackFX_Delete . is_some () { loaded_count += 1 ; } if pointers . TrackFX_EndParamEdit . is_some () { loaded_count += 1 ; } if pointers . TrackFX_FormatParamValue . is_some () { loaded_count += 1 ; } if pointers . TrackFX_FormatParamValueNormalized . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetByName . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetChainVisible . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetCount . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetEnabled . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetEQ . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetEQBandEnabled . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetEQParam . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetFloatingWindow . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetFormattedParamValue . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetFXGUID . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetFXName . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetInstrument . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetIOSize . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetNamedConfigParm . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetNumParams . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetOffline . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetOpen . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParam . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParameterStepSizes . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParamEx . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParamFromIdent . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParamIdent . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParamName . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetParamNormalized . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetPinMappings . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetPreset . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetPresetIndex . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetRecChainVisible . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetRecCount . is_some () { loaded_count += 1 ; } if pointers . TrackFX_GetUserPresetFilename . is_some () { loaded_count += 1 ; } if pointers . TrackFX_NavigatePresets . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetEnabled . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetEQBandEnabled . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetEQParam . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetNamedConfigParm . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetOffline . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetOpen . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetParam . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetParamNormalized . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetPinMappings . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetPreset . is_some () { loaded_count += 1 ; } if pointers . TrackFX_SetPresetByIndex . is_some () { loaded_count += 1 ; } if pointers . TrackFX_Show . is_some () { loaded_count += 1 ; } if pointers . TrackList_AdjustWindows . is_some () { loaded_count += 1 ; } if pointers . TrackList_UpdateAllExternalSurfaces . is_some () { loaded_count += 1 ; } if pointers . Undo_BeginBlock . is_some () { loaded_count += 1 ; } if pointers . Undo_BeginBlock2 . is_some () { loaded_count += 1 ; } if pointers . Undo_CanRedo2 . is_some () { loaded_count += 1 ; } if pointers . Undo_CanUndo2 . is_some () { loaded_count += 1 ; } if pointers . Undo_DoRedo2 . is_some () { loaded_count += 1 ; } if pointers . Undo_DoUndo2 . is_some () { loaded_count += 1 ; } if pointers . Undo_EndBlock . is_some () { loaded_count += 1 ; } if pointers . Undo_EndBlock2 . is_some () { loaded_count += 1 ; } if pointers . Undo_OnStateChange . is_some () { loaded_count += 1 ; } if pointers . Undo_OnStateChange2 . is_some () { loaded_count += 1 ; } if pointers . Undo_OnStateChange_Item . is_some () { loaded_count += 1 ; } if pointers . Undo_OnStateChangeEx . is_some () { loaded_count += 1 ; } if pointers . Undo_OnStateChangeEx2 . is_some () { loaded_count += 1 ; } if pointers . update_disk_counters . is_some () { loaded_count += 1 ; } if pointers . UpdateArrange . is_some () { loaded_count += 1 ; } if pointers . UpdateItemInProject . is_some () { loaded_count += 1 ; } if pointers . UpdateTimeline . is_some () { loaded_count += 1 ; } if pointers . ValidatePtr . is_some () { loaded_count += 1 ; } if pointers . ValidatePtr2 . is_some () { loaded_count += 1 ; } if pointers . ViewPrefs . is_some () { loaded_count += 1 ; } if pointers . WDL_VirtualWnd_ScaledBlitBG . is_some () { loaded_count += 1 ; } if pointers . GetMidiInput . is_some () { loaded_count += 1 ; } if pointers . GetMidiOutput . is_some () { loaded_count += 1 ; } if pointers . InitializeCoolSB . is_some () { loaded_count += 1 ; } if pointers . UninitializeCoolSB . is_some () { loaded_count += 1 ; } if pointers . CoolSB_SetMinThumbSize . is_some () { loaded_count += 1 ; } if pointers . CoolSB_GetScrollInfo . is_some () { loaded_count += 1 ; } if pointers . CoolSB_SetScrollInfo . is_some () { loaded_count += 1 ; } if pointers . CoolSB_SetScrollPos . is_some () { loaded_count += 1 ; } if pointers . CoolSB_SetScrollRange . is_some () { loaded_count += 1 ; } if pointers . CoolSB_ShowScrollBar . is_some () { loaded_count += 1 ; } if pointers . CoolSB_SetResizingThumb . is_some () { loaded_count += 1 ; } if pointers . CoolSB_SetThemeIndex . is_some () { loaded_count += 1 ; } pointers . loaded_count = loaded_count ; Reaper { pointers , plugin_context : Some (plugin_context) } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn __mergesort (& self , base : * mut :: std :: os :: raw :: c_void , nmemb : usize , size : usize , cmpfunc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ,) -> :: std :: os :: raw :: c_int , > , tmpspace : * mut :: std :: os :: raw :: c_void) { match self . pointers . __mergesort { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (__mergesort)) , Some (f) => f (base , nmemb , size , cmpfunc , tmpspace) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddCustomizableMenu (& self , menuidstr : * const :: std :: os :: raw :: c_char , menuname : * const :: std :: os :: raw :: c_char , kbdsecname : * const :: std :: os :: raw :: c_char , addtomainmenu : bool) -> bool { match self . pointers . AddCustomizableMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddCustomizableMenu)) , Some (f) => f (menuidstr , menuname , kbdsecname , addtomainmenu) , } } pub fn AddExtensionsMainMenu (& self) -> bool { match self . pointers . AddExtensionsMainMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddExtensionsMainMenu)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddMediaItemToTrack (& self , tr : * mut root :: MediaTrack) -> * mut root :: MediaItem { match self . pointers . AddMediaItemToTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddMediaItemToTrack)) , Some (f) => f (tr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddProjectMarker (& self , proj : * mut root :: ReaProject , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , wantidx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . AddProjectMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddProjectMarker)) , Some (f) => f (proj , isrgn , pos , rgnend , name , wantidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddProjectMarker2 (& self , proj : * mut root :: ReaProject , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , wantidx : :: std :: os :: raw :: c_int , color : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . AddProjectMarker2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddProjectMarker2)) , Some (f) => f (proj , isrgn , pos , rgnend , name , wantidx , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddRemoveReaScript (& self , add : bool , sectionID : :: std :: os :: raw :: c_int , scriptfn : * const :: std :: os :: raw :: c_char , commit : bool) -> :: std :: os :: raw :: c_int { match self . pointers . AddRemoveReaScript { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddRemoveReaScript)) , Some (f) => f (add , sectionID , scriptfn , commit) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddTakeToMediaItem (& self , item : * mut root :: MediaItem) -> * mut root :: MediaItem_Take { match self . pointers . AddTakeToMediaItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddTakeToMediaItem)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AddTempoTimeSigMarker (& self , proj : * mut root :: ReaProject , timepos : f64 , bpm : f64 , timesig_num : :: std :: os :: raw :: c_int , timesig_denom : :: std :: os :: raw :: c_int , lineartempochange : bool) -> bool { match self . pointers . AddTempoTimeSigMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AddTempoTimeSigMarker)) , Some (f) => f (proj , timepos , bpm , timesig_num , timesig_denom , lineartempochange) , } } pub fn adjustZoom (& self , amt : f64 , forceset : :: std :: os :: raw :: c_int , doupd : bool , centermode : :: std :: os :: raw :: c_int) { match self . pointers . adjustZoom { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (adjustZoom)) , Some (f) => f (amt , forceset , doupd , centermode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AnyTrackSolo (& self , proj : * mut root :: ReaProject) -> bool { match self . pointers . AnyTrackSolo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AnyTrackSolo)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn APIExists (& self , function_name : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . APIExists { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (APIExists)) , Some (f) => f (function_name) , } } pub fn APITest (& self) { match self . pointers . APITest { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (APITest)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ApplyNudge (& self , project : * mut root :: ReaProject , nudgeflag : :: std :: os :: raw :: c_int , nudgewhat : :: std :: os :: raw :: c_int , nudgeunits : :: std :: os :: raw :: c_int , value : f64 , reverse : bool , copies : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ApplyNudge { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ApplyNudge)) , Some (f) => f (project , nudgeflag , nudgewhat , nudgeunits , value , reverse , copies) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ArmCommand (& self , cmd : :: std :: os :: raw :: c_int , sectionname : * const :: std :: os :: raw :: c_char) { match self . pointers . ArmCommand { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ArmCommand)) , Some (f) => f (cmd , sectionname) , } } pub fn Audio_Init (& self) { match self . pointers . Audio_Init { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Audio_Init)) , Some (f) => f () , } } pub fn Audio_IsPreBuffer (& self) -> :: std :: os :: raw :: c_int { match self . pointers . Audio_IsPreBuffer { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Audio_IsPreBuffer)) , Some (f) => f () , } } pub fn Audio_IsRunning (& self) -> :: std :: os :: raw :: c_int { match self . pointers . Audio_IsRunning { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Audio_IsRunning)) , Some (f) => f () , } } pub fn Audio_Quit (& self) { match self . pointers . Audio_Quit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Audio_Quit)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Audio_RegHardwareHook (& self , isAdd : bool , reg : * mut root :: audio_hook_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . Audio_RegHardwareHook { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Audio_RegHardwareHook)) , Some (f) => f (isAdd , reg) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AudioAccessorStateChanged (& self , accessor : * mut root :: reaper_functions :: AudioAccessor) -> bool { match self . pointers . AudioAccessorStateChanged { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AudioAccessorStateChanged)) , Some (f) => f (accessor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AudioAccessorUpdate (& self , accessor : * mut root :: reaper_functions :: AudioAccessor) { match self . pointers . AudioAccessorUpdate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AudioAccessorUpdate)) , Some (f) => f (accessor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn AudioAccessorValidateState (& self , accessor : * mut root :: reaper_functions :: AudioAccessor) -> bool { match self . pointers . AudioAccessorValidateState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (AudioAccessorValidateState)) , Some (f) => f (accessor) , } } pub fn BypassFxAllTracks (& self , bypass : :: std :: os :: raw :: c_int) { match self . pointers . BypassFxAllTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (BypassFxAllTracks)) , Some (f) => f (bypass) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CalcMediaSrcLoudness (& self , mediasource : * mut root :: PCM_source) -> :: std :: os :: raw :: c_int { match self . pointers . CalcMediaSrcLoudness { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CalcMediaSrcLoudness)) , Some (f) => f (mediasource) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CalculateNormalization (& self , source : * mut root :: PCM_source , normalizeTo : :: std :: os :: raw :: c_int , normalizeTarget : f64 , normalizeStart : f64 , normalizeEnd : f64) -> f64 { match self . pointers . CalculateNormalization { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CalculateNormalization)) , Some (f) => f (source , normalizeTo , normalizeTarget , normalizeStart , normalizeEnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CalculatePeaks (& self , srcBlock : * mut root :: PCM_source_transfer_t , pksBlock : * mut root :: PCM_source_peaktransfer_t) -> :: std :: os :: raw :: c_int { match self . pointers . CalculatePeaks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CalculatePeaks)) , Some (f) => f (srcBlock , pksBlock) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CalculatePeaksFloatSrcPtr (& self , srcBlock : * mut root :: PCM_source_transfer_t , pksBlock : * mut root :: PCM_source_peaktransfer_t) -> :: std :: os :: raw :: c_int { match self . pointers . CalculatePeaksFloatSrcPtr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CalculatePeaksFloatSrcPtr)) , Some (f) => f (srcBlock , pksBlock) , } } pub fn ClearAllRecArmed (& self) { match self . pointers . ClearAllRecArmed { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ClearAllRecArmed)) , Some (f) => f () , } } pub fn ClearConsole (& self) { match self . pointers . ClearConsole { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ClearConsole)) , Some (f) => f () , } } pub fn ClearPeakCache (& self) { match self . pointers . ClearPeakCache { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ClearPeakCache)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ColorFromNative (& self , col : :: std :: os :: raw :: c_int , rOut : * mut :: std :: os :: raw :: c_int , gOut : * mut :: std :: os :: raw :: c_int , bOut : * mut :: std :: os :: raw :: c_int) { match self . pointers . ColorFromNative { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ColorFromNative)) , Some (f) => f (col , rOut , gOut , bOut) , } } pub fn ColorToNative (& self , r : :: std :: os :: raw :: c_int , g : :: std :: os :: raw :: c_int , b : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . ColorToNative { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ColorToNative)) , Some (f) => f (r , g , b) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountActionShortcuts (& self , section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . CountActionShortcuts { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountActionShortcuts)) , Some (f) => f (section , cmdID) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountAutomationItems (& self , env : * mut root :: TrackEnvelope) -> :: std :: os :: raw :: c_int { match self . pointers . CountAutomationItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountAutomationItems)) , Some (f) => f (env) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountEnvelopePoints (& self , envelope : * mut root :: TrackEnvelope) -> :: std :: os :: raw :: c_int { match self . pointers . CountEnvelopePoints { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountEnvelopePoints)) , Some (f) => f (envelope) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountEnvelopePointsEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . CountEnvelopePointsEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountEnvelopePointsEx)) , Some (f) => f (envelope , autoitem_idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountMediaItems (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . CountMediaItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountMediaItems)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountProjectMarkers (& self , proj : * mut root :: ReaProject , num_markersOut : * mut :: std :: os :: raw :: c_int , num_regionsOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . CountProjectMarkers { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountProjectMarkers)) , Some (f) => f (proj , num_markersOut , num_regionsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountSelectedMediaItems (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . CountSelectedMediaItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountSelectedMediaItems)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountSelectedTracks (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . CountSelectedTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountSelectedTracks)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountSelectedTracks2 (& self , proj : * mut root :: ReaProject , wantmaster : bool) -> :: std :: os :: raw :: c_int { match self . pointers . CountSelectedTracks2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountSelectedTracks2)) , Some (f) => f (proj , wantmaster) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTakeEnvelopes (& self , take : * mut root :: MediaItem_Take) -> :: std :: os :: raw :: c_int { match self . pointers . CountTakeEnvelopes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTakeEnvelopes)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTakes (& self , item : * mut root :: MediaItem) -> :: std :: os :: raw :: c_int { match self . pointers . CountTakes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTakes)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTCPFXParms (& self , project : * mut root :: ReaProject , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . CountTCPFXParms { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTCPFXParms)) , Some (f) => f (project , track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTempoTimeSigMarkers (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . CountTempoTimeSigMarkers { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTempoTimeSigMarkers)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTrackEnvelopes (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . CountTrackEnvelopes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTrackEnvelopes)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTrackMediaItems (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . CountTrackMediaItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTrackMediaItems)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CountTracks (& self , projOptional : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . CountTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CountTracks)) , Some (f) => f (projOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateLocalOscHandler (& self , obj : * mut :: std :: os :: raw :: c_void , callback : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { match self . pointers . CreateLocalOscHandler { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateLocalOscHandler)) , Some (f) => f (obj , callback) , } } pub fn CreateMIDIInput (& self , dev : :: std :: os :: raw :: c_int) -> * mut root :: midi_Input { match self . pointers . CreateMIDIInput { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateMIDIInput)) , Some (f) => f (dev) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateMIDIOutput (& self , dev : :: std :: os :: raw :: c_int , streamMode : bool , msoffset100 : * mut :: std :: os :: raw :: c_int) -> * mut root :: midi_Output { match self . pointers . CreateMIDIOutput { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateMIDIOutput)) , Some (f) => f (dev , streamMode , msoffset100) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateNewMIDIItemInProj (& self , track : * mut root :: MediaTrack , starttime : f64 , endtime : f64 , qnInOptional : * const bool) -> * mut root :: MediaItem { match self . pointers . CreateNewMIDIItemInProj { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateNewMIDIItemInProj)) , Some (f) => f (track , starttime , endtime , qnInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateTakeAudioAccessor (& self , take : * mut root :: MediaItem_Take) -> * mut root :: reaper_functions :: AudioAccessor { match self . pointers . CreateTakeAudioAccessor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateTakeAudioAccessor)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateTrackAudioAccessor (& self , track : * mut root :: MediaTrack) -> * mut root :: reaper_functions :: AudioAccessor { match self . pointers . CreateTrackAudioAccessor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateTrackAudioAccessor)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CreateTrackSend (& self , tr : * mut root :: MediaTrack , desttrInOptional : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . CreateTrackSend { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CreateTrackSend)) , Some (f) => f (tr , desttrInOptional) , } } pub fn CSurf_FlushUndo (& self , force : bool) { match self . pointers . CSurf_FlushUndo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_FlushUndo)) , Some (f) => f (force) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_GetTouchState (& self , trackid : * mut root :: MediaTrack , isPan : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CSurf_GetTouchState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_GetTouchState)) , Some (f) => f (trackid , isPan) , } } pub fn CSurf_GoEnd (& self) { match self . pointers . CSurf_GoEnd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_GoEnd)) , Some (f) => f () , } } pub fn CSurf_GoStart (& self) { match self . pointers . CSurf_GoStart { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_GoStart)) , Some (f) => f () , } } pub fn CSurf_NumTracks (& self , mcpView : bool) -> :: std :: os :: raw :: c_int { match self . pointers . CSurf_NumTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_NumTracks)) , Some (f) => f (mcpView) , } } pub fn CSurf_OnArrow (& self , whichdir : :: std :: os :: raw :: c_int , wantzoom : bool) { match self . pointers . CSurf_OnArrow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnArrow)) , Some (f) => f (whichdir , wantzoom) , } } pub fn CSurf_OnFwd (& self , seekplay : :: std :: os :: raw :: c_int) { match self . pointers . CSurf_OnFwd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnFwd)) , Some (f) => f (seekplay) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnFXChange (& self , trackid : * mut root :: MediaTrack , en : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CSurf_OnFXChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnFXChange)) , Some (f) => f (trackid , en) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnInputMonitorChange (& self , trackid : * mut root :: MediaTrack , monitor : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . CSurf_OnInputMonitorChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnInputMonitorChange)) , Some (f) => f (trackid , monitor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnInputMonitorChangeEx (& self , trackid : * mut root :: MediaTrack , monitor : :: std :: os :: raw :: c_int , allowgang : bool) -> :: std :: os :: raw :: c_int { match self . pointers . CSurf_OnInputMonitorChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnInputMonitorChangeEx)) , Some (f) => f (trackid , monitor , allowgang) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnMuteChange (& self , trackid : * mut root :: MediaTrack , mute : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CSurf_OnMuteChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnMuteChange)) , Some (f) => f (trackid , mute) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnMuteChangeEx (& self , trackid : * mut root :: MediaTrack , mute : :: std :: os :: raw :: c_int , allowgang : bool) -> bool { match self . pointers . CSurf_OnMuteChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnMuteChangeEx)) , Some (f) => f (trackid , mute , allowgang) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnOscControlMessage (& self , msg : * const :: std :: os :: raw :: c_char , arg : * const f32) { match self . pointers . CSurf_OnOscControlMessage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnOscControlMessage)) , Some (f) => f (msg , arg) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnOscControlMessage2 (& self , msg : * const :: std :: os :: raw :: c_char , arg : * const f32 , argstr : * const :: std :: os :: raw :: c_char) { match self . pointers . CSurf_OnOscControlMessage2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnOscControlMessage2)) , Some (f) => f (msg , arg , argstr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnPanChange (& self , trackid : * mut root :: MediaTrack , pan : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnPanChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnPanChange)) , Some (f) => f (trackid , pan , relative) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnPanChangeEx (& self , trackid : * mut root :: MediaTrack , pan : f64 , relative : bool , allowGang : bool) -> f64 { match self . pointers . CSurf_OnPanChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnPanChangeEx)) , Some (f) => f (trackid , pan , relative , allowGang) , } } pub fn CSurf_OnPause (& self) { match self . pointers . CSurf_OnPause { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnPause)) , Some (f) => f () , } } pub fn CSurf_OnPlay (& self) { match self . pointers . CSurf_OnPlay { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnPlay)) , Some (f) => f () , } } pub fn CSurf_OnPlayRateChange (& self , playrate : f64) { match self . pointers . CSurf_OnPlayRateChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnPlayRateChange)) , Some (f) => f (playrate) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnRecArmChange (& self , trackid : * mut root :: MediaTrack , recarm : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CSurf_OnRecArmChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRecArmChange)) , Some (f) => f (trackid , recarm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnRecArmChangeEx (& self , trackid : * mut root :: MediaTrack , recarm : :: std :: os :: raw :: c_int , allowgang : bool) -> bool { match self . pointers . CSurf_OnRecArmChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRecArmChangeEx)) , Some (f) => f (trackid , recarm , allowgang) , } } pub fn CSurf_OnRecord (& self) { match self . pointers . CSurf_OnRecord { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRecord)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnRecvPanChange (& self , trackid : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , pan : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnRecvPanChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRecvPanChange)) , Some (f) => f (trackid , recv_index , pan , relative) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnRecvVolumeChange (& self , trackid : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , volume : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnRecvVolumeChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRecvVolumeChange)) , Some (f) => f (trackid , recv_index , volume , relative) , } } pub fn CSurf_OnRew (& self , seekplay : :: std :: os :: raw :: c_int) { match self . pointers . CSurf_OnRew { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRew)) , Some (f) => f (seekplay) , } } pub fn CSurf_OnRewFwd (& self , seekplay : :: std :: os :: raw :: c_int , dir : :: std :: os :: raw :: c_int) { match self . pointers . CSurf_OnRewFwd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnRewFwd)) , Some (f) => f (seekplay , dir) , } } pub fn CSurf_OnScroll (& self , xdir : :: std :: os :: raw :: c_int , ydir : :: std :: os :: raw :: c_int) { match self . pointers . CSurf_OnScroll { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnScroll)) , Some (f) => f (xdir , ydir) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnSelectedChange (& self , trackid : * mut root :: MediaTrack , selected : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CSurf_OnSelectedChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnSelectedChange)) , Some (f) => f (trackid , selected) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnSendPanChange (& self , trackid : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , pan : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnSendPanChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnSendPanChange)) , Some (f) => f (trackid , send_index , pan , relative) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnSendVolumeChange (& self , trackid : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , volume : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnSendVolumeChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnSendVolumeChange)) , Some (f) => f (trackid , send_index , volume , relative) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnSoloChange (& self , trackid : * mut root :: MediaTrack , solo : :: std :: os :: raw :: c_int) -> bool { match self . pointers . CSurf_OnSoloChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnSoloChange)) , Some (f) => f (trackid , solo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnSoloChangeEx (& self , trackid : * mut root :: MediaTrack , solo : :: std :: os :: raw :: c_int , allowgang : bool) -> bool { match self . pointers . CSurf_OnSoloChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnSoloChangeEx)) , Some (f) => f (trackid , solo , allowgang) , } } pub fn CSurf_OnStop (& self) { match self . pointers . CSurf_OnStop { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnStop)) , Some (f) => f () , } } pub fn CSurf_OnTempoChange (& self , bpm : f64) { match self . pointers . CSurf_OnTempoChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnTempoChange)) , Some (f) => f (bpm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnTrackSelection (& self , trackid : * mut root :: MediaTrack) { match self . pointers . CSurf_OnTrackSelection { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnTrackSelection)) , Some (f) => f (trackid) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnVolumeChange (& self , trackid : * mut root :: MediaTrack , volume : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnVolumeChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnVolumeChange)) , Some (f) => f (trackid , volume , relative) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnVolumeChangeEx (& self , trackid : * mut root :: MediaTrack , volume : f64 , relative : bool , allowGang : bool) -> f64 { match self . pointers . CSurf_OnVolumeChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnVolumeChangeEx)) , Some (f) => f (trackid , volume , relative , allowGang) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnWidthChange (& self , trackid : * mut root :: MediaTrack , width : f64 , relative : bool) -> f64 { match self . pointers . CSurf_OnWidthChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnWidthChange)) , Some (f) => f (trackid , width , relative) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_OnWidthChangeEx (& self , trackid : * mut root :: MediaTrack , width : f64 , relative : bool , allowGang : bool) -> f64 { match self . pointers . CSurf_OnWidthChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnWidthChangeEx)) , Some (f) => f (trackid , width , relative , allowGang) , } } pub fn CSurf_OnZoom (& self , xdir : :: std :: os :: raw :: c_int , ydir : :: std :: os :: raw :: c_int) { match self . pointers . CSurf_OnZoom { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_OnZoom)) , Some (f) => f (xdir , ydir) , } } pub fn CSurf_ResetAllCachedVolPanStates (& self) { match self . pointers . CSurf_ResetAllCachedVolPanStates { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_ResetAllCachedVolPanStates)) , Some (f) => f () , } } pub fn CSurf_ScrubAmt (& self , amt : f64) { match self . pointers . CSurf_ScrubAmt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_ScrubAmt)) , Some (f) => f (amt) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetAutoMode (& self , mode : :: std :: os :: raw :: c_int , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetAutoMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetAutoMode)) , Some (f) => f (mode , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetPlayState (& self , play : bool , pause : bool , rec : bool , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetPlayState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetPlayState)) , Some (f) => f (play , pause , rec , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetRepeatState (& self , rep : bool , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetRepeatState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetRepeatState)) , Some (f) => f (rep , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetSurfaceMute (& self , trackid : * mut root :: MediaTrack , mute : bool , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetSurfaceMute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetSurfaceMute)) , Some (f) => f (trackid , mute , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetSurfacePan (& self , trackid : * mut root :: MediaTrack , pan : f64 , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetSurfacePan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetSurfacePan)) , Some (f) => f (trackid , pan , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetSurfaceRecArm (& self , trackid : * mut root :: MediaTrack , recarm : bool , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetSurfaceRecArm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetSurfaceRecArm)) , Some (f) => f (trackid , recarm , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetSurfaceSelected (& self , trackid : * mut root :: MediaTrack , selected : bool , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetSurfaceSelected { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetSurfaceSelected)) , Some (f) => f (trackid , selected , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetSurfaceSolo (& self , trackid : * mut root :: MediaTrack , solo : bool , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetSurfaceSolo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetSurfaceSolo)) , Some (f) => f (trackid , solo , ignoresurf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_SetSurfaceVolume (& self , trackid : * mut root :: MediaTrack , volume : f64 , ignoresurf : * mut root :: IReaperControlSurface) { match self . pointers . CSurf_SetSurfaceVolume { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetSurfaceVolume)) , Some (f) => f (trackid , volume , ignoresurf) , } } pub fn CSurf_SetTrackListChange (& self) { match self . pointers . CSurf_SetTrackListChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_SetTrackListChange)) , Some (f) => f () , } } pub fn CSurf_TrackFromID (& self , idx : :: std :: os :: raw :: c_int , mcpView : bool) -> * mut root :: MediaTrack { match self . pointers . CSurf_TrackFromID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_TrackFromID)) , Some (f) => f (idx , mcpView) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CSurf_TrackToID (& self , track : * mut root :: MediaTrack , mcpView : bool) -> :: std :: os :: raw :: c_int { match self . pointers . CSurf_TrackToID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CSurf_TrackToID)) , Some (f) => f (track , mcpView) , } } pub fn DB2SLIDER (& self , x : f64) -> f64 { match self . pointers . DB2SLIDER { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DB2SLIDER)) , Some (f) => f (x) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteActionShortcut (& self , section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int , shortcutidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DeleteActionShortcut { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteActionShortcut)) , Some (f) => f (section , cmdID , shortcutidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteEnvelopePointEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , ptidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DeleteEnvelopePointEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteEnvelopePointEx)) , Some (f) => f (envelope , autoitem_idx , ptidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteEnvelopePointRange (& self , envelope : * mut root :: TrackEnvelope , time_start : f64 , time_end : f64) -> bool { match self . pointers . DeleteEnvelopePointRange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteEnvelopePointRange)) , Some (f) => f (envelope , time_start , time_end) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteEnvelopePointRangeEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , time_start : f64 , time_end : f64) -> bool { match self . pointers . DeleteEnvelopePointRangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteEnvelopePointRangeEx)) , Some (f) => f (envelope , autoitem_idx , time_start , time_end) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteExtState (& self , section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , persist : bool) { match self . pointers . DeleteExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteExtState)) , Some (f) => f (section , key , persist) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteProjectMarker (& self , proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool) -> bool { match self . pointers . DeleteProjectMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteProjectMarker)) , Some (f) => f (proj , markrgnindexnumber , isrgn) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteProjectMarkerByIndex (& self , proj : * mut root :: ReaProject , markrgnidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DeleteProjectMarkerByIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteProjectMarkerByIndex)) , Some (f) => f (proj , markrgnidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteTakeMarker (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DeleteTakeMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteTakeMarker)) , Some (f) => f (take , idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteTakeStretchMarkers (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , countInOptional : * const :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . DeleteTakeStretchMarkers { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteTakeStretchMarkers)) , Some (f) => f (take , idx , countInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteTempoTimeSigMarker (& self , project : * mut root :: ReaProject , markerindex : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DeleteTempoTimeSigMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteTempoTimeSigMarker)) , Some (f) => f (project , markerindex) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteTrack (& self , tr : * mut root :: MediaTrack) { match self . pointers . DeleteTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteTrack)) , Some (f) => f (tr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DeleteTrackMediaItem (& self , tr : * mut root :: MediaTrack , it : * mut root :: MediaItem) -> bool { match self . pointers . DeleteTrackMediaItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DeleteTrackMediaItem)) , Some (f) => f (tr , it) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DestroyAudioAccessor (& self , accessor : * mut root :: reaper_functions :: AudioAccessor) { match self . pointers . DestroyAudioAccessor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DestroyAudioAccessor)) , Some (f) => f (accessor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DestroyLocalOscHandler (& self , local_osc_handler : * mut :: std :: os :: raw :: c_void) { match self . pointers . DestroyLocalOscHandler { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DestroyLocalOscHandler)) , Some (f) => f (local_osc_handler) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DoActionShortcutDialog (& self , hwnd : root :: HWND , section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int , shortcutidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . DoActionShortcutDialog { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DoActionShortcutDialog)) , Some (f) => f (hwnd , section , cmdID , shortcutidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Dock_UpdateDockID (& self , ident_str : * const :: std :: os :: raw :: c_char , whichDock : :: std :: os :: raw :: c_int) { match self . pointers . Dock_UpdateDockID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Dock_UpdateDockID)) , Some (f) => f (ident_str , whichDock) , } } pub fn DockGetPosition (& self , whichDock : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . DockGetPosition { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockGetPosition)) , Some (f) => f (whichDock) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DockIsChildOfDock (& self , hwnd : root :: HWND , isFloatingDockerOut : * mut bool) -> :: std :: os :: raw :: c_int { match self . pointers . DockIsChildOfDock { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockIsChildOfDock)) , Some (f) => f (hwnd , isFloatingDockerOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DockWindowActivate (& self , hwnd : root :: HWND) { match self . pointers . DockWindowActivate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockWindowActivate)) , Some (f) => f (hwnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DockWindowAdd (& self , hwnd : root :: HWND , name : * const :: std :: os :: raw :: c_char , pos : :: std :: os :: raw :: c_int , allowShow : bool) { match self . pointers . DockWindowAdd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockWindowAdd)) , Some (f) => f (hwnd , name , pos , allowShow) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DockWindowAddEx (& self , hwnd : root :: HWND , name : * const :: std :: os :: raw :: c_char , identstr : * const :: std :: os :: raw :: c_char , allowShow : bool) { match self . pointers . DockWindowAddEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockWindowAddEx)) , Some (f) => f (hwnd , name , identstr , allowShow) , } } pub fn DockWindowRefresh (& self) { match self . pointers . DockWindowRefresh { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockWindowRefresh)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DockWindowRefreshForHWND (& self , hwnd : root :: HWND) { match self . pointers . DockWindowRefreshForHWND { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockWindowRefreshForHWND)) , Some (f) => f (hwnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DockWindowRemove (& self , hwnd : root :: HWND) { match self . pointers . DockWindowRemove { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DockWindowRemove)) , Some (f) => f (hwnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn DuplicateCustomizableMenu (& self , srcmenu : * mut :: std :: os :: raw :: c_void , destmenu : * mut :: std :: os :: raw :: c_void) -> bool { match self . pointers . DuplicateCustomizableMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (DuplicateCustomizableMenu)) , Some (f) => f (srcmenu , destmenu) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EditTempoTimeSigMarker (& self , project : * mut root :: ReaProject , markerindex : :: std :: os :: raw :: c_int) -> bool { match self . pointers . EditTempoTimeSigMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EditTempoTimeSigMarker)) , Some (f) => f (project , markerindex) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnsureNotCompletelyOffscreen (& self , rInOut : * mut root :: RECT) { match self . pointers . EnsureNotCompletelyOffscreen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnsureNotCompletelyOffscreen)) , Some (f) => f (rInOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumerateFiles (& self , path : * const :: std :: os :: raw :: c_char , fileindex : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . EnumerateFiles { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumerateFiles)) , Some (f) => f (path , fileindex) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumerateSubdirectories (& self , path : * const :: std :: os :: raw :: c_char , subdirindex : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . EnumerateSubdirectories { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumerateSubdirectories)) , Some (f) => f (path , subdirindex) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumPitchShiftModes (& self , mode : :: std :: os :: raw :: c_int , strOut : * mut * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . EnumPitchShiftModes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumPitchShiftModes)) , Some (f) => f (mode , strOut) , } } pub fn EnumPitchShiftSubModes (& self , mode : :: std :: os :: raw :: c_int , submode : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . EnumPitchShiftSubModes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumPitchShiftSubModes)) , Some (f) => f (mode , submode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumProjectMarkers (& self , idx : :: std :: os :: raw :: c_int , isrgnOut : * mut bool , posOut : * mut f64 , rgnendOut : * mut f64 , nameOut : * mut * const :: std :: os :: raw :: c_char , markrgnindexnumberOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . EnumProjectMarkers { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumProjectMarkers)) , Some (f) => f (idx , isrgnOut , posOut , rgnendOut , nameOut , markrgnindexnumberOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumProjectMarkers2 (& self , proj : * mut root :: ReaProject , idx : :: std :: os :: raw :: c_int , isrgnOut : * mut bool , posOut : * mut f64 , rgnendOut : * mut f64 , nameOut : * mut * const :: std :: os :: raw :: c_char , markrgnindexnumberOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . EnumProjectMarkers2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumProjectMarkers2)) , Some (f) => f (proj , idx , isrgnOut , posOut , rgnendOut , nameOut , markrgnindexnumberOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumProjectMarkers3 (& self , proj : * mut root :: ReaProject , idx : :: std :: os :: raw :: c_int , isrgnOut : * mut bool , posOut : * mut f64 , rgnendOut : * mut f64 , nameOut : * mut * const :: std :: os :: raw :: c_char , markrgnindexnumberOut : * mut :: std :: os :: raw :: c_int , colorOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . EnumProjectMarkers3 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumProjectMarkers3)) , Some (f) => f (proj , idx , isrgnOut , posOut , rgnendOut , nameOut , markrgnindexnumberOut , colorOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumProjects (& self , idx : :: std :: os :: raw :: c_int , projfnOutOptional : * mut :: std :: os :: raw :: c_char , projfnOutOptional_sz : :: std :: os :: raw :: c_int) -> * mut root :: ReaProject { match self . pointers . EnumProjects { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumProjects)) , Some (f) => f (idx , projfnOutOptional , projfnOutOptional_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumProjExtState (& self , proj : * mut root :: ReaProject , extname : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , keyOutOptional : * mut :: std :: os :: raw :: c_char , keyOutOptional_sz : :: std :: os :: raw :: c_int , valOutOptional : * mut :: std :: os :: raw :: c_char , valOutOptional_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . EnumProjExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumProjExtState)) , Some (f) => f (proj , extname , idx , keyOutOptional , keyOutOptional_sz , valOutOptional , valOutOptional_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumRegionRenderMatrix (& self , proj : * mut root :: ReaProject , regionindex : :: std :: os :: raw :: c_int , rendertrack : :: std :: os :: raw :: c_int) -> * mut root :: MediaTrack { match self . pointers . EnumRegionRenderMatrix { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumRegionRenderMatrix)) , Some (f) => f (proj , regionindex , rendertrack) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumTrackMIDIProgramNames (& self , track : :: std :: os :: raw :: c_int , programNumber : :: std :: os :: raw :: c_int , programName : * mut :: std :: os :: raw :: c_char , programName_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . EnumTrackMIDIProgramNames { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumTrackMIDIProgramNames)) , Some (f) => f (track , programNumber , programName , programName_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn EnumTrackMIDIProgramNamesEx (& self , proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , programNumber : :: std :: os :: raw :: c_int , programName : * mut :: std :: os :: raw :: c_char , programName_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . EnumTrackMIDIProgramNamesEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (EnumTrackMIDIProgramNamesEx)) , Some (f) => f (proj , track , programNumber , programName , programName_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Envelope_Evaluate (& self , envelope : * mut root :: TrackEnvelope , time : f64 , samplerate : f64 , samplesRequested : :: std :: os :: raw :: c_int , valueOut : * mut f64 , dVdSOut : * mut f64 , ddVdSOut : * mut f64 , dddVdSOut : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . Envelope_Evaluate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Envelope_Evaluate)) , Some (f) => f (envelope , time , samplerate , samplesRequested , valueOut , dVdSOut , ddVdSOut , dddVdSOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Envelope_FormatValue (& self , env : * mut root :: TrackEnvelope , value : f64 , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . Envelope_FormatValue { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Envelope_FormatValue)) , Some (f) => f (env , value , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Envelope_GetParentTake (& self , env : * mut root :: TrackEnvelope , indexOut : * mut :: std :: os :: raw :: c_int , index2Out : * mut :: std :: os :: raw :: c_int) -> * mut root :: MediaItem_Take { match self . pointers . Envelope_GetParentTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Envelope_GetParentTake)) , Some (f) => f (env , indexOut , index2Out) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Envelope_GetParentTrack (& self , env : * mut root :: TrackEnvelope , indexOut : * mut :: std :: os :: raw :: c_int , index2Out : * mut :: std :: os :: raw :: c_int) -> * mut root :: MediaTrack { match self . pointers . Envelope_GetParentTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Envelope_GetParentTrack)) , Some (f) => f (env , indexOut , index2Out) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Envelope_SortPoints (& self , envelope : * mut root :: TrackEnvelope) -> bool { match self . pointers . Envelope_SortPoints { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Envelope_SortPoints)) , Some (f) => f (envelope) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Envelope_SortPointsEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . Envelope_SortPointsEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Envelope_SortPointsEx)) , Some (f) => f (envelope , autoitem_idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ExecProcess (& self , cmdline : * const :: std :: os :: raw :: c_char , timeoutmsec : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . ExecProcess { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ExecProcess)) , Some (f) => f (cmdline , timeoutmsec) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn file_exists (& self , path : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . file_exists { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (file_exists)) , Some (f) => f (path) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn FindTempoTimeSigMarker (& self , project : * mut root :: ReaProject , time : f64) -> :: std :: os :: raw :: c_int { match self . pointers . FindTempoTimeSigMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (FindTempoTimeSigMarker)) , Some (f) => f (project , time) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn format_timestr (& self , tpos : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int) { match self . pointers . format_timestr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (format_timestr)) , Some (f) => f (tpos , buf , buf_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn format_timestr_len (& self , tpos : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , offset : f64 , modeoverride : :: std :: os :: raw :: c_int) { match self . pointers . format_timestr_len { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (format_timestr_len)) , Some (f) => f (tpos , buf , buf_sz , offset , modeoverride) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn format_timestr_pos (& self , tpos : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , modeoverride : :: std :: os :: raw :: c_int) { match self . pointers . format_timestr_pos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (format_timestr_pos)) , Some (f) => f (tpos , buf , buf_sz , modeoverride) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn FreeHeapPtr (& self , ptr : * mut :: std :: os :: raw :: c_void) { match self . pointers . FreeHeapPtr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (FreeHeapPtr)) , Some (f) => f (ptr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn genGuid (& self , g : * mut root :: GUID) { match self . pointers . genGuid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (genGuid)) , Some (f) => f (g) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn get_config_var (& self , name : * const :: std :: os :: raw :: c_char , szOut : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_void { match self . pointers . get_config_var { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (get_config_var)) , Some (f) => f (name , szOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn get_config_var_string (& self , name : * const :: std :: os :: raw :: c_char , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . get_config_var_string { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (get_config_var_string)) , Some (f) => f (name , bufOut , bufOut_sz) , } } pub fn get_ini_file (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . get_ini_file { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (get_ini_file)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn get_midi_config_var (& self , name : * const :: std :: os :: raw :: c_char , szOut : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_void { match self . pointers . get_midi_config_var { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (get_midi_config_var)) , Some (f) => f (name , szOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetActionShortcutDesc (& self , section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int , shortcutidx : :: std :: os :: raw :: c_int , descOut : * mut :: std :: os :: raw :: c_char , descOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetActionShortcutDesc { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetActionShortcutDesc)) , Some (f) => f (section , cmdID , shortcutidx , descOut , descOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetActiveTake (& self , item : * mut root :: MediaItem) -> * mut root :: MediaItem_Take { match self . pointers . GetActiveTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetActiveTake)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetAllProjectPlayStates (& self , ignoreProject : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . GetAllProjectPlayStates { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAllProjectPlayStates)) , Some (f) => f (ignoreProject) , } } pub fn GetAppVersion (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetAppVersion { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAppVersion)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetArmedCommand (& self , secOut : * mut :: std :: os :: raw :: c_char , secOut_sz : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetArmedCommand { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetArmedCommand)) , Some (f) => f (secOut , secOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetAudioAccessorEndTime (& self , accessor : * mut root :: reaper_functions :: AudioAccessor) -> f64 { match self . pointers . GetAudioAccessorEndTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAudioAccessorEndTime)) , Some (f) => f (accessor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetAudioAccessorHash (& self , accessor : * mut root :: reaper_functions :: AudioAccessor , hashNeed128 : * mut :: std :: os :: raw :: c_char) { match self . pointers . GetAudioAccessorHash { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAudioAccessorHash)) , Some (f) => f (accessor , hashNeed128) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetAudioAccessorSamples (& self , accessor : * mut root :: reaper_functions :: AudioAccessor , samplerate : :: std :: os :: raw :: c_int , numchannels : :: std :: os :: raw :: c_int , starttime_sec : f64 , numsamplesperchannel : :: std :: os :: raw :: c_int , samplebuffer : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . GetAudioAccessorSamples { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAudioAccessorSamples)) , Some (f) => f (accessor , samplerate , numchannels , starttime_sec , numsamplesperchannel , samplebuffer) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetAudioAccessorStartTime (& self , accessor : * mut root :: reaper_functions :: AudioAccessor) -> f64 { match self . pointers . GetAudioAccessorStartTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAudioAccessorStartTime)) , Some (f) => f (accessor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetAudioDeviceInfo (& self , attribute : * const :: std :: os :: raw :: c_char , descOut : * mut :: std :: os :: raw :: c_char , descOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetAudioDeviceInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetAudioDeviceInfo)) , Some (f) => f (attribute , descOut , descOut_sz) , } } pub fn GetColorTheme (& self , idx : :: std :: os :: raw :: c_int , defval : :: std :: os :: raw :: c_int) -> root :: INT_PTR { match self . pointers . GetColorTheme { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetColorTheme)) , Some (f) => f (idx , defval) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetColorThemeStruct (& self , szOut : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetColorThemeStruct { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetColorThemeStruct)) , Some (f) => f (szOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetConfigWantsDock (& self , ident_str : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . GetConfigWantsDock { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetConfigWantsDock)) , Some (f) => f (ident_str) , } } pub fn GetContextMenu (& self , idx : :: std :: os :: raw :: c_int) -> root :: HMENU { match self . pointers . GetContextMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetContextMenu)) , Some (f) => f (idx) , } } pub fn GetCurrentProjectInLoadSave (& self) -> * mut root :: ReaProject { match self . pointers . GetCurrentProjectInLoadSave { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCurrentProjectInLoadSave)) , Some (f) => f () , } } pub fn GetCursorContext (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetCursorContext { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCursorContext)) , Some (f) => f () , } } pub fn GetCursorContext2 (& self , want_last_valid : bool) -> :: std :: os :: raw :: c_int { match self . pointers . GetCursorContext2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCursorContext2)) , Some (f) => f (want_last_valid) , } } pub fn GetCursorPosition (& self) -> f64 { match self . pointers . GetCursorPosition { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCursorPosition)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetCursorPositionEx (& self , proj : * mut root :: ReaProject) -> f64 { match self . pointers . GetCursorPositionEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetCursorPositionEx)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDisplayedMediaItemColor (& self , item : * mut root :: MediaItem) -> :: std :: os :: raw :: c_int { match self . pointers . GetDisplayedMediaItemColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetDisplayedMediaItemColor)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetDisplayedMediaItemColor2 (& self , item : * mut root :: MediaItem , take : * mut root :: MediaItem_Take) -> :: std :: os :: raw :: c_int { match self . pointers . GetDisplayedMediaItemColor2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetDisplayedMediaItemColor2)) , Some (f) => f (item , take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopeInfo_Value (& self , env : * mut root :: TrackEnvelope , parmname : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . GetEnvelopeInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopeInfo_Value)) , Some (f) => f (env , parmname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopeName (& self , env : * mut root :: TrackEnvelope , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetEnvelopeName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopeName)) , Some (f) => f (env , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopePoint (& self , envelope : * mut root :: TrackEnvelope , ptidx : :: std :: os :: raw :: c_int , timeOut : * mut f64 , valueOut : * mut f64 , shapeOut : * mut :: std :: os :: raw :: c_int , tensionOut : * mut f64 , selectedOut : * mut bool) -> bool { match self . pointers . GetEnvelopePoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopePoint)) , Some (f) => f (envelope , ptidx , timeOut , valueOut , shapeOut , tensionOut , selectedOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopePointByTime (& self , envelope : * mut root :: TrackEnvelope , time : f64) -> :: std :: os :: raw :: c_int { match self . pointers . GetEnvelopePointByTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopePointByTime)) , Some (f) => f (envelope , time) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopePointByTimeEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , time : f64) -> :: std :: os :: raw :: c_int { match self . pointers . GetEnvelopePointByTimeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopePointByTimeEx)) , Some (f) => f (envelope , autoitem_idx , time) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopePointEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , ptidx : :: std :: os :: raw :: c_int , timeOut : * mut f64 , valueOut : * mut f64 , shapeOut : * mut :: std :: os :: raw :: c_int , tensionOut : * mut f64 , selectedOut : * mut bool) -> bool { match self . pointers . GetEnvelopePointEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopePointEx)) , Some (f) => f (envelope , autoitem_idx , ptidx , timeOut , valueOut , shapeOut , tensionOut , selectedOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopeScalingMode (& self , env : * mut root :: TrackEnvelope) -> :: std :: os :: raw :: c_int { match self . pointers . GetEnvelopeScalingMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopeScalingMode)) , Some (f) => f (env) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopeStateChunk (& self , env : * mut root :: TrackEnvelope , strNeedBig : * mut :: std :: os :: raw :: c_char , strNeedBig_sz : :: std :: os :: raw :: c_int , isundoOptional : bool) -> bool { match self . pointers . GetEnvelopeStateChunk { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopeStateChunk)) , Some (f) => f (env , strNeedBig , strNeedBig_sz , isundoOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetEnvelopeUIState (& self , env : * mut root :: TrackEnvelope) -> :: std :: os :: raw :: c_int { match self . pointers . GetEnvelopeUIState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetEnvelopeUIState)) , Some (f) => f (env) , } } pub fn GetExePath (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetExePath { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetExePath)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetExtState (& self , section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetExtState)) , Some (f) => f (section , key) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetFocusedFX (& self , tracknumberOut : * mut :: std :: os :: raw :: c_int , itemnumberOut : * mut :: std :: os :: raw :: c_int , fxnumberOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetFocusedFX { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetFocusedFX)) , Some (f) => f (tracknumberOut , itemnumberOut , fxnumberOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetFocusedFX2 (& self , tracknumberOut : * mut :: std :: os :: raw :: c_int , itemnumberOut : * mut :: std :: os :: raw :: c_int , fxnumberOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetFocusedFX2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetFocusedFX2)) , Some (f) => f (tracknumberOut , itemnumberOut , fxnumberOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetFreeDiskSpaceForRecordPath (& self , proj : * mut root :: ReaProject , pathidx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetFreeDiskSpaceForRecordPath { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetFreeDiskSpaceForRecordPath)) , Some (f) => f (proj , pathidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetFXEnvelope (& self , track : * mut root :: MediaTrack , fxindex : :: std :: os :: raw :: c_int , parameterindex : :: std :: os :: raw :: c_int , create : bool) -> * mut root :: TrackEnvelope { match self . pointers . GetFXEnvelope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetFXEnvelope)) , Some (f) => f (track , fxindex , parameterindex , create) , } } pub fn GetGlobalAutomationOverride (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetGlobalAutomationOverride { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetGlobalAutomationOverride)) , Some (f) => f () , } } pub fn GetHZoomLevel (& self) -> f64 { match self . pointers . GetHZoomLevel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetHZoomLevel)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetIconThemePointer (& self , name : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetIconThemePointer { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetIconThemePointer)) , Some (f) => f (name) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetIconThemePointerForDPI (& self , name : * const :: std :: os :: raw :: c_char , dpisc : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetIconThemePointerForDPI { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetIconThemePointerForDPI)) , Some (f) => f (name , dpisc) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetIconThemeStruct (& self , szOut : * mut :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetIconThemeStruct { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetIconThemeStruct)) , Some (f) => f (szOut) , } } pub fn GetInputChannelName (& self , channelIndex : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetInputChannelName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetInputChannelName)) , Some (f) => f (channelIndex) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetInputOutputLatency (& self , inputlatencyOut : * mut :: std :: os :: raw :: c_int , outputLatencyOut : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetInputOutputLatency { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetInputOutputLatency)) , Some (f) => f (inputlatencyOut , outputLatencyOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetItemEditingTime2 (& self , which_itemOut : * mut * mut root :: PCM_source , flagsOut : * mut :: std :: os :: raw :: c_int) -> f64 { match self . pointers . GetItemEditingTime2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetItemEditingTime2)) , Some (f) => f (which_itemOut , flagsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetItemFromPoint (& self , screen_x : :: std :: os :: raw :: c_int , screen_y : :: std :: os :: raw :: c_int , allow_locked : bool , takeOutOptional : * mut * mut root :: MediaItem_Take) -> * mut root :: MediaItem { match self . pointers . GetItemFromPoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetItemFromPoint)) , Some (f) => f (screen_x , screen_y , allow_locked , takeOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetItemProjectContext (& self , item : * mut root :: MediaItem) -> * mut root :: ReaProject { match self . pointers . GetItemProjectContext { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetItemProjectContext)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetItemStateChunk (& self , item : * mut root :: MediaItem , strNeedBig : * mut :: std :: os :: raw :: c_char , strNeedBig_sz : :: std :: os :: raw :: c_int , isundoOptional : bool) -> bool { match self . pointers . GetItemStateChunk { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetItemStateChunk)) , Some (f) => f (item , strNeedBig , strNeedBig_sz , isundoOptional) , } } pub fn GetLastColorThemeFile (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetLastColorThemeFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetLastColorThemeFile)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetLastMarkerAndCurRegion (& self , proj : * mut root :: ReaProject , time : f64 , markeridxOut : * mut :: std :: os :: raw :: c_int , regionidxOut : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetLastMarkerAndCurRegion { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetLastMarkerAndCurRegion)) , Some (f) => f (proj , time , markeridxOut , regionidxOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetLastTouchedFX (& self , tracknumberOut : * mut :: std :: os :: raw :: c_int , fxnumberOut : * mut :: std :: os :: raw :: c_int , paramnumberOut : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetLastTouchedFX { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetLastTouchedFX)) , Some (f) => f (tracknumberOut , fxnumberOut , paramnumberOut) , } } pub fn GetLastTouchedTrack (& self) -> * mut root :: MediaTrack { match self . pointers . GetLastTouchedTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetLastTouchedTrack)) , Some (f) => f () , } } pub fn GetMainHwnd (& self) -> root :: HWND { match self . pointers . GetMainHwnd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMainHwnd)) , Some (f) => f () , } } pub fn GetMasterMuteSoloFlags (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetMasterMuteSoloFlags { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMasterMuteSoloFlags)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMasterTrack (& self , proj : * mut root :: ReaProject) -> * mut root :: MediaTrack { match self . pointers . GetMasterTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMasterTrack)) , Some (f) => f (proj) , } } pub fn GetMasterTrackVisibility (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetMasterTrackVisibility { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMasterTrackVisibility)) , Some (f) => f () , } } pub fn GetMaxMidiInputs (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetMaxMidiInputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMaxMidiInputs)) , Some (f) => f () , } } pub fn GetMaxMidiOutputs (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetMaxMidiOutputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMaxMidiOutputs)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaFileMetadata (& self , mediaSource : * mut root :: PCM_source , identifier : * const :: std :: os :: raw :: c_char , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetMediaFileMetadata { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaFileMetadata)) , Some (f) => f (mediaSource , identifier , bufOutNeedBig , bufOutNeedBig_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItem (& self , proj : * mut root :: ReaProject , itemidx : :: std :: os :: raw :: c_int) -> * mut root :: MediaItem { match self . pointers . GetMediaItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItem)) , Some (f) => f (proj , itemidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItem_Track (& self , item : * mut root :: MediaItem) -> * mut root :: MediaTrack { match self . pointers . GetMediaItem_Track { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItem_Track)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemInfo_Value (& self , item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . GetMediaItemInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemInfo_Value)) , Some (f) => f (item , parmname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemNumTakes (& self , item : * mut root :: MediaItem) -> :: std :: os :: raw :: c_int { match self . pointers . GetMediaItemNumTakes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemNumTakes)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTake (& self , item : * mut root :: MediaItem , tk : :: std :: os :: raw :: c_int) -> * mut root :: MediaItem_Take { match self . pointers . GetMediaItemTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTake)) , Some (f) => f (item , tk) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTake_Item (& self , take : * mut root :: MediaItem_Take) -> * mut root :: MediaItem { match self . pointers . GetMediaItemTake_Item { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTake_Item)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTake_Peaks (& self , take : * mut root :: MediaItem_Take , peakrate : f64 , starttime : f64 , numchannels : :: std :: os :: raw :: c_int , numsamplesperchannel : :: std :: os :: raw :: c_int , want_extra_type : :: std :: os :: raw :: c_int , buf : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . GetMediaItemTake_Peaks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTake_Peaks)) , Some (f) => f (take , peakrate , starttime , numchannels , numsamplesperchannel , want_extra_type , buf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTake_Source (& self , take : * mut root :: MediaItem_Take) -> * mut root :: PCM_source { match self . pointers . GetMediaItemTake_Source { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTake_Source)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTake_Track (& self , take : * mut root :: MediaItem_Take) -> * mut root :: MediaTrack { match self . pointers . GetMediaItemTake_Track { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTake_Track)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTakeByGUID (& self , project : * mut root :: ReaProject , guid : * const root :: GUID) -> * mut root :: MediaItem_Take { match self . pointers . GetMediaItemTakeByGUID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTakeByGUID)) , Some (f) => f (project , guid) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTakeInfo_Value (& self , take : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . GetMediaItemTakeInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTakeInfo_Value)) , Some (f) => f (take , parmname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaItemTrack (& self , item : * mut root :: MediaItem) -> * mut root :: MediaTrack { match self . pointers . GetMediaItemTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaItemTrack)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaSourceFileName (& self , source : * mut root :: PCM_source , filenamebufOut : * mut :: std :: os :: raw :: c_char , filenamebufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetMediaSourceFileName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaSourceFileName)) , Some (f) => f (source , filenamebufOut , filenamebufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaSourceLength (& self , source : * mut root :: PCM_source , lengthIsQNOut : * mut bool) -> f64 { match self . pointers . GetMediaSourceLength { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaSourceLength)) , Some (f) => f (source , lengthIsQNOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaSourceNumChannels (& self , source : * mut root :: PCM_source) -> :: std :: os :: raw :: c_int { match self . pointers . GetMediaSourceNumChannels { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaSourceNumChannels)) , Some (f) => f (source) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaSourceParent (& self , src : * mut root :: PCM_source) -> * mut root :: PCM_source { match self . pointers . GetMediaSourceParent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaSourceParent)) , Some (f) => f (src) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaSourceSampleRate (& self , source : * mut root :: PCM_source) -> :: std :: os :: raw :: c_int { match self . pointers . GetMediaSourceSampleRate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaSourceSampleRate)) , Some (f) => f (source) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaSourceType (& self , source : * mut root :: PCM_source , typebufOut : * mut :: std :: os :: raw :: c_char , typebufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetMediaSourceType { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaSourceType)) , Some (f) => f (source , typebufOut , typebufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMediaTrackInfo_Value (& self , tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . GetMediaTrackInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMediaTrackInfo_Value)) , Some (f) => f (tr , parmname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMIDIInputName (& self , dev : :: std :: os :: raw :: c_int , nameout : * mut :: std :: os :: raw :: c_char , nameout_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetMIDIInputName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMIDIInputName)) , Some (f) => f (dev , nameout , nameout_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMIDIOutputName (& self , dev : :: std :: os :: raw :: c_int , nameout : * mut :: std :: os :: raw :: c_char , nameout_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetMIDIOutputName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMIDIOutputName)) , Some (f) => f (dev , nameout , nameout_sz) , } } pub fn GetMixerScroll (& self) -> * mut root :: MediaTrack { match self . pointers . GetMixerScroll { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMixerScroll)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMouseModifier (& self , context : * const :: std :: os :: raw :: c_char , modifier_flag : :: std :: os :: raw :: c_int , actionOut : * mut :: std :: os :: raw :: c_char , actionOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetMouseModifier { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMouseModifier)) , Some (f) => f (context , modifier_flag , actionOut , actionOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetMousePosition (& self , xOut : * mut :: std :: os :: raw :: c_int , yOut : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetMousePosition { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMousePosition)) , Some (f) => f (xOut , yOut) , } } pub fn GetNumAudioInputs (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetNumAudioInputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetNumAudioInputs)) , Some (f) => f () , } } pub fn GetNumAudioOutputs (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetNumAudioOutputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetNumAudioOutputs)) , Some (f) => f () , } } pub fn GetNumMIDIInputs (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetNumMIDIInputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetNumMIDIInputs)) , Some (f) => f () , } } pub fn GetNumMIDIOutputs (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetNumMIDIOutputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetNumMIDIOutputs)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetNumTakeMarkers (& self , take : * mut root :: MediaItem_Take) -> :: std :: os :: raw :: c_int { match self . pointers . GetNumTakeMarkers { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetNumTakeMarkers)) , Some (f) => f (take) , } } pub fn GetNumTracks (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetNumTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetNumTracks)) , Some (f) => f () , } } pub fn GetOS (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetOS { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetOS)) , Some (f) => f () , } } pub fn GetOutputChannelName (& self , channelIndex : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetOutputChannelName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetOutputChannelName)) , Some (f) => f (channelIndex) , } } pub fn GetOutputLatency (& self) -> f64 { match self . pointers . GetOutputLatency { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetOutputLatency)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetParentTrack (& self , track : * mut root :: MediaTrack) -> * mut root :: MediaTrack { match self . pointers . GetParentTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetParentTrack)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPeakFileName (& self , fn_ : * const :: std :: os :: raw :: c_char , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetPeakFileName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPeakFileName)) , Some (f) => f (fn_ , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPeakFileNameEx (& self , fn_ : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , forWrite : bool) { match self . pointers . GetPeakFileNameEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPeakFileNameEx)) , Some (f) => f (fn_ , buf , buf_sz , forWrite) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPeakFileNameEx2 (& self , fn_ : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , forWrite : bool , peaksfileextension : * const :: std :: os :: raw :: c_char) { match self . pointers . GetPeakFileNameEx2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPeakFileNameEx2)) , Some (f) => f (fn_ , buf , buf_sz , forWrite , peaksfileextension) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPeaksBitmap (& self , pks : * mut root :: PCM_source_peaktransfer_t , maxamp : f64 , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , bmp : * mut root :: reaper_functions :: LICE_IBitmap) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetPeaksBitmap { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPeaksBitmap)) , Some (f) => f (pks , maxamp , w , h , bmp) , } } pub fn GetPlayPosition (& self) -> f64 { match self . pointers . GetPlayPosition { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPlayPosition)) , Some (f) => f () , } } pub fn GetPlayPosition2 (& self) -> f64 { match self . pointers . GetPlayPosition2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPlayPosition2)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPlayPosition2Ex (& self , proj : * mut root :: ReaProject) -> f64 { match self . pointers . GetPlayPosition2Ex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPlayPosition2Ex)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPlayPositionEx (& self , proj : * mut root :: ReaProject) -> f64 { match self . pointers . GetPlayPositionEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPlayPositionEx)) , Some (f) => f (proj) , } } pub fn GetPlayState (& self) -> :: std :: os :: raw :: c_int { match self . pointers . GetPlayState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPlayState)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPlayStateEx (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . GetPlayStateEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPlayStateEx)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPreferredDiskReadMode (& self , mode : * mut :: std :: os :: raw :: c_int , nb : * mut :: std :: os :: raw :: c_int , bs : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetPreferredDiskReadMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPreferredDiskReadMode)) , Some (f) => f (mode , nb , bs) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPreferredDiskReadModePeak (& self , mode : * mut :: std :: os :: raw :: c_int , nb : * mut :: std :: os :: raw :: c_int , bs : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetPreferredDiskReadModePeak { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPreferredDiskReadModePeak)) , Some (f) => f (mode , nb , bs) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetPreferredDiskWriteMode (& self , mode : * mut :: std :: os :: raw :: c_int , nb : * mut :: std :: os :: raw :: c_int , bs : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetPreferredDiskWriteMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetPreferredDiskWriteMode)) , Some (f) => f (mode , nb , bs) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectLength (& self , proj : * mut root :: ReaProject) -> f64 { match self . pointers . GetProjectLength { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectLength)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectName (& self , proj : * mut root :: ReaProject , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetProjectName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectName)) , Some (f) => f (proj , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectPath (& self , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetProjectPath { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectPath)) , Some (f) => f (bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectPathEx (& self , proj : * mut root :: ReaProject , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetProjectPathEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectPathEx)) , Some (f) => f (proj , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectStateChangeCount (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . GetProjectStateChangeCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectStateChangeCount)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectTimeOffset (& self , proj : * mut root :: ReaProject , rndframe : bool) -> f64 { match self . pointers . GetProjectTimeOffset { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectTimeOffset)) , Some (f) => f (proj , rndframe) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectTimeSignature (& self , bpmOut : * mut f64 , bpiOut : * mut f64) { match self . pointers . GetProjectTimeSignature { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectTimeSignature)) , Some (f) => f (bpmOut , bpiOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjectTimeSignature2 (& self , proj : * mut root :: ReaProject , bpmOut : * mut f64 , bpiOut : * mut f64) { match self . pointers . GetProjectTimeSignature2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjectTimeSignature2)) , Some (f) => f (proj , bpmOut , bpiOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetProjExtState (& self , proj : * mut root :: ReaProject , extname : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , valOutNeedBig : * mut :: std :: os :: raw :: c_char , valOutNeedBig_sz : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetProjExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetProjExtState)) , Some (f) => f (proj , extname , key , valOutNeedBig , valOutNeedBig_sz) , } } pub fn GetResourcePath (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetResourcePath { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetResourcePath)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSelectedEnvelope (& self , proj : * mut root :: ReaProject) -> * mut root :: TrackEnvelope { match self . pointers . GetSelectedEnvelope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSelectedEnvelope)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSelectedMediaItem (& self , proj : * mut root :: ReaProject , selitem : :: std :: os :: raw :: c_int) -> * mut root :: MediaItem { match self . pointers . GetSelectedMediaItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSelectedMediaItem)) , Some (f) => f (proj , selitem) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSelectedTrack (& self , proj : * mut root :: ReaProject , seltrackidx : :: std :: os :: raw :: c_int) -> * mut root :: MediaTrack { match self . pointers . GetSelectedTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSelectedTrack)) , Some (f) => f (proj , seltrackidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSelectedTrack2 (& self , proj : * mut root :: ReaProject , seltrackidx : :: std :: os :: raw :: c_int , wantmaster : bool) -> * mut root :: MediaTrack { match self . pointers . GetSelectedTrack2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSelectedTrack2)) , Some (f) => f (proj , seltrackidx , wantmaster) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSelectedTrackEnvelope (& self , proj : * mut root :: ReaProject) -> * mut root :: TrackEnvelope { match self . pointers . GetSelectedTrackEnvelope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSelectedTrackEnvelope)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSet_ArrangeView2 (& self , proj : * mut root :: ReaProject , isSet : bool , screen_x_start : :: std :: os :: raw :: c_int , screen_x_end : :: std :: os :: raw :: c_int , start_timeInOut : * mut f64 , end_timeInOut : * mut f64) { match self . pointers . GetSet_ArrangeView2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSet_ArrangeView2)) , Some (f) => f (proj , isSet , screen_x_start , screen_x_end , start_timeInOut , end_timeInOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSet_LoopTimeRange (& self , isSet : bool , isLoop : bool , startOut : * mut f64 , endOut : * mut f64 , allowautoseek : bool) { match self . pointers . GetSet_LoopTimeRange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSet_LoopTimeRange)) , Some (f) => f (isSet , isLoop , startOut , endOut , allowautoseek) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSet_LoopTimeRange2 (& self , proj : * mut root :: ReaProject , isSet : bool , isLoop : bool , startOut : * mut f64 , endOut : * mut f64 , allowautoseek : bool) { match self . pointers . GetSet_LoopTimeRange2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSet_LoopTimeRange2)) , Some (f) => f (proj , isSet , isLoop , startOut , endOut , allowautoseek) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetAutomationItemInfo (& self , env : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , desc : * const :: std :: os :: raw :: c_char , value : f64 , is_set : bool) -> f64 { match self . pointers . GetSetAutomationItemInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetAutomationItemInfo)) , Some (f) => f (env , autoitem_idx , desc , value , is_set) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetAutomationItemInfo_String (& self , env : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , desc : * const :: std :: os :: raw :: c_char , valuestrNeedBig : * mut :: std :: os :: raw :: c_char , is_set : bool) -> bool { match self . pointers . GetSetAutomationItemInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetAutomationItemInfo_String)) , Some (f) => f (env , autoitem_idx , desc , valuestrNeedBig , is_set) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetEnvelopeInfo_String (& self , env : * mut root :: TrackEnvelope , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool) -> bool { match self . pointers . GetSetEnvelopeInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetEnvelopeInfo_String)) , Some (f) => f (env , parmname , stringNeedBig , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetEnvelopeState (& self , env : * mut root :: TrackEnvelope , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetSetEnvelopeState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetEnvelopeState)) , Some (f) => f (env , str , str_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetEnvelopeState2 (& self , env : * mut root :: TrackEnvelope , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int , isundo : bool) -> bool { match self . pointers . GetSetEnvelopeState2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetEnvelopeState2)) , Some (f) => f (env , str , str_sz , isundo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetItemState (& self , item : * mut root :: MediaItem , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetSetItemState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetItemState)) , Some (f) => f (item , str , str_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetItemState2 (& self , item : * mut root :: MediaItem , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int , isundo : bool) -> bool { match self . pointers . GetSetItemState2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetItemState2)) , Some (f) => f (item , str , str_sz , isundo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetMediaItemInfo (& self , item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetSetMediaItemInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetMediaItemInfo)) , Some (f) => f (item , parmname , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetMediaItemInfo_String (& self , item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool) -> bool { match self . pointers . GetSetMediaItemInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetMediaItemInfo_String)) , Some (f) => f (item , parmname , stringNeedBig , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetMediaItemTakeInfo (& self , tk : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetSetMediaItemTakeInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetMediaItemTakeInfo)) , Some (f) => f (tk , parmname , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetMediaItemTakeInfo_String (& self , tk : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool) -> bool { match self . pointers . GetSetMediaItemTakeInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetMediaItemTakeInfo_String)) , Some (f) => f (tk , parmname , stringNeedBig , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetMediaTrackInfo (& self , tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetSetMediaTrackInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetMediaTrackInfo)) , Some (f) => f (tr , parmname , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetMediaTrackInfo_String (& self , tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool) -> bool { match self . pointers . GetSetMediaTrackInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetMediaTrackInfo_String)) , Some (f) => f (tr , parmname , stringNeedBig , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetObjectState (& self , obj : * mut :: std :: os :: raw :: c_void , str : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_char { match self . pointers . GetSetObjectState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetObjectState)) , Some (f) => f (obj , str) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetObjectState2 (& self , obj : * mut :: std :: os :: raw :: c_void , str : * const :: std :: os :: raw :: c_char , isundo : bool) -> * mut :: std :: os :: raw :: c_char { match self . pointers . GetSetObjectState2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetObjectState2)) , Some (f) => f (obj , str , isundo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetProjectAuthor (& self , proj : * mut root :: ReaProject , set : bool , author : * mut :: std :: os :: raw :: c_char , author_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetSetProjectAuthor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetProjectAuthor)) , Some (f) => f (proj , set , author , author_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetProjectGrid (& self , project : * mut root :: ReaProject , set : bool , divisionInOutOptional : * mut f64 , swingmodeInOutOptional : * mut :: std :: os :: raw :: c_int , swingamtInOutOptional : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . GetSetProjectGrid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetProjectGrid)) , Some (f) => f (project , set , divisionInOutOptional , swingmodeInOutOptional , swingamtInOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetProjectInfo (& self , project : * mut root :: ReaProject , desc : * const :: std :: os :: raw :: c_char , value : f64 , is_set : bool) -> f64 { match self . pointers . GetSetProjectInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetProjectInfo)) , Some (f) => f (project , desc , value , is_set) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetProjectInfo_String (& self , project : * mut root :: ReaProject , desc : * const :: std :: os :: raw :: c_char , valuestrNeedBig : * mut :: std :: os :: raw :: c_char , is_set : bool) -> bool { match self . pointers . GetSetProjectInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetProjectInfo_String)) , Some (f) => f (project , desc , valuestrNeedBig , is_set) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetProjectNotes (& self , proj : * mut root :: ReaProject , set : bool , notesNeedBig : * mut :: std :: os :: raw :: c_char , notesNeedBig_sz : :: std :: os :: raw :: c_int) { match self . pointers . GetSetProjectNotes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetProjectNotes)) , Some (f) => f (proj , set , notesNeedBig , notesNeedBig_sz) , } } pub fn GetSetRepeat (& self , val : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetSetRepeat { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetRepeat)) , Some (f) => f (val) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetRepeatEx (& self , proj : * mut root :: ReaProject , val : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetSetRepeatEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetRepeatEx)) , Some (f) => f (proj , val) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackGroupMembership (& self , tr : * mut root :: MediaTrack , groupname : * const :: std :: os :: raw :: c_char , setmask : :: std :: os :: raw :: c_uint , setvalue : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint { match self . pointers . GetSetTrackGroupMembership { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackGroupMembership)) , Some (f) => f (tr , groupname , setmask , setvalue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackGroupMembershipHigh (& self , tr : * mut root :: MediaTrack , groupname : * const :: std :: os :: raw :: c_char , setmask : :: std :: os :: raw :: c_uint , setvalue : :: std :: os :: raw :: c_uint) -> :: std :: os :: raw :: c_uint { match self . pointers . GetSetTrackGroupMembershipHigh { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackGroupMembershipHigh)) , Some (f) => f (tr , groupname , setmask , setvalue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackMIDISupportFile (& self , proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , which : :: std :: os :: raw :: c_int , filename : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetSetTrackMIDISupportFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackMIDISupportFile)) , Some (f) => f (proj , track , which , filename) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackSendInfo (& self , tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void { match self . pointers . GetSetTrackSendInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackSendInfo)) , Some (f) => f (tr , category , sendidx , parmname , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackSendInfo_String (& self , tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool) -> bool { match self . pointers . GetSetTrackSendInfo_String { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackSendInfo_String)) , Some (f) => f (tr , category , sendidx , parmname , stringNeedBig , setNewValue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackState (& self , track : * mut root :: MediaTrack , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetSetTrackState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackState)) , Some (f) => f (track , str , str_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSetTrackState2 (& self , track : * mut root :: MediaTrack , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int , isundo : bool) -> bool { match self . pointers . GetSetTrackState2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSetTrackState2)) , Some (f) => f (track , str , str_sz , isundo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetSubProjectFromSource (& self , src : * mut root :: PCM_source) -> * mut root :: ReaProject { match self . pointers . GetSubProjectFromSource { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetSubProjectFromSource)) , Some (f) => f (src) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTake (& self , item : * mut root :: MediaItem , takeidx : :: std :: os :: raw :: c_int) -> * mut root :: MediaItem_Take { match self . pointers . GetTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTake)) , Some (f) => f (item , takeidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeEnvelope (& self , take : * mut root :: MediaItem_Take , envidx : :: std :: os :: raw :: c_int) -> * mut root :: TrackEnvelope { match self . pointers . GetTakeEnvelope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeEnvelope)) , Some (f) => f (take , envidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeEnvelopeByName (& self , take : * mut root :: MediaItem_Take , envname : * const :: std :: os :: raw :: c_char) -> * mut root :: TrackEnvelope { match self . pointers . GetTakeEnvelopeByName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeEnvelopeByName)) , Some (f) => f (take , envname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeMarker (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , nameOut : * mut :: std :: os :: raw :: c_char , nameOut_sz : :: std :: os :: raw :: c_int , colorOutOptional : * mut :: std :: os :: raw :: c_int) -> f64 { match self . pointers . GetTakeMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeMarker)) , Some (f) => f (take , idx , nameOut , nameOut_sz , colorOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeName (& self , take : * mut root :: MediaItem_Take) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetTakeName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeName)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeNumStretchMarkers (& self , take : * mut root :: MediaItem_Take) -> :: std :: os :: raw :: c_int { match self . pointers . GetTakeNumStretchMarkers { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeNumStretchMarkers)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeStretchMarker (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , posOut : * mut f64 , srcposOutOptional : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . GetTakeStretchMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeStretchMarker)) , Some (f) => f (take , idx , posOut , srcposOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTakeStretchMarkerSlope (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . GetTakeStretchMarkerSlope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTakeStretchMarkerSlope)) , Some (f) => f (take , idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTCPFXParm (& self , project : * mut root :: ReaProject , track : * mut root :: MediaTrack , index : :: std :: os :: raw :: c_int , fxindexOut : * mut :: std :: os :: raw :: c_int , parmidxOut : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetTCPFXParm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTCPFXParm)) , Some (f) => f (project , track , index , fxindexOut , parmidxOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTempoMatchPlayRate (& self , source : * mut root :: PCM_source , srcscale : f64 , position : f64 , mult : f64 , rateOut : * mut f64 , targetlenOut : * mut f64) -> bool { match self . pointers . GetTempoMatchPlayRate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTempoMatchPlayRate)) , Some (f) => f (source , srcscale , position , mult , rateOut , targetlenOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTempoTimeSigMarker (& self , proj : * mut root :: ReaProject , ptidx : :: std :: os :: raw :: c_int , timeposOut : * mut f64 , measureposOut : * mut :: std :: os :: raw :: c_int , beatposOut : * mut f64 , bpmOut : * mut f64 , timesig_numOut : * mut :: std :: os :: raw :: c_int , timesig_denomOut : * mut :: std :: os :: raw :: c_int , lineartempoOut : * mut bool) -> bool { match self . pointers . GetTempoTimeSigMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTempoTimeSigMarker)) , Some (f) => f (proj , ptidx , timeposOut , measureposOut , beatposOut , bpmOut , timesig_numOut , timesig_denomOut , lineartempoOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetThemeColor (& self , ini_key : * const :: std :: os :: raw :: c_char , flagsOptional : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetThemeColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetThemeColor)) , Some (f) => f (ini_key , flagsOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetThingFromPoint (& self , screen_x : :: std :: os :: raw :: c_int , screen_y : :: std :: os :: raw :: c_int , infoOut : * mut :: std :: os :: raw :: c_char , infoOut_sz : :: std :: os :: raw :: c_int) -> * mut root :: MediaTrack { match self . pointers . GetThingFromPoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetThingFromPoint)) , Some (f) => f (screen_x , screen_y , infoOut , infoOut_sz) , } } pub fn GetToggleCommandState (& self , command_id : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetToggleCommandState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetToggleCommandState)) , Some (f) => f (command_id) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetToggleCommandState2 (& self , section : * mut root :: KbdSectionInfo , command_id : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetToggleCommandState2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetToggleCommandState2)) , Some (f) => f (section , command_id) , } } pub fn GetToggleCommandStateEx (& self , section_id : :: std :: os :: raw :: c_int , command_id : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetToggleCommandStateEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetToggleCommandStateEx)) , Some (f) => f (section_id , command_id) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetToggleCommandStateThroughHooks (& self , section : * mut root :: KbdSectionInfo , command_id : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetToggleCommandStateThroughHooks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetToggleCommandStateThroughHooks)) , Some (f) => f (section , command_id) , } } pub fn GetTooltipWindow (& self) -> root :: HWND { match self . pointers . GetTooltipWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTooltipWindow)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrack (& self , proj : * mut root :: ReaProject , trackidx : :: std :: os :: raw :: c_int) -> * mut root :: MediaTrack { match self . pointers . GetTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrack)) , Some (f) => f (proj , trackidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackAutomationMode (& self , tr : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . GetTrackAutomationMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackAutomationMode)) , Some (f) => f (tr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackColor (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . GetTrackColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackColor)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackDepth (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . GetTrackDepth { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackDepth)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackEnvelope (& self , track : * mut root :: MediaTrack , envidx : :: std :: os :: raw :: c_int) -> * mut root :: TrackEnvelope { match self . pointers . GetTrackEnvelope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackEnvelope)) , Some (f) => f (track , envidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackEnvelopeByChunkName (& self , tr : * mut root :: MediaTrack , cfgchunkname_or_guid : * const :: std :: os :: raw :: c_char) -> * mut root :: TrackEnvelope { match self . pointers . GetTrackEnvelopeByChunkName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackEnvelopeByChunkName)) , Some (f) => f (tr , cfgchunkname_or_guid) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackEnvelopeByName (& self , track : * mut root :: MediaTrack , envname : * const :: std :: os :: raw :: c_char) -> * mut root :: TrackEnvelope { match self . pointers . GetTrackEnvelopeByName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackEnvelopeByName)) , Some (f) => f (track , envname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackFromPoint (& self , screen_x : :: std :: os :: raw :: c_int , screen_y : :: std :: os :: raw :: c_int , infoOutOptional : * mut :: std :: os :: raw :: c_int) -> * mut root :: MediaTrack { match self . pointers . GetTrackFromPoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackFromPoint)) , Some (f) => f (screen_x , screen_y , infoOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackGUID (& self , tr : * mut root :: MediaTrack) -> * mut root :: GUID { match self . pointers . GetTrackGUID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackGUID)) , Some (f) => f (tr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackInfo (& self , track : root :: INT_PTR , flags : * mut :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetTrackInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackInfo)) , Some (f) => f (track , flags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackMediaItem (& self , tr : * mut root :: MediaTrack , itemidx : :: std :: os :: raw :: c_int) -> * mut root :: MediaItem { match self . pointers . GetTrackMediaItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackMediaItem)) , Some (f) => f (tr , itemidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackMIDILyrics (& self , track : * mut root :: MediaTrack , flag : :: std :: os :: raw :: c_int , bufOutWantNeedBig : * mut :: std :: os :: raw :: c_char , bufOutWantNeedBig_sz : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetTrackMIDILyrics { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackMIDILyrics)) , Some (f) => f (track , flag , bufOutWantNeedBig , bufOutWantNeedBig_sz) , } } pub fn GetTrackMIDINoteName (& self , track : :: std :: os :: raw :: c_int , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetTrackMIDINoteName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackMIDINoteName)) , Some (f) => f (track , pitch , chan) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackMIDINoteNameEx (& self , proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetTrackMIDINoteNameEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackMIDINoteNameEx)) , Some (f) => f (proj , track , pitch , chan) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackMIDINoteRange (& self , proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , note_loOut : * mut :: std :: os :: raw :: c_int , note_hiOut : * mut :: std :: os :: raw :: c_int) { match self . pointers . GetTrackMIDINoteRange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackMIDINoteRange)) , Some (f) => f (proj , track , note_loOut , note_hiOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackName (& self , track : * mut root :: MediaTrack , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetTrackName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackName)) , Some (f) => f (track , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackNumMediaItems (& self , tr : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . GetTrackNumMediaItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackNumMediaItems)) , Some (f) => f (tr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackNumSends (& self , tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GetTrackNumSends { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackNumSends)) , Some (f) => f (tr , category) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackReceiveName (& self , track : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetTrackReceiveName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackReceiveName)) , Some (f) => f (track , recv_index , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackReceiveUIMute (& self , track : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , muteOut : * mut bool) -> bool { match self . pointers . GetTrackReceiveUIMute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackReceiveUIMute)) , Some (f) => f (track , recv_index , muteOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackReceiveUIVolPan (& self , track : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , volumeOut : * mut f64 , panOut : * mut f64) -> bool { match self . pointers . GetTrackReceiveUIVolPan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackReceiveUIVolPan)) , Some (f) => f (track , recv_index , volumeOut , panOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackSendInfo_Value (& self , tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . GetTrackSendInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackSendInfo_Value)) , Some (f) => f (tr , category , sendidx , parmname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackSendName (& self , track : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetTrackSendName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackSendName)) , Some (f) => f (track , send_index , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackSendUIMute (& self , track : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , muteOut : * mut bool) -> bool { match self . pointers . GetTrackSendUIMute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackSendUIMute)) , Some (f) => f (track , send_index , muteOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackSendUIVolPan (& self , track : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , volumeOut : * mut f64 , panOut : * mut f64) -> bool { match self . pointers . GetTrackSendUIVolPan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackSendUIVolPan)) , Some (f) => f (track , send_index , volumeOut , panOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackState (& self , track : * mut root :: MediaTrack , flagsOut : * mut :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . GetTrackState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackState)) , Some (f) => f (track , flagsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackStateChunk (& self , track : * mut root :: MediaTrack , strNeedBig : * mut :: std :: os :: raw :: c_char , strNeedBig_sz : :: std :: os :: raw :: c_int , isundoOptional : bool) -> bool { match self . pointers . GetTrackStateChunk { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackStateChunk)) , Some (f) => f (track , strNeedBig , strNeedBig_sz , isundoOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackUIMute (& self , track : * mut root :: MediaTrack , muteOut : * mut bool) -> bool { match self . pointers . GetTrackUIMute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackUIMute)) , Some (f) => f (track , muteOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackUIPan (& self , track : * mut root :: MediaTrack , pan1Out : * mut f64 , pan2Out : * mut f64 , panmodeOut : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetTrackUIPan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackUIPan)) , Some (f) => f (track , pan1Out , pan2Out , panmodeOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetTrackUIVolPan (& self , track : * mut root :: MediaTrack , volumeOut : * mut f64 , panOut : * mut f64) -> bool { match self . pointers . GetTrackUIVolPan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetTrackUIVolPan)) , Some (f) => f (track , volumeOut , panOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetUnderrunTime (& self , audio_xrunOut : * mut :: std :: os :: raw :: c_uint , media_xrunOut : * mut :: std :: os :: raw :: c_uint , curtimeOut : * mut :: std :: os :: raw :: c_uint) { match self . pointers . GetUnderrunTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetUnderrunTime)) , Some (f) => f (audio_xrunOut , media_xrunOut , curtimeOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetUserFileNameForRead (& self , filenameNeed4096 : * mut :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char , defext : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . GetUserFileNameForRead { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetUserFileNameForRead)) , Some (f) => f (filenameNeed4096 , title , defext) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GetUserInputs (& self , title : * const :: std :: os :: raw :: c_char , num_inputs : :: std :: os :: raw :: c_int , captions_csv : * const :: std :: os :: raw :: c_char , retvals_csv : * mut :: std :: os :: raw :: c_char , retvals_csv_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . GetUserInputs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetUserInputs)) , Some (f) => f (title , num_inputs , captions_csv , retvals_csv , retvals_csv_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GoToMarker (& self , proj : * mut root :: ReaProject , marker_index : :: std :: os :: raw :: c_int , use_timeline_order : bool) { match self . pointers . GoToMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GoToMarker)) , Some (f) => f (proj , marker_index , use_timeline_order) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GoToRegion (& self , proj : * mut root :: ReaProject , region_index : :: std :: os :: raw :: c_int , use_timeline_order : bool) { match self . pointers . GoToRegion { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GoToRegion)) , Some (f) => f (proj , region_index , use_timeline_order) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn GR_SelectColor (& self , hwnd : root :: HWND , colorOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GR_SelectColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GR_SelectColor)) , Some (f) => f (hwnd , colorOut) , } } pub fn GSC_mainwnd (& self , t : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . GSC_mainwnd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GSC_mainwnd)) , Some (f) => f (t) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn guidToString (& self , g : * const root :: GUID , destNeed64 : * mut :: std :: os :: raw :: c_char) { match self . pointers . guidToString { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (guidToString)) , Some (f) => f (g , destNeed64) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn HasExtState (& self , section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . HasExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (HasExtState)) , Some (f) => f (section , key) , } } pub fn HasTrackMIDIPrograms (& self , track : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . HasTrackMIDIPrograms { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (HasTrackMIDIPrograms)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn HasTrackMIDIProgramsEx (& self , proj : * mut root :: ReaProject , track : * mut root :: MediaTrack) -> * const :: std :: os :: raw :: c_char { match self . pointers . HasTrackMIDIProgramsEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (HasTrackMIDIProgramsEx)) , Some (f) => f (proj , track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Help_Set (& self , helpstring : * const :: std :: os :: raw :: c_char , is_temporary_help : bool) { match self . pointers . Help_Set { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Help_Set)) , Some (f) => f (helpstring , is_temporary_help) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn HiresPeaksFromSource (& self , src : * mut root :: PCM_source , block : * mut root :: PCM_source_peaktransfer_t) { match self . pointers . HiresPeaksFromSource { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (HiresPeaksFromSource)) , Some (f) => f (src , block) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn image_resolve_fn (& self , in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int) { match self . pointers . image_resolve_fn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (image_resolve_fn)) , Some (f) => f (in_ , out , out_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InsertAutomationItem (& self , env : * mut root :: TrackEnvelope , pool_id : :: std :: os :: raw :: c_int , position : f64 , length : f64) -> :: std :: os :: raw :: c_int { match self . pointers . InsertAutomationItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertAutomationItem)) , Some (f) => f (env , pool_id , position , length) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InsertEnvelopePoint (& self , envelope : * mut root :: TrackEnvelope , time : f64 , value : f64 , shape : :: std :: os :: raw :: c_int , tension : f64 , selected : bool , noSortInOptional : * mut bool) -> bool { match self . pointers . InsertEnvelopePoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertEnvelopePoint)) , Some (f) => f (envelope , time , value , shape , tension , selected , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InsertEnvelopePointEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , time : f64 , value : f64 , shape : :: std :: os :: raw :: c_int , tension : f64 , selected : bool , noSortInOptional : * mut bool) -> bool { match self . pointers . InsertEnvelopePointEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertEnvelopePointEx)) , Some (f) => f (envelope , autoitem_idx , time , value , shape , tension , selected , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InsertMedia (& self , file : * const :: std :: os :: raw :: c_char , mode : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . InsertMedia { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertMedia)) , Some (f) => f (file , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InsertMediaSection (& self , file : * const :: std :: os :: raw :: c_char , mode : :: std :: os :: raw :: c_int , startpct : f64 , endpct : f64 , pitchshift : f64) -> :: std :: os :: raw :: c_int { match self . pointers . InsertMediaSection { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertMediaSection)) , Some (f) => f (file , mode , startpct , endpct , pitchshift) , } } pub fn InsertTrackAtIndex (& self , idx : :: std :: os :: raw :: c_int , wantDefaults : bool) { match self . pointers . InsertTrackAtIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InsertTrackAtIndex)) , Some (f) => f (idx , wantDefaults) , } } pub fn IsInRealTimeAudio (& self) -> :: std :: os :: raw :: c_int { match self . pointers . IsInRealTimeAudio { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsInRealTimeAudio)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsItemTakeActiveForPlayback (& self , item : * mut root :: MediaItem , take : * mut root :: MediaItem_Take) -> bool { match self . pointers . IsItemTakeActiveForPlayback { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsItemTakeActiveForPlayback)) , Some (f) => f (item , take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsMediaExtension (& self , ext : * const :: std :: os :: raw :: c_char , wantOthers : bool) -> bool { match self . pointers . IsMediaExtension { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsMediaExtension)) , Some (f) => f (ext , wantOthers) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsMediaItemSelected (& self , item : * mut root :: MediaItem) -> bool { match self . pointers . IsMediaItemSelected { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsMediaItemSelected)) , Some (f) => f (item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsProjectDirty (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . IsProjectDirty { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsProjectDirty)) , Some (f) => f (proj) , } } pub fn IsREAPER (& self) -> bool { match self . pointers . IsREAPER { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsREAPER)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsTrackSelected (& self , track : * mut root :: MediaTrack) -> bool { match self . pointers . IsTrackSelected { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsTrackSelected)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn IsTrackVisible (& self , track : * mut root :: MediaTrack , mixer : bool) -> bool { match self . pointers . IsTrackVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (IsTrackVisible)) , Some (f) => f (track , mixer) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_create (& self , guid : * const root :: GUID) -> * mut root :: reaper_functions :: joystick_device { match self . pointers . joystick_create { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_create)) , Some (f) => f (guid) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_destroy (& self , device : * mut root :: reaper_functions :: joystick_device) { match self . pointers . joystick_destroy { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_destroy)) , Some (f) => f (device) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_enum (& self , index : :: std :: os :: raw :: c_int , namestrOutOptional : * mut * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char { match self . pointers . joystick_enum { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_enum)) , Some (f) => f (index , namestrOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_getaxis (& self , dev : * mut root :: reaper_functions :: joystick_device , axis : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . joystick_getaxis { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_getaxis)) , Some (f) => f (dev , axis) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_getbuttonmask (& self , dev : * mut root :: reaper_functions :: joystick_device) -> :: std :: os :: raw :: c_uint { match self . pointers . joystick_getbuttonmask { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_getbuttonmask)) , Some (f) => f (dev) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_getinfo (& self , dev : * mut root :: reaper_functions :: joystick_device , axesOutOptional : * mut :: std :: os :: raw :: c_int , povsOutOptional : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . joystick_getinfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_getinfo)) , Some (f) => f (dev , axesOutOptional , povsOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_getpov (& self , dev : * mut root :: reaper_functions :: joystick_device , pov : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . joystick_getpov { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_getpov)) , Some (f) => f (dev , pov) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn joystick_update (& self , dev : * mut root :: reaper_functions :: joystick_device) -> bool { match self . pointers . joystick_update { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (joystick_update)) , Some (f) => f (dev) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_enumerateActions (& self , section : * mut root :: KbdSectionInfo , idx : :: std :: os :: raw :: c_int , nameOut : * mut * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . kbd_enumerateActions { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_enumerateActions)) , Some (f) => f (section , idx , nameOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_formatKeyName (& self , ac : * mut root :: ACCEL , s : * mut :: std :: os :: raw :: c_char) { match self . pointers . kbd_formatKeyName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_formatKeyName)) , Some (f) => f (ac , s) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_getCommandName (& self , cmd : :: std :: os :: raw :: c_int , s : * mut :: std :: os :: raw :: c_char , section : * mut root :: KbdSectionInfo) { match self . pointers . kbd_getCommandName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_getCommandName)) , Some (f) => f (cmd , s , section) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_getTextFromCmd (& self , cmd : :: std :: os :: raw :: c_int , section : * mut root :: KbdSectionInfo) -> * const :: std :: os :: raw :: c_char { match self . pointers . kbd_getTextFromCmd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_getTextFromCmd)) , Some (f) => f (cmd , section) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn KBD_OnMainActionEx (& self , cmd : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int , valhw : :: std :: os :: raw :: c_int , relmode : :: std :: os :: raw :: c_int , hwnd : root :: HWND , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . KBD_OnMainActionEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (KBD_OnMainActionEx)) , Some (f) => f (cmd , val , valhw , relmode , hwnd , proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_OnMidiEvent (& self , evt : * mut root :: MIDI_event_t , dev_index : :: std :: os :: raw :: c_int) { match self . pointers . kbd_OnMidiEvent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_OnMidiEvent)) , Some (f) => f (evt , dev_index) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_OnMidiList (& self , list : * mut root :: MIDI_eventlist , dev_index : :: std :: os :: raw :: c_int) { match self . pointers . kbd_OnMidiList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_OnMidiList)) , Some (f) => f (list , dev_index) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_ProcessActionsMenu (& self , menu : root :: HMENU , section : * mut root :: KbdSectionInfo) { match self . pointers . kbd_ProcessActionsMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_ProcessActionsMenu)) , Some (f) => f (menu , section) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_processMidiEventActionEx (& self , evt : * mut root :: MIDI_event_t , section : * mut root :: KbdSectionInfo , hwndCtx : root :: HWND) -> bool { match self . pointers . kbd_processMidiEventActionEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_processMidiEventActionEx)) , Some (f) => f (evt , section , hwndCtx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_reprocessMenu (& self , menu : root :: HMENU , section : * mut root :: KbdSectionInfo) { match self . pointers . kbd_reprocessMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_reprocessMenu)) , Some (f) => f (menu , section) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_RunCommandThroughHooks (& self , section : * mut root :: KbdSectionInfo , actionCommandID : * const :: std :: os :: raw :: c_int , val : * const :: std :: os :: raw :: c_int , valhw : * const :: std :: os :: raw :: c_int , relmode : * const :: std :: os :: raw :: c_int , hwnd : root :: HWND) -> bool { match self . pointers . kbd_RunCommandThroughHooks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_RunCommandThroughHooks)) , Some (f) => f (section , actionCommandID , val , valhw , relmode , hwnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_translateAccelerator (& self , hwnd : root :: HWND , msg : * mut root :: MSG , section : * mut root :: KbdSectionInfo) -> :: std :: os :: raw :: c_int { match self . pointers . kbd_translateAccelerator { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_translateAccelerator)) , Some (f) => f (hwnd , msg , section) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn kbd_translateMouse (& self , winmsg : * mut :: std :: os :: raw :: c_void , midimsg : * mut :: std :: os :: raw :: c_uchar) -> bool { match self . pointers . kbd_translateMouse { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (kbd_translateMouse)) , Some (f) => f (winmsg , midimsg) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__Destroy (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) { match self . pointers . LICE__Destroy { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__Destroy)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__DestroyFont (& self , font : * mut root :: reaper_functions :: LICE_IFont) { match self . pointers . LICE__DestroyFont { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__DestroyFont)) , Some (f) => f (font) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__DrawText (& self , font : * mut root :: reaper_functions :: LICE_IFont , bm : * mut root :: reaper_functions :: LICE_IBitmap , str : * const :: std :: os :: raw :: c_char , strcnt : :: std :: os :: raw :: c_int , rect : * mut root :: RECT , dtFlags : root :: UINT) -> :: std :: os :: raw :: c_int { match self . pointers . LICE__DrawText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__DrawText)) , Some (f) => f (font , bm , str , strcnt , rect , dtFlags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__GetBits (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) -> * mut :: std :: os :: raw :: c_void { match self . pointers . LICE__GetBits { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__GetBits)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__GetDC (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) -> root :: HDC { match self . pointers . LICE__GetDC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__GetDC)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__GetHeight (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) -> :: std :: os :: raw :: c_int { match self . pointers . LICE__GetHeight { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__GetHeight)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__GetRowSpan (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) -> :: std :: os :: raw :: c_int { match self . pointers . LICE__GetRowSpan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__GetRowSpan)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__GetWidth (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) -> :: std :: os :: raw :: c_int { match self . pointers . LICE__GetWidth { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__GetWidth)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__IsFlipped (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap) -> bool { match self . pointers . LICE__IsFlipped { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__IsFlipped)) , Some (f) => f (bm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__resize (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int) -> bool { match self . pointers . LICE__resize { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__resize)) , Some (f) => f (bm , w , h) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__SetBkColor (& self , font : * mut root :: reaper_functions :: LICE_IFont , color : root :: reaper_functions :: LICE_pixel) -> root :: reaper_functions :: LICE_pixel { match self . pointers . LICE__SetBkColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__SetBkColor)) , Some (f) => f (font , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__SetFromHFont (& self , font : * mut root :: reaper_functions :: LICE_IFont , hfont : root :: HFONT , flags : :: std :: os :: raw :: c_int) { match self . pointers . LICE__SetFromHFont { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__SetFromHFont)) , Some (f) => f (font , hfont , flags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__SetTextColor (& self , font : * mut root :: reaper_functions :: LICE_IFont , color : root :: reaper_functions :: LICE_pixel) -> root :: reaper_functions :: LICE_pixel { match self . pointers . LICE__SetTextColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__SetTextColor)) , Some (f) => f (font , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE__SetTextCombineMode (& self , ifont : * mut root :: reaper_functions :: LICE_IFont , mode : :: std :: os :: raw :: c_int , alpha : f32) { match self . pointers . LICE__SetTextCombineMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE__SetTextCombineMode)) , Some (f) => f (ifont , mode , alpha) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Arc (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , cx : f32 , cy : f32 , r : f32 , minAngle : f32 , maxAngle : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool) { match self . pointers . LICE_Arc { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Arc)) , Some (f) => f (dest , cx , cy , r , minAngle , maxAngle , color , alpha , mode , aa) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Blit (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , srcx : :: std :: os :: raw :: c_int , srcy : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_Blit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Blit)) , Some (f) => f (dest , src , dstx , dsty , srcx , srcy , srcw , srch , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Blur (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , srcx : :: std :: os :: raw :: c_int , srcy : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int) { match self . pointers . LICE_Blur { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Blur)) , Some (f) => f (dest , src , dstx , dsty , srcx , srcy , srcw , srch) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_BorderedRect (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , bgcolor : root :: reaper_functions :: LICE_pixel , fgcolor : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_BorderedRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_BorderedRect)) , Some (f) => f (dest , x , y , w , h , bgcolor , fgcolor , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Circle (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , cx : f32 , cy : f32 , r : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool) { match self . pointers . LICE_Circle { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Circle)) , Some (f) => f (dest , cx , cy , r , color , alpha , mode , aa) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Clear (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , color : root :: reaper_functions :: LICE_pixel) { match self . pointers . LICE_Clear { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Clear)) , Some (f) => f (dest , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_ClearRect (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , mask : root :: reaper_functions :: LICE_pixel , orbits : root :: reaper_functions :: LICE_pixel) { match self . pointers . LICE_ClearRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_ClearRect)) , Some (f) => f (dest , x , y , w , h , mask , orbits) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_ClipLine (& self , pX1Out : * mut :: std :: os :: raw :: c_int , pY1Out : * mut :: std :: os :: raw :: c_int , pX2Out : * mut :: std :: os :: raw :: c_int , pY2Out : * mut :: std :: os :: raw :: c_int , xLo : :: std :: os :: raw :: c_int , yLo : :: std :: os :: raw :: c_int , xHi : :: std :: os :: raw :: c_int , yHi : :: std :: os :: raw :: c_int) -> bool { match self . pointers . LICE_ClipLine { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_ClipLine)) , Some (f) => f (pX1Out , pY1Out , pX2Out , pY2Out , xLo , yLo , xHi , yHi) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Copy (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap) { match self . pointers . LICE_Copy { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Copy)) , Some (f) => f (dest , src) , } } pub fn LICE_CreateBitmap (& self , mode : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int) -> * mut root :: reaper_functions :: LICE_IBitmap { match self . pointers . LICE_CreateBitmap { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_CreateBitmap)) , Some (f) => f (mode , w , h) , } } pub fn LICE_CreateFont (& self) -> * mut root :: reaper_functions :: LICE_IFont { match self . pointers . LICE_CreateFont { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_CreateFont)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_DrawCBezier (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , xstart : f64 , ystart : f64 , xctl1 : f64 , yctl1 : f64 , xctl2 : f64 , yctl2 : f64 , xend : f64 , yend : f64 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool , tol : f64) { match self . pointers . LICE_DrawCBezier { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_DrawCBezier)) , Some (f) => f (dest , xstart , ystart , xctl1 , yctl1 , xctl2 , yctl2 , xend , yend , color , alpha , mode , aa , tol) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_DrawChar (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , c : :: std :: os :: raw :: c_char , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_DrawChar { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_DrawChar)) , Some (f) => f (bm , x , y , c , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_DrawGlyph (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alphas : * mut root :: reaper_functions :: LICE_pixel_chan , glyph_w : :: std :: os :: raw :: c_int , glyph_h : :: std :: os :: raw :: c_int , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_DrawGlyph { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_DrawGlyph)) , Some (f) => f (dest , x , y , color , alphas , glyph_w , glyph_h , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_DrawRect (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_DrawRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_DrawRect)) , Some (f) => f (dest , x , y , w , h , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_DrawText (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , string : * const :: std :: os :: raw :: c_char , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_DrawText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_DrawText)) , Some (f) => f (bm , x , y , string , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_FillCBezier (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , xstart : f64 , ystart : f64 , xctl1 : f64 , yctl1 : f64 , xctl2 : f64 , yctl2 : f64 , xend : f64 , yend : f64 , yfill : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool , tol : f64) { match self . pointers . LICE_FillCBezier { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_FillCBezier)) , Some (f) => f (dest , xstart , ystart , xctl1 , yctl1 , xctl2 , yctl2 , xend , yend , yfill , color , alpha , mode , aa , tol) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_FillCircle (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , cx : f32 , cy : f32 , r : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool) { match self . pointers . LICE_FillCircle { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_FillCircle)) , Some (f) => f (dest , cx , cy , r , color , alpha , mode , aa) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_FillConvexPolygon (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : * mut :: std :: os :: raw :: c_int , y : * mut :: std :: os :: raw :: c_int , npoints : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_FillConvexPolygon { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_FillConvexPolygon)) , Some (f) => f (dest , x , y , npoints , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_FillRect (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_FillRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_FillRect)) , Some (f) => f (dest , x , y , w , h , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_FillTrapezoid (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x1a : :: std :: os :: raw :: c_int , x1b : :: std :: os :: raw :: c_int , y1 : :: std :: os :: raw :: c_int , x2a : :: std :: os :: raw :: c_int , x2b : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_FillTrapezoid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_FillTrapezoid)) , Some (f) => f (dest , x1a , x1b , y1 , x2a , x2b , y2 , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_FillTriangle (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : :: std :: os :: raw :: c_int , y1 : :: std :: os :: raw :: c_int , x2 : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , x3 : :: std :: os :: raw :: c_int , y3 : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_FillTriangle { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_FillTriangle)) , Some (f) => f (dest , x1 , y1 , x2 , y2 , x3 , y3 , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_GetPixel (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int) -> root :: reaper_functions :: LICE_pixel { match self . pointers . LICE_GetPixel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_GetPixel)) , Some (f) => f (bm , x , y) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_GradRect (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , dstw : :: std :: os :: raw :: c_int , dsth : :: std :: os :: raw :: c_int , ir : f32 , ig : f32 , ib : f32 , ia : f32 , drdx : f32 , dgdx : f32 , dbdx : f32 , dadx : f32 , drdy : f32 , dgdy : f32 , dbdy : f32 , dady : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_GradRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_GradRect)) , Some (f) => f (dest , dstx , dsty , dstw , dsth , ir , ig , ib , ia , drdx , dgdx , dbdx , dadx , drdy , dgdy , dbdy , dady , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_Line (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : f32 , y1 : f32 , x2 : f32 , y2 : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool) { match self . pointers . LICE_Line { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_Line)) , Some (f) => f (dest , x1 , y1 , x2 , y2 , color , alpha , mode , aa) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_LineInt (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : :: std :: os :: raw :: c_int , y1 : :: std :: os :: raw :: c_int , x2 : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool) { match self . pointers . LICE_LineInt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_LineInt)) , Some (f) => f (dest , x1 , y1 , x2 , y2 , color , alpha , mode , aa) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_LoadPNG (& self , filename : * const :: std :: os :: raw :: c_char , bmp : * mut root :: reaper_functions :: LICE_IBitmap) -> * mut root :: reaper_functions :: LICE_IBitmap { match self . pointers . LICE_LoadPNG { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_LoadPNG)) , Some (f) => f (filename , bmp) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_LoadPNGFromResource (& self , hInst : root :: HINSTANCE , resid : * const :: std :: os :: raw :: c_char , bmp : * mut root :: reaper_functions :: LICE_IBitmap) -> * mut root :: reaper_functions :: LICE_IBitmap { match self . pointers . LICE_LoadPNGFromResource { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_LoadPNGFromResource)) , Some (f) => f (hInst , resid , bmp) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_MeasureText (& self , string : * const :: std :: os :: raw :: c_char , w : * mut :: std :: os :: raw :: c_int , h : * mut :: std :: os :: raw :: c_int) { match self . pointers . LICE_MeasureText { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_MeasureText)) , Some (f) => f (string , w , h) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_MultiplyAddRect (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , rsc : f32 , gsc : f32 , bsc : f32 , asc : f32 , radd : f32 , gadd : f32 , badd : f32 , aadd : f32) { match self . pointers . LICE_MultiplyAddRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_MultiplyAddRect)) , Some (f) => f (dest , x , y , w , h , rsc , gsc , bsc , asc , radd , gadd , badd , aadd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_PutPixel (& self , bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_PutPixel { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_PutPixel)) , Some (f) => f (bm , x , y , color , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_RotatedBlit (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , dstw : :: std :: os :: raw :: c_int , dsth : :: std :: os :: raw :: c_int , srcx : f32 , srcy : f32 , srcw : f32 , srch : f32 , angle : f32 , cliptosourcerect : bool , alpha : f32 , mode : :: std :: os :: raw :: c_int , rotxcent : f32 , rotycent : f32) { match self . pointers . LICE_RotatedBlit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_RotatedBlit)) , Some (f) => f (dest , src , dstx , dsty , dstw , dsth , srcx , srcy , srcw , srch , angle , cliptosourcerect , alpha , mode , rotxcent , rotycent) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_RoundRect (& self , drawbm : * mut root :: reaper_functions :: LICE_IBitmap , xpos : f32 , ypos : f32 , w : f32 , h : f32 , cornerradius : :: std :: os :: raw :: c_int , col : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool) { match self . pointers . LICE_RoundRect { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_RoundRect)) , Some (f) => f (drawbm , xpos , ypos , w , h , cornerradius , col , alpha , mode , aa) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_ScaledBlit (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , dstw : :: std :: os :: raw :: c_int , dsth : :: std :: os :: raw :: c_int , srcx : f32 , srcy : f32 , srcw : f32 , srch : f32 , alpha : f32 , mode : :: std :: os :: raw :: c_int) { match self . pointers . LICE_ScaledBlit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_ScaledBlit)) , Some (f) => f (dest , src , dstx , dsty , dstw , dsth , srcx , srcy , srcw , srch , alpha , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_SimpleFill (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , newcolor : root :: reaper_functions :: LICE_pixel , comparemask : root :: reaper_functions :: LICE_pixel , keepmask : root :: reaper_functions :: LICE_pixel) { match self . pointers . LICE_SimpleFill { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_SimpleFill)) , Some (f) => f (dest , x , y , newcolor , comparemask , keepmask) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LICE_ThickFLine (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : f64 , y1 : f64 , x2 : f64 , y2 : f64 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int) { match self . pointers . LICE_ThickFLine { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LICE_ThickFLine)) , Some (f) => f (dest , x1 , y1 , x2 , y2 , color , alpha , mode , wid) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn LocalizeString (& self , src_string : * const :: std :: os :: raw :: c_char , section : * const :: std :: os :: raw :: c_char , flagsOptional : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . LocalizeString { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (LocalizeString)) , Some (f) => f (src_string , section , flagsOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Loop_OnArrow (& self , project : * mut root :: ReaProject , direction : :: std :: os :: raw :: c_int) -> bool { match self . pointers . Loop_OnArrow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Loop_OnArrow)) , Some (f) => f (project , direction) , } } pub fn Main_OnCommand (& self , command : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int) { match self . pointers . Main_OnCommand { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Main_OnCommand)) , Some (f) => f (command , flag) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Main_OnCommandEx (& self , command : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int , proj : * mut root :: ReaProject) { match self . pointers . Main_OnCommandEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Main_OnCommandEx)) , Some (f) => f (command , flag , proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Main_openProject (& self , name : * const :: std :: os :: raw :: c_char) { match self . pointers . Main_openProject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Main_openProject)) , Some (f) => f (name) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Main_SaveProject (& self , proj : * mut root :: ReaProject , forceSaveAsInOptional : bool) { match self . pointers . Main_SaveProject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Main_SaveProject)) , Some (f) => f (proj , forceSaveAsInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Main_SaveProjectEx (& self , proj : * mut root :: ReaProject , filename : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int) { match self . pointers . Main_SaveProjectEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Main_SaveProjectEx)) , Some (f) => f (proj , filename , options) , } } pub fn Main_UpdateLoopInfo (& self , ignoremask : :: std :: os :: raw :: c_int) { match self . pointers . Main_UpdateLoopInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Main_UpdateLoopInfo)) , Some (f) => f (ignoremask) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MarkProjectDirty (& self , proj : * mut root :: ReaProject) { match self . pointers . MarkProjectDirty { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MarkProjectDirty)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MarkTrackItemsDirty (& self , track : * mut root :: MediaTrack , item : * mut root :: MediaItem) { match self . pointers . MarkTrackItemsDirty { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MarkTrackItemsDirty)) , Some (f) => f (track , item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Master_GetPlayRate (& self , project : * mut root :: ReaProject) -> f64 { match self . pointers . Master_GetPlayRate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Master_GetPlayRate)) , Some (f) => f (project) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Master_GetPlayRateAtTime (& self , time_s : f64 , proj : * mut root :: ReaProject) -> f64 { match self . pointers . Master_GetPlayRateAtTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Master_GetPlayRateAtTime)) , Some (f) => f (time_s , proj) , } } pub fn Master_GetTempo (& self) -> f64 { match self . pointers . Master_GetTempo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Master_GetTempo)) , Some (f) => f () , } } pub fn Master_NormalizePlayRate (& self , playrate : f64 , isnormalized : bool) -> f64 { match self . pointers . Master_NormalizePlayRate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Master_NormalizePlayRate)) , Some (f) => f (playrate , isnormalized) , } } pub fn Master_NormalizeTempo (& self , bpm : f64 , isnormalized : bool) -> f64 { match self . pointers . Master_NormalizeTempo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Master_NormalizeTempo)) , Some (f) => f (bpm , isnormalized) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MB (& self , msg : * const :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MB { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MB)) , Some (f) => f (msg , title , type_) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MediaItemDescendsFromTrack (& self , item : * mut root :: MediaItem , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . MediaItemDescendsFromTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MediaItemDescendsFromTrack)) , Some (f) => f (item , track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_CountEvts (& self , take : * mut root :: MediaItem_Take , notecntOut : * mut :: std :: os :: raw :: c_int , ccevtcntOut : * mut :: std :: os :: raw :: c_int , textsyxevtcntOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MIDI_CountEvts { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_CountEvts)) , Some (f) => f (take , notecntOut , ccevtcntOut , textsyxevtcntOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_DeleteCC (& self , take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_DeleteCC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_DeleteCC)) , Some (f) => f (take , ccidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_DeleteEvt (& self , take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_DeleteEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_DeleteEvt)) , Some (f) => f (take , evtidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_DeleteNote (& self , take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_DeleteNote { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_DeleteNote)) , Some (f) => f (take , noteidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_DeleteTextSysexEvt (& self , take : * mut root :: MediaItem_Take , textsyxevtidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_DeleteTextSysexEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_DeleteTextSysexEvt)) , Some (f) => f (take , textsyxevtidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_DisableSort (& self , take : * mut root :: MediaItem_Take) { match self . pointers . MIDI_DisableSort { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_DisableSort)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_EnumSelCC (& self , take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MIDI_EnumSelCC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_EnumSelCC)) , Some (f) => f (take , ccidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_EnumSelEvts (& self , take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MIDI_EnumSelEvts { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_EnumSelEvts)) , Some (f) => f (take , evtidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_EnumSelNotes (& self , take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MIDI_EnumSelNotes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_EnumSelNotes)) , Some (f) => f (take , noteidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_EnumSelTextSysexEvts (& self , take : * mut root :: MediaItem_Take , textsyxidx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MIDI_EnumSelTextSysexEvts { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_EnumSelTextSysexEvts)) , Some (f) => f (take , textsyxidx) , } } pub fn MIDI_eventlist_Create (& self) -> * mut root :: MIDI_eventlist { match self . pointers . MIDI_eventlist_Create { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_eventlist_Create)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_eventlist_Destroy (& self , evtlist : * mut root :: MIDI_eventlist) { match self . pointers . MIDI_eventlist_Destroy { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_eventlist_Destroy)) , Some (f) => f (evtlist) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetAllEvts (& self , take : * mut root :: MediaItem_Take , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetAllEvts { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetAllEvts)) , Some (f) => f (take , bufOutNeedBig , bufOutNeedBig_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetCC (& self , take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , selectedOut : * mut bool , mutedOut : * mut bool , ppqposOut : * mut f64 , chanmsgOut : * mut :: std :: os :: raw :: c_int , chanOut : * mut :: std :: os :: raw :: c_int , msg2Out : * mut :: std :: os :: raw :: c_int , msg3Out : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetCC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetCC)) , Some (f) => f (take , ccidx , selectedOut , mutedOut , ppqposOut , chanmsgOut , chanOut , msg2Out , msg3Out) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetCCShape (& self , take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , shapeOut : * mut :: std :: os :: raw :: c_int , beztensionOut : * mut f64) -> bool { match self . pointers . MIDI_GetCCShape { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetCCShape)) , Some (f) => f (take , ccidx , shapeOut , beztensionOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetEvt (& self , take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int , selectedOut : * mut bool , mutedOut : * mut bool , ppqposOut : * mut f64 , msgOut : * mut :: std :: os :: raw :: c_char , msgOut_sz : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetEvt)) , Some (f) => f (take , evtidx , selectedOut , mutedOut , ppqposOut , msgOut , msgOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetGrid (& self , take : * mut root :: MediaItem_Take , swingOutOptional : * mut f64 , noteLenOutOptional : * mut f64) -> f64 { match self . pointers . MIDI_GetGrid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetGrid)) , Some (f) => f (take , swingOutOptional , noteLenOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetHash (& self , take : * mut root :: MediaItem_Take , notesonly : bool , hashOut : * mut :: std :: os :: raw :: c_char , hashOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetHash { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetHash)) , Some (f) => f (take , notesonly , hashOut , hashOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetNote (& self , take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int , selectedOut : * mut bool , mutedOut : * mut bool , startppqposOut : * mut f64 , endppqposOut : * mut f64 , chanOut : * mut :: std :: os :: raw :: c_int , pitchOut : * mut :: std :: os :: raw :: c_int , velOut : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetNote { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetNote)) , Some (f) => f (take , noteidx , selectedOut , mutedOut , startppqposOut , endppqposOut , chanOut , pitchOut , velOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetPPQPos_EndOfMeasure (& self , take : * mut root :: MediaItem_Take , ppqpos : f64) -> f64 { match self . pointers . MIDI_GetPPQPos_EndOfMeasure { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetPPQPos_EndOfMeasure)) , Some (f) => f (take , ppqpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetPPQPos_StartOfMeasure (& self , take : * mut root :: MediaItem_Take , ppqpos : f64) -> f64 { match self . pointers . MIDI_GetPPQPos_StartOfMeasure { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetPPQPos_StartOfMeasure)) , Some (f) => f (take , ppqpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetPPQPosFromProjQN (& self , take : * mut root :: MediaItem_Take , projqn : f64) -> f64 { match self . pointers . MIDI_GetPPQPosFromProjQN { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetPPQPosFromProjQN)) , Some (f) => f (take , projqn) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetPPQPosFromProjTime (& self , take : * mut root :: MediaItem_Take , projtime : f64) -> f64 { match self . pointers . MIDI_GetPPQPosFromProjTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetPPQPosFromProjTime)) , Some (f) => f (take , projtime) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetProjQNFromPPQPos (& self , take : * mut root :: MediaItem_Take , ppqpos : f64) -> f64 { match self . pointers . MIDI_GetProjQNFromPPQPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetProjQNFromPPQPos)) , Some (f) => f (take , ppqpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetProjTimeFromPPQPos (& self , take : * mut root :: MediaItem_Take , ppqpos : f64) -> f64 { match self . pointers . MIDI_GetProjTimeFromPPQPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetProjTimeFromPPQPos)) , Some (f) => f (take , ppqpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetRecentInputEvent (& self , idx : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : * mut :: std :: os :: raw :: c_int , tsOut : * mut :: std :: os :: raw :: c_int , devIdxOut : * mut :: std :: os :: raw :: c_int , projPosOut : * mut f64 , projLoopCntOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . MIDI_GetRecentInputEvent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetRecentInputEvent)) , Some (f) => f (idx , bufOut , bufOut_sz , tsOut , devIdxOut , projPosOut , projLoopCntOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetScale (& self , take : * mut root :: MediaItem_Take , rootOut : * mut :: std :: os :: raw :: c_int , scaleOut : * mut :: std :: os :: raw :: c_int , nameOut : * mut :: std :: os :: raw :: c_char , nameOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetScale { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetScale)) , Some (f) => f (take , rootOut , scaleOut , nameOut , nameOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetTextSysexEvt (& self , take : * mut root :: MediaItem_Take , textsyxevtidx : :: std :: os :: raw :: c_int , selectedOutOptional : * mut bool , mutedOutOptional : * mut bool , ppqposOutOptional : * mut f64 , typeOutOptional : * mut :: std :: os :: raw :: c_int , msgOptional : * mut :: std :: os :: raw :: c_char , msgOptional_sz : * mut :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetTextSysexEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetTextSysexEvt)) , Some (f) => f (take , textsyxevtidx , selectedOutOptional , mutedOutOptional , ppqposOutOptional , typeOutOptional , msgOptional , msgOptional_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_GetTrackHash (& self , track : * mut root :: MediaTrack , notesonly : bool , hashOut : * mut :: std :: os :: raw :: c_char , hashOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_GetTrackHash { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_GetTrackHash)) , Some (f) => f (track , notesonly , hashOut , hashOut_sz) , } } pub fn midi_init (& self , force_reinit_input : :: std :: os :: raw :: c_int , force_reinit_output : :: std :: os :: raw :: c_int) { match self . pointers . midi_init { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (midi_init)) , Some (f) => f (force_reinit_input , force_reinit_output) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_InsertCC (& self , take : * mut root :: MediaItem_Take , selected : bool , muted : bool , ppqpos : f64 , chanmsg : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int , msg2 : :: std :: os :: raw :: c_int , msg3 : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_InsertCC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_InsertCC)) , Some (f) => f (take , selected , muted , ppqpos , chanmsg , chan , msg2 , msg3) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_InsertEvt (& self , take : * mut root :: MediaItem_Take , selected : bool , muted : bool , ppqpos : f64 , bytestr : * const :: std :: os :: raw :: c_char , bytestr_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_InsertEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_InsertEvt)) , Some (f) => f (take , selected , muted , ppqpos , bytestr , bytestr_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_InsertNote (& self , take : * mut root :: MediaItem_Take , selected : bool , muted : bool , startppqpos : f64 , endppqpos : f64 , chan : :: std :: os :: raw :: c_int , pitch : :: std :: os :: raw :: c_int , vel : :: std :: os :: raw :: c_int , noSortInOptional : * const bool) -> bool { match self . pointers . MIDI_InsertNote { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_InsertNote)) , Some (f) => f (take , selected , muted , startppqpos , endppqpos , chan , pitch , vel , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_InsertTextSysexEvt (& self , take : * mut root :: MediaItem_Take , selected : bool , muted : bool , ppqpos : f64 , type_ : :: std :: os :: raw :: c_int , bytestr : * const :: std :: os :: raw :: c_char , bytestr_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_InsertTextSysexEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_InsertTextSysexEvt)) , Some (f) => f (take , selected , muted , ppqpos , type_ , bytestr , bytestr_sz) , } } pub fn midi_reinit (& self) { match self . pointers . midi_reinit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (midi_reinit)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SelectAll (& self , take : * mut root :: MediaItem_Take , select : bool) { match self . pointers . MIDI_SelectAll { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SelectAll)) , Some (f) => f (take , select) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetAllEvts (& self , take : * mut root :: MediaItem_Take , buf : * const :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDI_SetAllEvts { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetAllEvts)) , Some (f) => f (take , buf , buf_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetCC (& self , take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , ppqposInOptional : * const f64 , chanmsgInOptional : * const :: std :: os :: raw :: c_int , chanInOptional : * const :: std :: os :: raw :: c_int , msg2InOptional : * const :: std :: os :: raw :: c_int , msg3InOptional : * const :: std :: os :: raw :: c_int , noSortInOptional : * const bool) -> bool { match self . pointers . MIDI_SetCC { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetCC)) , Some (f) => f (take , ccidx , selectedInOptional , mutedInOptional , ppqposInOptional , chanmsgInOptional , chanInOptional , msg2InOptional , msg3InOptional , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetCCShape (& self , take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , shape : :: std :: os :: raw :: c_int , beztension : f64 , noSortInOptional : * const bool) -> bool { match self . pointers . MIDI_SetCCShape { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetCCShape)) , Some (f) => f (take , ccidx , shape , beztension , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetEvt (& self , take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , ppqposInOptional : * const f64 , msgOptional : * const :: std :: os :: raw :: c_char , msgOptional_sz : :: std :: os :: raw :: c_int , noSortInOptional : * const bool) -> bool { match self . pointers . MIDI_SetEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetEvt)) , Some (f) => f (take , evtidx , selectedInOptional , mutedInOptional , ppqposInOptional , msgOptional , msgOptional_sz , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetItemExtents (& self , item : * mut root :: MediaItem , startQN : f64 , endQN : f64) -> bool { match self . pointers . MIDI_SetItemExtents { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetItemExtents)) , Some (f) => f (item , startQN , endQN) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetNote (& self , take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , startppqposInOptional : * const f64 , endppqposInOptional : * const f64 , chanInOptional : * const :: std :: os :: raw :: c_int , pitchInOptional : * const :: std :: os :: raw :: c_int , velInOptional : * const :: std :: os :: raw :: c_int , noSortInOptional : * const bool) -> bool { match self . pointers . MIDI_SetNote { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetNote)) , Some (f) => f (take , noteidx , selectedInOptional , mutedInOptional , startppqposInOptional , endppqposInOptional , chanInOptional , pitchInOptional , velInOptional , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_SetTextSysexEvt (& self , take : * mut root :: MediaItem_Take , textsyxevtidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , ppqposInOptional : * const f64 , typeInOptional : * const :: std :: os :: raw :: c_int , msgOptional : * const :: std :: os :: raw :: c_char , msgOptional_sz : :: std :: os :: raw :: c_int , noSortInOptional : * const bool) -> bool { match self . pointers . MIDI_SetTextSysexEvt { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_SetTextSysexEvt)) , Some (f) => f (take , textsyxevtidx , selectedInOptional , mutedInOptional , ppqposInOptional , typeInOptional , msgOptional , msgOptional_sz , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDI_Sort (& self , take : * mut root :: MediaItem_Take) { match self . pointers . MIDI_Sort { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDI_Sort)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_EnumTakes (& self , midieditor : root :: HWND , takeindex : :: std :: os :: raw :: c_int , editable_only : bool) -> * mut root :: MediaItem_Take { match self . pointers . MIDIEditor_EnumTakes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_EnumTakes)) , Some (f) => f (midieditor , takeindex , editable_only) , } } pub fn MIDIEditor_GetActive (& self) -> root :: HWND { match self . pointers . MIDIEditor_GetActive { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_GetActive)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_GetMode (& self , midieditor : root :: HWND) -> :: std :: os :: raw :: c_int { match self . pointers . MIDIEditor_GetMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_GetMode)) , Some (f) => f (midieditor) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_GetSetting_int (& self , midieditor : root :: HWND , setting_desc : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . MIDIEditor_GetSetting_int { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_GetSetting_int)) , Some (f) => f (midieditor , setting_desc) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_GetSetting_str (& self , midieditor : root :: HWND , setting_desc : * const :: std :: os :: raw :: c_char , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDIEditor_GetSetting_str { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_GetSetting_str)) , Some (f) => f (midieditor , setting_desc , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_GetTake (& self , midieditor : root :: HWND) -> * mut root :: MediaItem_Take { match self . pointers . MIDIEditor_GetTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_GetTake)) , Some (f) => f (midieditor) , } } pub fn MIDIEditor_LastFocused_OnCommand (& self , command_id : :: std :: os :: raw :: c_int , islistviewcommand : bool) -> bool { match self . pointers . MIDIEditor_LastFocused_OnCommand { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_LastFocused_OnCommand)) , Some (f) => f (command_id , islistviewcommand) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_OnCommand (& self , midieditor : root :: HWND , command_id : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDIEditor_OnCommand { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_OnCommand)) , Some (f) => f (midieditor , command_id) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MIDIEditor_SetSetting_int (& self , midieditor : root :: HWND , setting_desc : * const :: std :: os :: raw :: c_char , setting : :: std :: os :: raw :: c_int) -> bool { match self . pointers . MIDIEditor_SetSetting_int { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MIDIEditor_SetSetting_int)) , Some (f) => f (midieditor , setting_desc , setting) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn mkpanstr (& self , strNeed64 : * mut :: std :: os :: raw :: c_char , pan : f64) { match self . pointers . mkpanstr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (mkpanstr)) , Some (f) => f (strNeed64 , pan) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn mkvolpanstr (& self , strNeed64 : * mut :: std :: os :: raw :: c_char , vol : f64 , pan : f64) { match self . pointers . mkvolpanstr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (mkvolpanstr)) , Some (f) => f (strNeed64 , vol , pan) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn mkvolstr (& self , strNeed64 : * mut :: std :: os :: raw :: c_char , vol : f64) { match self . pointers . mkvolstr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (mkvolstr)) , Some (f) => f (strNeed64 , vol) , } } pub fn MoveEditCursor (& self , adjamt : f64 , dosel : bool) { match self . pointers . MoveEditCursor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MoveEditCursor)) , Some (f) => f (adjamt , dosel) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn MoveMediaItemToTrack (& self , item : * mut root :: MediaItem , desttr : * mut root :: MediaTrack) -> bool { match self . pointers . MoveMediaItemToTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MoveMediaItemToTrack)) , Some (f) => f (item , desttr) , } } pub fn MuteAllTracks (& self , mute : bool) { match self . pointers . MuteAllTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (MuteAllTracks)) , Some (f) => f (mute) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn my_getViewport (& self , r : * mut root :: RECT , sr : * const root :: RECT , wantWorkArea : bool) { match self . pointers . my_getViewport { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (my_getViewport)) , Some (f) => f (r , sr , wantWorkArea) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn NamedCommandLookup (& self , command_name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . NamedCommandLookup { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (NamedCommandLookup)) , Some (f) => f (command_name) , } } pub fn OnPauseButton (& self) { match self . pointers . OnPauseButton { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OnPauseButton)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OnPauseButtonEx (& self , proj : * mut root :: ReaProject) { match self . pointers . OnPauseButtonEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OnPauseButtonEx)) , Some (f) => f (proj) , } } pub fn OnPlayButton (& self) { match self . pointers . OnPlayButton { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OnPlayButton)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OnPlayButtonEx (& self , proj : * mut root :: ReaProject) { match self . pointers . OnPlayButtonEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OnPlayButtonEx)) , Some (f) => f (proj) , } } pub fn OnStopButton (& self) { match self . pointers . OnStopButton { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OnStopButton)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OnStopButtonEx (& self , proj : * mut root :: ReaProject) { match self . pointers . OnStopButtonEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OnStopButtonEx)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OpenColorThemeFile (& self , fn_ : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . OpenColorThemeFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OpenColorThemeFile)) , Some (f) => f (fn_) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OpenMediaExplorer (& self , mediafn : * const :: std :: os :: raw :: c_char , play : bool) -> root :: HWND { match self . pointers . OpenMediaExplorer { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OpenMediaExplorer)) , Some (f) => f (mediafn , play) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn OscLocalMessageToHost (& self , message : * const :: std :: os :: raw :: c_char , valueInOptional : * const f64) { match self . pointers . OscLocalMessageToHost { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (OscLocalMessageToHost)) , Some (f) => f (message , valueInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn parse_timestr (& self , buf : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . parse_timestr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (parse_timestr)) , Some (f) => f (buf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn parse_timestr_len (& self , buf : * const :: std :: os :: raw :: c_char , offset : f64 , modeoverride : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . parse_timestr_len { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (parse_timestr_len)) , Some (f) => f (buf , offset , modeoverride) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn parse_timestr_pos (& self , buf : * const :: std :: os :: raw :: c_char , modeoverride : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . parse_timestr_pos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (parse_timestr_pos)) , Some (f) => f (buf , modeoverride) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn parsepanstr (& self , str : * const :: std :: os :: raw :: c_char) -> f64 { match self . pointers . parsepanstr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (parsepanstr)) , Some (f) => f (str) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_Create (& self , filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int , srate : :: std :: os :: raw :: c_int , buildpeaks : bool) -> * mut root :: PCM_sink { match self . pointers . PCM_Sink_Create { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_Create)) , Some (f) => f (filename , cfg , cfg_sz , nch , srate , buildpeaks) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_CreateEx (& self , proj : * mut root :: ReaProject , filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int , srate : :: std :: os :: raw :: c_int , buildpeaks : bool) -> * mut root :: PCM_sink { match self . pointers . PCM_Sink_CreateEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_CreateEx)) , Some (f) => f (proj , filename , cfg , cfg_sz , nch , srate , buildpeaks) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_CreateMIDIFile (& self , filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , bpm : f64 , div : :: std :: os :: raw :: c_int) -> * mut root :: PCM_sink { match self . pointers . PCM_Sink_CreateMIDIFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_CreateMIDIFile)) , Some (f) => f (filename , cfg , cfg_sz , bpm , div) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_CreateMIDIFileEx (& self , proj : * mut root :: ReaProject , filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , bpm : f64 , div : :: std :: os :: raw :: c_int) -> * mut root :: PCM_sink { match self . pointers . PCM_Sink_CreateMIDIFileEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_CreateMIDIFileEx)) , Some (f) => f (proj , filename , cfg , cfg_sz , bpm , div) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_Enum (& self , idx : :: std :: os :: raw :: c_int , descstrOut : * mut * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_uint { match self . pointers . PCM_Sink_Enum { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_Enum)) , Some (f) => f (idx , descstrOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_GetExtension (& self , data : * const :: std :: os :: raw :: c_char , data_sz : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . PCM_Sink_GetExtension { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_GetExtension)) , Some (f) => f (data , data_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Sink_ShowConfig (& self , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , hwndParent : root :: HWND) -> root :: HWND { match self . pointers . PCM_Sink_ShowConfig { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Sink_ShowConfig)) , Some (f) => f (cfg , cfg_sz , hwndParent) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_BuildPeaks (& self , src : * mut root :: PCM_source , mode : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . PCM_Source_BuildPeaks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_BuildPeaks)) , Some (f) => f (src , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_CreateFromFile (& self , filename : * const :: std :: os :: raw :: c_char) -> * mut root :: PCM_source { match self . pointers . PCM_Source_CreateFromFile { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_CreateFromFile)) , Some (f) => f (filename) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_CreateFromFileEx (& self , filename : * const :: std :: os :: raw :: c_char , forcenoMidiImp : bool) -> * mut root :: PCM_source { match self . pointers . PCM_Source_CreateFromFileEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_CreateFromFileEx)) , Some (f) => f (filename , forcenoMidiImp) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_CreateFromSimple (& self , dec : * mut root :: ISimpleMediaDecoder , fn_ : * const :: std :: os :: raw :: c_char) -> * mut root :: PCM_source { match self . pointers . PCM_Source_CreateFromSimple { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_CreateFromSimple)) , Some (f) => f (dec , fn_) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_CreateFromType (& self , sourcetype : * const :: std :: os :: raw :: c_char) -> * mut root :: PCM_source { match self . pointers . PCM_Source_CreateFromType { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_CreateFromType)) , Some (f) => f (sourcetype) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_Destroy (& self , src : * mut root :: PCM_source) { match self . pointers . PCM_Source_Destroy { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_Destroy)) , Some (f) => f (src) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_GetPeaks (& self , src : * mut root :: PCM_source , peakrate : f64 , starttime : f64 , numchannels : :: std :: os :: raw :: c_int , numsamplesperchannel : :: std :: os :: raw :: c_int , want_extra_type : :: std :: os :: raw :: c_int , buf : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . PCM_Source_GetPeaks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_GetPeaks)) , Some (f) => f (src , peakrate , starttime , numchannels , numsamplesperchannel , want_extra_type , buf) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PCM_Source_GetSectionInfo (& self , src : * mut root :: PCM_source , offsOut : * mut f64 , lenOut : * mut f64 , revOut : * mut bool) -> bool { match self . pointers . PCM_Source_GetSectionInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PCM_Source_GetSectionInfo)) , Some (f) => f (src , offsOut , lenOut , revOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PeakBuild_Create (& self , src : * mut root :: PCM_source , fn_ : * const :: std :: os :: raw :: c_char , srate : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int) -> * mut root :: REAPER_PeakBuild_Interface { match self . pointers . PeakBuild_Create { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PeakBuild_Create)) , Some (f) => f (src , fn_ , srate , nch) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PeakBuild_CreateEx (& self , src : * mut root :: PCM_source , fn_ : * const :: std :: os :: raw :: c_char , srate : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> * mut root :: REAPER_PeakBuild_Interface { match self . pointers . PeakBuild_CreateEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PeakBuild_CreateEx)) , Some (f) => f (src , fn_ , srate , nch , flags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PeakGet_Create (& self , fn_ : * const :: std :: os :: raw :: c_char , srate : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int) -> * mut root :: REAPER_PeakGet_Interface { match self . pointers . PeakGet_Create { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PeakGet_Create)) , Some (f) => f (fn_ , srate , nch) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PitchShiftSubModeMenu (& self , hwnd : root :: HWND , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , submode_sel : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . PitchShiftSubModeMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PitchShiftSubModeMenu)) , Some (f) => f (hwnd , x , y , mode , submode_sel) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PlayPreview (& self , preview : * mut root :: preview_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . PlayPreview { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PlayPreview)) , Some (f) => f (preview) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PlayPreviewEx (& self , preview : * mut root :: preview_register_t , bufflags : :: std :: os :: raw :: c_int , measure_align : f64) -> :: std :: os :: raw :: c_int { match self . pointers . PlayPreviewEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PlayPreviewEx)) , Some (f) => f (preview , bufflags , measure_align) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PlayTrackPreview (& self , preview : * mut root :: preview_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . PlayTrackPreview { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PlayTrackPreview)) , Some (f) => f (preview) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PlayTrackPreview2 (& self , proj : * mut root :: ReaProject , preview : * mut root :: preview_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . PlayTrackPreview2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PlayTrackPreview2)) , Some (f) => f (proj , preview) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn PlayTrackPreview2Ex (& self , proj : * mut root :: ReaProject , preview : * mut root :: preview_register_t , flags : :: std :: os :: raw :: c_int , measure_align : f64) -> :: std :: os :: raw :: c_int { match self . pointers . PlayTrackPreview2Ex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PlayTrackPreview2Ex)) , Some (f) => f (proj , preview , flags , measure_align) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn plugin_getapi (& self , name : * const :: std :: os :: raw :: c_char) -> * mut :: std :: os :: raw :: c_void { match self . pointers . plugin_getapi { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (plugin_getapi)) , Some (f) => f (name) , } } pub fn plugin_getFilterList (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . plugin_getFilterList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (plugin_getFilterList)) , Some (f) => f () , } } pub fn plugin_getImportableProjectFilterList (& self) -> * const :: std :: os :: raw :: c_char { match self . pointers . plugin_getImportableProjectFilterList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (plugin_getImportableProjectFilterList)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn plugin_register (& self , name : * const :: std :: os :: raw :: c_char , infostruct : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int { match self . pointers . plugin_register { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (plugin_register)) , Some (f) => f (name , infostruct) , } } pub fn PluginWantsAlwaysRunFx (& self , amt : :: std :: os :: raw :: c_int) { match self . pointers . PluginWantsAlwaysRunFx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PluginWantsAlwaysRunFx)) , Some (f) => f (amt) , } } pub fn PreventUIRefresh (& self , prevent_count : :: std :: os :: raw :: c_int) { match self . pointers . PreventUIRefresh { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PreventUIRefresh)) , Some (f) => f (prevent_count) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn projectconfig_var_addr (& self , proj : * mut root :: ReaProject , idx : :: std :: os :: raw :: c_int) -> * mut :: std :: os :: raw :: c_void { match self . pointers . projectconfig_var_addr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (projectconfig_var_addr)) , Some (f) => f (proj , idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn projectconfig_var_getoffs (& self , name : * const :: std :: os :: raw :: c_char , szOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . projectconfig_var_getoffs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (projectconfig_var_getoffs)) , Some (f) => f (name , szOut) , } } pub fn PromptForAction (& self , session_mode : :: std :: os :: raw :: c_int , init_id : :: std :: os :: raw :: c_int , section_id : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . PromptForAction { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (PromptForAction)) , Some (f) => f (session_mode , init_id , section_id) , } } pub fn realloc_cmd_clear (& self , tok : :: std :: os :: raw :: c_int) { match self . pointers . realloc_cmd_clear { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (realloc_cmd_clear)) , Some (f) => f (tok) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn realloc_cmd_ptr (& self , ptr : * mut * mut :: std :: os :: raw :: c_char , ptr_size : * mut :: std :: os :: raw :: c_int , new_size : :: std :: os :: raw :: c_int) -> bool { match self . pointers . realloc_cmd_ptr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (realloc_cmd_ptr)) , Some (f) => f (ptr , ptr_size , new_size) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn realloc_cmd_register_buf (& self , ptr : * mut * mut :: std :: os :: raw :: c_char , ptr_size : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . realloc_cmd_register_buf { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (realloc_cmd_register_buf)) , Some (f) => f (ptr , ptr_size) , } } pub fn ReaperGetPitchShiftAPI (& self , version : :: std :: os :: raw :: c_int) -> * mut root :: IReaperPitchShift { match self . pointers . ReaperGetPitchShiftAPI { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ReaperGetPitchShiftAPI)) , Some (f) => f (version) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ReaScriptError (& self , errmsg : * const :: std :: os :: raw :: c_char) { match self . pointers . ReaScriptError { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ReaScriptError)) , Some (f) => f (errmsg) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn RecursiveCreateDirectory (& self , path : * const :: std :: os :: raw :: c_char , ignored : usize) -> :: std :: os :: raw :: c_int { match self . pointers . RecursiveCreateDirectory { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RecursiveCreateDirectory)) , Some (f) => f (path , ignored) , } } pub fn reduce_open_files (& self , flags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . reduce_open_files { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (reduce_open_files)) , Some (f) => f (flags) , } } pub fn RefreshToolbar (& self , command_id : :: std :: os :: raw :: c_int) { match self . pointers . RefreshToolbar { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RefreshToolbar)) , Some (f) => f (command_id) , } } pub fn RefreshToolbar2 (& self , section_id : :: std :: os :: raw :: c_int , command_id : :: std :: os :: raw :: c_int) { match self . pointers . RefreshToolbar2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RefreshToolbar2)) , Some (f) => f (section_id , command_id) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn relative_fn (& self , in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int) { match self . pointers . relative_fn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (relative_fn)) , Some (f) => f (in_ , out , out_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn RemoveTrackSend (& self , tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . RemoveTrackSend { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RemoveTrackSend)) , Some (f) => f (tr , category , sendidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn RenderFileSection (& self , source_filename : * const :: std :: os :: raw :: c_char , target_filename : * const :: std :: os :: raw :: c_char , start_percent : f64 , end_percent : f64 , playrate : f64) -> bool { match self . pointers . RenderFileSection { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (RenderFileSection)) , Some (f) => f (source_filename , target_filename , start_percent , end_percent , playrate) , } } pub fn ReorderSelectedTracks (& self , beforeTrackIdx : :: std :: os :: raw :: c_int , makePrevFolder : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ReorderSelectedTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ReorderSelectedTracks)) , Some (f) => f (beforeTrackIdx , makePrevFolder) , } } pub fn Resample_EnumModes (& self , mode : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . Resample_EnumModes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Resample_EnumModes)) , Some (f) => f (mode) , } } pub fn Resampler_Create (& self) -> * mut root :: REAPER_Resample_Interface { match self . pointers . Resampler_Create { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Resampler_Create)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn resolve_fn (& self , in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int) { match self . pointers . resolve_fn { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (resolve_fn)) , Some (f) => f (in_ , out , out_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn resolve_fn2 (& self , in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int , checkSubDirOptional : * const :: std :: os :: raw :: c_char) { match self . pointers . resolve_fn2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (resolve_fn2)) , Some (f) => f (in_ , out , out_sz , checkSubDirOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ResolveRenderPattern (& self , project : * mut root :: ReaProject , path : * const :: std :: os :: raw :: c_char , pattern : * const :: std :: os :: raw :: c_char , targets : * mut :: std :: os :: raw :: c_char , targets_sz : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . ResolveRenderPattern { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ResolveRenderPattern)) , Some (f) => f (project , path , pattern , targets , targets_sz) , } } pub fn ReverseNamedCommandLookup (& self , command_id : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . ReverseNamedCommandLookup { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ReverseNamedCommandLookup)) , Some (f) => f (command_id) , } } pub fn ScaleFromEnvelopeMode (& self , scaling_mode : :: std :: os :: raw :: c_int , val : f64) -> f64 { match self . pointers . ScaleFromEnvelopeMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ScaleFromEnvelopeMode)) , Some (f) => f (scaling_mode , val) , } } pub fn ScaleToEnvelopeMode (& self , scaling_mode : :: std :: os :: raw :: c_int , val : f64) -> f64 { match self . pointers . ScaleToEnvelopeMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ScaleToEnvelopeMode)) , Some (f) => f (scaling_mode , val) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn screenset_register (& self , id : * mut :: std :: os :: raw :: c_char , callbackFunc : * mut :: std :: os :: raw :: c_void , param : * mut :: std :: os :: raw :: c_void) { match self . pointers . screenset_register { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (screenset_register)) , Some (f) => f (id , callbackFunc , param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn screenset_registerNew (& self , id : * mut :: std :: os :: raw :: c_char , callbackFunc : root :: screensetNewCallbackFunc , param : * mut :: std :: os :: raw :: c_void) { match self . pointers . screenset_registerNew { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (screenset_registerNew)) , Some (f) => f (id , callbackFunc , param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn screenset_unregister (& self , id : * mut :: std :: os :: raw :: c_char) { match self . pointers . screenset_unregister { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (screenset_unregister)) , Some (f) => f (id) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn screenset_unregisterByParam (& self , param : * mut :: std :: os :: raw :: c_void) { match self . pointers . screenset_unregisterByParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (screenset_unregisterByParam)) , Some (f) => f (param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn screenset_updateLastFocus (& self , prevWin : root :: HWND) { match self . pointers . screenset_updateLastFocus { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (screenset_updateLastFocus)) , Some (f) => f (prevWin) , } } pub fn SectionFromUniqueID (& self , uniqueID : :: std :: os :: raw :: c_int) -> * mut root :: KbdSectionInfo { match self . pointers . SectionFromUniqueID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SectionFromUniqueID)) , Some (f) => f (uniqueID) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SelectAllMediaItems (& self , proj : * mut root :: ReaProject , selected : bool) { match self . pointers . SelectAllMediaItems { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SelectAllMediaItems)) , Some (f) => f (proj , selected) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SelectProjectInstance (& self , proj : * mut root :: ReaProject) { match self . pointers . SelectProjectInstance { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SelectProjectInstance)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SendLocalOscMessage (& self , local_osc_handler : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , msglen : :: std :: os :: raw :: c_int) { match self . pointers . SendLocalOscMessage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SendLocalOscMessage)) , Some (f) => f (local_osc_handler , msg , msglen) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetActiveTake (& self , take : * mut root :: MediaItem_Take) { match self . pointers . SetActiveTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetActiveTake)) , Some (f) => f (take) , } } pub fn SetAutomationMode (& self , mode : :: std :: os :: raw :: c_int , onlySel : bool) { match self . pointers . SetAutomationMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetAutomationMode)) , Some (f) => f (mode , onlySel) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetCurrentBPM (& self , __proj : * mut root :: ReaProject , bpm : f64 , wantUndo : bool) { match self . pointers . SetCurrentBPM { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetCurrentBPM)) , Some (f) => f (__proj , bpm , wantUndo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetCursorContext (& self , mode : :: std :: os :: raw :: c_int , envInOptional : * mut root :: TrackEnvelope) { match self . pointers . SetCursorContext { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetCursorContext)) , Some (f) => f (mode , envInOptional) , } } pub fn SetEditCurPos (& self , time : f64 , moveview : bool , seekplay : bool) { match self . pointers . SetEditCurPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetEditCurPos)) , Some (f) => f (time , moveview , seekplay) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetEditCurPos2 (& self , proj : * mut root :: ReaProject , time : f64 , moveview : bool , seekplay : bool) { match self . pointers . SetEditCurPos2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetEditCurPos2)) , Some (f) => f (proj , time , moveview , seekplay) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetEnvelopePoint (& self , envelope : * mut root :: TrackEnvelope , ptidx : :: std :: os :: raw :: c_int , timeInOptional : * mut f64 , valueInOptional : * mut f64 , shapeInOptional : * mut :: std :: os :: raw :: c_int , tensionInOptional : * mut f64 , selectedInOptional : * mut bool , noSortInOptional : * mut bool) -> bool { match self . pointers . SetEnvelopePoint { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetEnvelopePoint)) , Some (f) => f (envelope , ptidx , timeInOptional , valueInOptional , shapeInOptional , tensionInOptional , selectedInOptional , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetEnvelopePointEx (& self , envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , ptidx : :: std :: os :: raw :: c_int , timeInOptional : * mut f64 , valueInOptional : * mut f64 , shapeInOptional : * mut :: std :: os :: raw :: c_int , tensionInOptional : * mut f64 , selectedInOptional : * mut bool , noSortInOptional : * mut bool) -> bool { match self . pointers . SetEnvelopePointEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetEnvelopePointEx)) , Some (f) => f (envelope , autoitem_idx , ptidx , timeInOptional , valueInOptional , shapeInOptional , tensionInOptional , selectedInOptional , noSortInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetEnvelopeStateChunk (& self , env : * mut root :: TrackEnvelope , str : * const :: std :: os :: raw :: c_char , isundoOptional : bool) -> bool { match self . pointers . SetEnvelopeStateChunk { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetEnvelopeStateChunk)) , Some (f) => f (env , str , isundoOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetExtState (& self , section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char , persist : bool) { match self . pointers . SetExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetExtState)) , Some (f) => f (section , key , value , persist) , } } pub fn SetGlobalAutomationOverride (& self , mode : :: std :: os :: raw :: c_int) { match self . pointers . SetGlobalAutomationOverride { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetGlobalAutomationOverride)) , Some (f) => f (mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetItemStateChunk (& self , item : * mut root :: MediaItem , str : * const :: std :: os :: raw :: c_char , isundoOptional : bool) -> bool { match self . pointers . SetItemStateChunk { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetItemStateChunk)) , Some (f) => f (item , str , isundoOptional) , } } pub fn SetMasterTrackVisibility (& self , flag : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetMasterTrackVisibility { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMasterTrackVisibility)) , Some (f) => f (flag) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaItemInfo_Value (& self , item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64) -> bool { match self . pointers . SetMediaItemInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaItemInfo_Value)) , Some (f) => f (item , parmname , newvalue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaItemLength (& self , item : * mut root :: MediaItem , length : f64 , refreshUI : bool) -> bool { match self . pointers . SetMediaItemLength { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaItemLength)) , Some (f) => f (item , length , refreshUI) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaItemPosition (& self , item : * mut root :: MediaItem , position : f64 , refreshUI : bool) -> bool { match self . pointers . SetMediaItemPosition { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaItemPosition)) , Some (f) => f (item , position , refreshUI) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaItemSelected (& self , item : * mut root :: MediaItem , selected : bool) { match self . pointers . SetMediaItemSelected { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaItemSelected)) , Some (f) => f (item , selected) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaItemTake_Source (& self , take : * mut root :: MediaItem_Take , source : * mut root :: PCM_source) -> bool { match self . pointers . SetMediaItemTake_Source { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaItemTake_Source)) , Some (f) => f (take , source) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaItemTakeInfo_Value (& self , take : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64) -> bool { match self . pointers . SetMediaItemTakeInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaItemTakeInfo_Value)) , Some (f) => f (take , parmname , newvalue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMediaTrackInfo_Value (& self , tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64) -> bool { match self . pointers . SetMediaTrackInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMediaTrackInfo_Value)) , Some (f) => f (tr , parmname , newvalue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMIDIEditorGrid (& self , project : * mut root :: ReaProject , division : f64) { match self . pointers . SetMIDIEditorGrid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMIDIEditorGrid)) , Some (f) => f (project , division) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMixerScroll (& self , leftmosttrack : * mut root :: MediaTrack) -> * mut root :: MediaTrack { match self . pointers . SetMixerScroll { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMixerScroll)) , Some (f) => f (leftmosttrack) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetMouseModifier (& self , context : * const :: std :: os :: raw :: c_char , modifier_flag : :: std :: os :: raw :: c_int , action : * const :: std :: os :: raw :: c_char) { match self . pointers . SetMouseModifier { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetMouseModifier)) , Some (f) => f (context , modifier_flag , action) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetOnlyTrackSelected (& self , track : * mut root :: MediaTrack) { match self . pointers . SetOnlyTrackSelected { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetOnlyTrackSelected)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectGrid (& self , project : * mut root :: ReaProject , division : f64) { match self . pointers . SetProjectGrid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectGrid)) , Some (f) => f (project , division) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectMarker (& self , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . SetProjectMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectMarker)) , Some (f) => f (markrgnindexnumber , isrgn , pos , rgnend , name) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectMarker2 (& self , proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . SetProjectMarker2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectMarker2)) , Some (f) => f (proj , markrgnindexnumber , isrgn , pos , rgnend , name) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectMarker3 (& self , proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetProjectMarker3 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectMarker3)) , Some (f) => f (proj , markrgnindexnumber , isrgn , pos , rgnend , name , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectMarker4 (& self , proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetProjectMarker4 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectMarker4)) , Some (f) => f (proj , markrgnindexnumber , isrgn , pos , rgnend , name , color , flags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectMarkerByIndex (& self , proj : * mut root :: ReaProject , markrgnidx : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , IDnumber : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetProjectMarkerByIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectMarkerByIndex)) , Some (f) => f (proj , markrgnidx , isrgn , pos , rgnend , IDnumber , name , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjectMarkerByIndex2 (& self , proj : * mut root :: ReaProject , markrgnidx : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , IDnumber : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetProjectMarkerByIndex2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjectMarkerByIndex2)) , Some (f) => f (proj , markrgnidx , isrgn , pos , rgnend , IDnumber , name , color , flags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetProjExtState (& self , proj : * mut root :: ReaProject , extname : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . SetProjExtState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetProjExtState)) , Some (f) => f (proj , extname , key , value) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetRegionRenderMatrix (& self , proj : * mut root :: ReaProject , regionindex : :: std :: os :: raw :: c_int , track : * mut root :: MediaTrack , flag : :: std :: os :: raw :: c_int) { match self . pointers . SetRegionRenderMatrix { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetRegionRenderMatrix)) , Some (f) => f (proj , regionindex , track , flag) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetRenderLastError (& self , errorstr : * const :: std :: os :: raw :: c_char) { match self . pointers . SetRenderLastError { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetRenderLastError)) , Some (f) => f (errorstr) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTakeMarker (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , nameIn : * const :: std :: os :: raw :: c_char , srcposInOptional : * mut f64 , colorInOptional : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetTakeMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTakeMarker)) , Some (f) => f (take , idx , nameIn , srcposInOptional , colorInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTakeStretchMarker (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , pos : f64 , srcposInOptional : * const f64) -> :: std :: os :: raw :: c_int { match self . pointers . SetTakeStretchMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTakeStretchMarker)) , Some (f) => f (take , idx , pos , srcposInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTakeStretchMarkerSlope (& self , take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , slope : f64) -> bool { match self . pointers . SetTakeStretchMarkerSlope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTakeStretchMarkerSlope)) , Some (f) => f (take , idx , slope) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTempoTimeSigMarker (& self , proj : * mut root :: ReaProject , ptidx : :: std :: os :: raw :: c_int , timepos : f64 , measurepos : :: std :: os :: raw :: c_int , beatpos : f64 , bpm : f64 , timesig_num : :: std :: os :: raw :: c_int , timesig_denom : :: std :: os :: raw :: c_int , lineartempo : bool) -> bool { match self . pointers . SetTempoTimeSigMarker { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTempoTimeSigMarker)) , Some (f) => f (proj , ptidx , timepos , measurepos , beatpos , bpm , timesig_num , timesig_denom , lineartempo) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetThemeColor (& self , ini_key : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int , flagsOptional : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetThemeColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetThemeColor)) , Some (f) => f (ini_key , color , flagsOptional) , } } pub fn SetToggleCommandState (& self , section_id : :: std :: os :: raw :: c_int , command_id : :: std :: os :: raw :: c_int , state : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetToggleCommandState { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetToggleCommandState)) , Some (f) => f (section_id , command_id , state) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackAutomationMode (& self , tr : * mut root :: MediaTrack , mode : :: std :: os :: raw :: c_int) { match self . pointers . SetTrackAutomationMode { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackAutomationMode)) , Some (f) => f (tr , mode) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackColor (& self , track : * mut root :: MediaTrack , color : :: std :: os :: raw :: c_int) { match self . pointers . SetTrackColor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackColor)) , Some (f) => f (track , color) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackMIDILyrics (& self , track : * mut root :: MediaTrack , flag : :: std :: os :: raw :: c_int , str : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . SetTrackMIDILyrics { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackMIDILyrics)) , Some (f) => f (track , flag , str) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackMIDINoteName (& self , track : :: std :: os :: raw :: c_int , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . SetTrackMIDINoteName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackMIDINoteName)) , Some (f) => f (track , pitch , chan , name) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackMIDINoteNameEx (& self , proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . SetTrackMIDINoteNameEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackMIDINoteNameEx)) , Some (f) => f (proj , track , pitch , chan , name) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackSelected (& self , track : * mut root :: MediaTrack , selected : bool) { match self . pointers . SetTrackSelected { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackSelected)) , Some (f) => f (track , selected) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackSendInfo_Value (& self , tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64) -> bool { match self . pointers . SetTrackSendInfo_Value { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackSendInfo_Value)) , Some (f) => f (tr , category , sendidx , parmname , newvalue) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackSendUIPan (& self , track : * mut root :: MediaTrack , send_idx : :: std :: os :: raw :: c_int , pan : f64 , isend : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetTrackSendUIPan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackSendUIPan)) , Some (f) => f (track , send_idx , pan , isend) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackSendUIVol (& self , track : * mut root :: MediaTrack , send_idx : :: std :: os :: raw :: c_int , vol : f64 , isend : :: std :: os :: raw :: c_int) -> bool { match self . pointers . SetTrackSendUIVol { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackSendUIVol)) , Some (f) => f (track , send_idx , vol , isend) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackStateChunk (& self , track : * mut root :: MediaTrack , str : * const :: std :: os :: raw :: c_char , isundoOptional : bool) -> bool { match self . pointers . SetTrackStateChunk { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackStateChunk)) , Some (f) => f (track , str , isundoOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIInputMonitor (& self , track : * mut root :: MediaTrack , monitor : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetTrackUIInputMonitor { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIInputMonitor)) , Some (f) => f (track , monitor , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIMute (& self , track : * mut root :: MediaTrack , mute : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetTrackUIMute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIMute)) , Some (f) => f (track , mute , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIPan (& self , track : * mut root :: MediaTrack , pan : f64 , relative : bool , done : bool , igngroupflags : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . SetTrackUIPan { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIPan)) , Some (f) => f (track , pan , relative , done , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIPolarity (& self , track : * mut root :: MediaTrack , polarity : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetTrackUIPolarity { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIPolarity)) , Some (f) => f (track , polarity , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIRecArm (& self , track : * mut root :: MediaTrack , recarm : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetTrackUIRecArm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIRecArm)) , Some (f) => f (track , recarm , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUISolo (& self , track : * mut root :: MediaTrack , solo : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . SetTrackUISolo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUISolo)) , Some (f) => f (track , solo , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIVolume (& self , track : * mut root :: MediaTrack , volume : f64 , relative : bool , done : bool , igngroupflags : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . SetTrackUIVolume { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIVolume)) , Some (f) => f (track , volume , relative , done , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SetTrackUIWidth (& self , track : * mut root :: MediaTrack , width : f64 , relative : bool , done : bool , igngroupflags : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . SetTrackUIWidth { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SetTrackUIWidth)) , Some (f) => f (track , width , relative , done , igngroupflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShowActionList (& self , section : * mut root :: KbdSectionInfo , callerWnd : root :: HWND) { match self . pointers . ShowActionList { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ShowActionList)) , Some (f) => f (section , callerWnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShowConsoleMsg (& self , msg : * const :: std :: os :: raw :: c_char) { match self . pointers . ShowConsoleMsg { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ShowConsoleMsg)) , Some (f) => f (msg) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShowMessageBox (& self , msg : * const :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . ShowMessageBox { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ShowMessageBox)) , Some (f) => f (msg , title , type_) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ShowPopupMenu (& self , name : * const :: std :: os :: raw :: c_char , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , hwndParentOptional : root :: HWND , ctxOptional : * mut :: std :: os :: raw :: c_void , ctx2Optional : :: std :: os :: raw :: c_int , ctx3Optional : :: std :: os :: raw :: c_int) { match self . pointers . ShowPopupMenu { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ShowPopupMenu)) , Some (f) => f (name , x , y , hwndParentOptional , ctxOptional , ctx2Optional , ctx3Optional) , } } pub fn SLIDER2DB (& self , y : f64) -> f64 { match self . pointers . SLIDER2DB { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SLIDER2DB)) , Some (f) => f (y) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SnapToGrid (& self , project : * mut root :: ReaProject , time_pos : f64) -> f64 { match self . pointers . SnapToGrid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SnapToGrid)) , Some (f) => f (project , time_pos) , } } pub fn SoloAllTracks (& self , solo : :: std :: os :: raw :: c_int) { match self . pointers . SoloAllTracks { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SoloAllTracks)) , Some (f) => f (solo) , } } pub fn Splash_GetWnd (& self) -> root :: HWND { match self . pointers . Splash_GetWnd { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Splash_GetWnd)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn SplitMediaItem (& self , item : * mut root :: MediaItem , position : f64) -> * mut root :: MediaItem { match self . pointers . SplitMediaItem { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (SplitMediaItem)) , Some (f) => f (item , position) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn StopPreview (& self , preview : * mut root :: preview_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . StopPreview { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (StopPreview)) , Some (f) => f (preview) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn StopTrackPreview (& self , preview : * mut root :: preview_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . StopTrackPreview { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (StopTrackPreview)) , Some (f) => f (preview) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn StopTrackPreview2 (& self , proj : * mut root :: ReaProject , preview : * mut root :: preview_register_t) -> :: std :: os :: raw :: c_int { match self . pointers . StopTrackPreview2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (StopTrackPreview2)) , Some (f) => f (proj , preview) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn stringToGuid (& self , str : * const :: std :: os :: raw :: c_char , g : * mut root :: GUID) { match self . pointers . stringToGuid { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (stringToGuid)) , Some (f) => f (str , g) , } } pub fn StuffMIDIMessage (& self , mode : :: std :: os :: raw :: c_int , msg1 : :: std :: os :: raw :: c_int , msg2 : :: std :: os :: raw :: c_int , msg3 : :: std :: os :: raw :: c_int) { match self . pointers . StuffMIDIMessage { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (StuffMIDIMessage)) , Some (f) => f (mode , msg1 , msg2 , msg3) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_AddByName (& self , take : * mut root :: MediaItem_Take , fxname : * const :: std :: os :: raw :: c_char , instantiate : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_AddByName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_AddByName)) , Some (f) => f (take , fxname , instantiate) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_CopyToTake (& self , src_take : * mut root :: MediaItem_Take , src_fx : :: std :: os :: raw :: c_int , dest_take : * mut root :: MediaItem_Take , dest_fx : :: std :: os :: raw :: c_int , is_move : bool) { match self . pointers . TakeFX_CopyToTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_CopyToTake)) , Some (f) => f (src_take , src_fx , dest_take , dest_fx , is_move) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_CopyToTrack (& self , src_take : * mut root :: MediaItem_Take , src_fx : :: std :: os :: raw :: c_int , dest_track : * mut root :: MediaTrack , dest_fx : :: std :: os :: raw :: c_int , is_move : bool) { match self . pointers . TakeFX_CopyToTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_CopyToTrack)) , Some (f) => f (src_take , src_fx , dest_track , dest_fx , is_move) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_Delete (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_Delete { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_Delete)) , Some (f) => f (take , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_EndParamEdit (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_EndParamEdit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_EndParamEdit)) , Some (f) => f (take , fx , param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_FormatParamValue (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64 , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_FormatParamValue { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_FormatParamValue)) , Some (f) => f (take , fx , param , val , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_FormatParamValueNormalized (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_FormatParamValueNormalized { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_FormatParamValueNormalized)) , Some (f) => f (take , fx , param , value , buf , buf_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetChainVisible (& self , take : * mut root :: MediaItem_Take) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetChainVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetChainVisible)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetCount (& self , take : * mut root :: MediaItem_Take) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetCount)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetEnabled (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetEnabled)) , Some (f) => f (take , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetEnvelope (& self , take : * mut root :: MediaItem_Take , fxindex : :: std :: os :: raw :: c_int , parameterindex : :: std :: os :: raw :: c_int , create : bool) -> * mut root :: TrackEnvelope { match self . pointers . TakeFX_GetEnvelope { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetEnvelope)) , Some (f) => f (take , fxindex , parameterindex , create) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetFloatingWindow (& self , take : * mut root :: MediaItem_Take , index : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . TakeFX_GetFloatingWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetFloatingWindow)) , Some (f) => f (take , index) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetFormattedParamValue (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetFormattedParamValue { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetFormattedParamValue)) , Some (f) => f (take , fx , param , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetFXGUID (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int) -> * mut root :: GUID { match self . pointers . TakeFX_GetFXGUID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetFXGUID)) , Some (f) => f (take , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetFXName (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetFXName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetFXName)) , Some (f) => f (take , fx , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetIOSize (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , inputPinsOut : * mut :: std :: os :: raw :: c_int , outputPinsOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetIOSize { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetIOSize)) , Some (f) => f (take , fx , inputPinsOut , outputPinsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetNamedConfigParm (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetNamedConfigParm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetNamedConfigParm)) , Some (f) => f (take , fx , parmname , bufOutNeedBig , bufOutNeedBig_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetNumParams (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetNumParams { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetNumParams)) , Some (f) => f (take , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetOffline (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetOffline { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetOffline)) , Some (f) => f (take , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetOpen (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetOpen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetOpen)) , Some (f) => f (take , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParam (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64) -> f64 { match self . pointers . TakeFX_GetParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParam)) , Some (f) => f (take , fx , param , minvalOut , maxvalOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParameterStepSizes (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , stepOut : * mut f64 , smallstepOut : * mut f64 , largestepOut : * mut f64 , istoggleOut : * mut bool) -> bool { match self . pointers . TakeFX_GetParameterStepSizes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParameterStepSizes)) , Some (f) => f (take , fx , param , stepOut , smallstepOut , largestepOut , istoggleOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParamEx (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64 , midvalOut : * mut f64) -> f64 { match self . pointers . TakeFX_GetParamEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParamEx)) , Some (f) => f (take , fx , param , minvalOut , maxvalOut , midvalOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParamFromIdent (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , ident_str : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetParamFromIdent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParamFromIdent)) , Some (f) => f (take , fx , ident_str) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParamIdent (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetParamIdent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParamIdent)) , Some (f) => f (take , fx , param , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParamName (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetParamName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParamName)) , Some (f) => f (take , fx , param , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetParamNormalized (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . TakeFX_GetParamNormalized { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetParamNormalized)) , Some (f) => f (take , fx , param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetPinMappings (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , high32Out : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetPinMappings { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetPinMappings)) , Some (f) => f (take , fx , isoutput , pin , high32Out) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetPreset (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , presetnameOut : * mut :: std :: os :: raw :: c_char , presetnameOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_GetPreset { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetPreset)) , Some (f) => f (take , fx , presetnameOut , presetnameOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetPresetIndex (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , numberOfPresetsOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TakeFX_GetPresetIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetPresetIndex)) , Some (f) => f (take , fx , numberOfPresetsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_GetUserPresetFilename (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , fnOut : * mut :: std :: os :: raw :: c_char , fnOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . TakeFX_GetUserPresetFilename { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_GetUserPresetFilename)) , Some (f) => f (take , fx , fnOut , fnOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_NavigatePresets (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , presetmove : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_NavigatePresets { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_NavigatePresets)) , Some (f) => f (take , fx , presetmove) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetEnabled (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , enabled : bool) { match self . pointers . TakeFX_SetEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetEnabled)) , Some (f) => f (take , fx , enabled) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetNamedConfigParm (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . TakeFX_SetNamedConfigParm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetNamedConfigParm)) , Some (f) => f (take , fx , parmname , value) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetOffline (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , offline : bool) { match self . pointers . TakeFX_SetOffline { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetOffline)) , Some (f) => f (take , fx , offline) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetOpen (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , open : bool) { match self . pointers . TakeFX_SetOpen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetOpen)) , Some (f) => f (take , fx , open) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetParam (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64) -> bool { match self . pointers . TakeFX_SetParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetParam)) , Some (f) => f (take , fx , param , val) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetParamNormalized (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64) -> bool { match self . pointers . TakeFX_SetParamNormalized { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetParamNormalized)) , Some (f) => f (take , fx , param , value) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetPinMappings (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , low32bits : :: std :: os :: raw :: c_int , hi32bits : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_SetPinMappings { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetPinMappings)) , Some (f) => f (take , fx , isoutput , pin , low32bits , hi32bits) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetPreset (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , presetname : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . TakeFX_SetPreset { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetPreset)) , Some (f) => f (take , fx , presetname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_SetPresetByIndex (& self , take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , idx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TakeFX_SetPresetByIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_SetPresetByIndex)) , Some (f) => f (take , fx , idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeFX_Show (& self , take : * mut root :: MediaItem_Take , index : :: std :: os :: raw :: c_int , showFlag : :: std :: os :: raw :: c_int) { match self . pointers . TakeFX_Show { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeFX_Show)) , Some (f) => f (take , index , showFlag) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TakeIsMIDI (& self , take : * mut root :: MediaItem_Take) -> bool { match self . pointers . TakeIsMIDI { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TakeIsMIDI)) , Some (f) => f (take) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ThemeLayout_GetLayout (& self , section : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , nameOut : * mut :: std :: os :: raw :: c_char , nameOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ThemeLayout_GetLayout { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ThemeLayout_GetLayout)) , Some (f) => f (section , idx , nameOut , nameOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ThemeLayout_GetParameter (& self , wp : :: std :: os :: raw :: c_int , descOutOptional : * mut * const :: std :: os :: raw :: c_char , valueOutOptional : * mut :: std :: os :: raw :: c_int , defValueOutOptional : * mut :: std :: os :: raw :: c_int , minValueOutOptional : * mut :: std :: os :: raw :: c_int , maxValueOutOptional : * mut :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char { match self . pointers . ThemeLayout_GetParameter { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ThemeLayout_GetParameter)) , Some (f) => f (wp , descOutOptional , valueOutOptional , defValueOutOptional , minValueOutOptional , maxValueOutOptional) , } } pub fn ThemeLayout_RefreshAll (& self) { match self . pointers . ThemeLayout_RefreshAll { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ThemeLayout_RefreshAll)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ThemeLayout_SetLayout (& self , section : * const :: std :: os :: raw :: c_char , layout : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . ThemeLayout_SetLayout { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ThemeLayout_SetLayout)) , Some (f) => f (section , layout) , } } pub fn ThemeLayout_SetParameter (& self , wp : :: std :: os :: raw :: c_int , value : :: std :: os :: raw :: c_int , persist : bool) -> bool { match self . pointers . ThemeLayout_SetParameter { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ThemeLayout_SetParameter)) , Some (f) => f (wp , value , persist) , } } pub fn time_precise (& self) -> f64 { match self . pointers . time_precise { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (time_precise)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap2_beatsToTime (& self , proj : * mut root :: ReaProject , tpos : f64 , measuresInOptional : * const :: std :: os :: raw :: c_int) -> f64 { match self . pointers . TimeMap2_beatsToTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap2_beatsToTime)) , Some (f) => f (proj , tpos , measuresInOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap2_GetDividedBpmAtTime (& self , proj : * mut root :: ReaProject , time : f64) -> f64 { match self . pointers . TimeMap2_GetDividedBpmAtTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap2_GetDividedBpmAtTime)) , Some (f) => f (proj , time) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap2_GetNextChangeTime (& self , proj : * mut root :: ReaProject , time : f64) -> f64 { match self . pointers . TimeMap2_GetNextChangeTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap2_GetNextChangeTime)) , Some (f) => f (proj , time) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap2_QNToTime (& self , proj : * mut root :: ReaProject , qn : f64) -> f64 { match self . pointers . TimeMap2_QNToTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap2_QNToTime)) , Some (f) => f (proj , qn) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap2_timeToBeats (& self , proj : * mut root :: ReaProject , tpos : f64 , measuresOutOptional : * mut :: std :: os :: raw :: c_int , cmlOutOptional : * mut :: std :: os :: raw :: c_int , fullbeatsOutOptional : * mut f64 , cdenomOutOptional : * mut :: std :: os :: raw :: c_int) -> f64 { match self . pointers . TimeMap2_timeToBeats { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap2_timeToBeats)) , Some (f) => f (proj , tpos , measuresOutOptional , cmlOutOptional , fullbeatsOutOptional , cdenomOutOptional) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap2_timeToQN (& self , proj : * mut root :: ReaProject , tpos : f64) -> f64 { match self . pointers . TimeMap2_timeToQN { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap2_timeToQN)) , Some (f) => f (proj , tpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_curFrameRate (& self , proj : * mut root :: ReaProject , dropFrameOut : * mut bool) -> f64 { match self . pointers . TimeMap_curFrameRate { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_curFrameRate)) , Some (f) => f (proj , dropFrameOut) , } } pub fn TimeMap_GetDividedBpmAtTime (& self , time : f64) -> f64 { match self . pointers . TimeMap_GetDividedBpmAtTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_GetDividedBpmAtTime)) , Some (f) => f (time) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_GetMeasureInfo (& self , proj : * mut root :: ReaProject , measure : :: std :: os :: raw :: c_int , qn_startOut : * mut f64 , qn_endOut : * mut f64 , timesig_numOut : * mut :: std :: os :: raw :: c_int , timesig_denomOut : * mut :: std :: os :: raw :: c_int , tempoOut : * mut f64) -> f64 { match self . pointers . TimeMap_GetMeasureInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_GetMeasureInfo)) , Some (f) => f (proj , measure , qn_startOut , qn_endOut , timesig_numOut , timesig_denomOut , tempoOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_GetMetronomePattern (& self , proj : * mut root :: ReaProject , time : f64 , pattern : * mut :: std :: os :: raw :: c_char , pattern_sz : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TimeMap_GetMetronomePattern { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_GetMetronomePattern)) , Some (f) => f (proj , time , pattern , pattern_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_GetTimeSigAtTime (& self , proj : * mut root :: ReaProject , time : f64 , timesig_numOut : * mut :: std :: os :: raw :: c_int , timesig_denomOut : * mut :: std :: os :: raw :: c_int , tempoOut : * mut f64) { match self . pointers . TimeMap_GetTimeSigAtTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_GetTimeSigAtTime)) , Some (f) => f (proj , time , timesig_numOut , timesig_denomOut , tempoOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_QNToMeasures (& self , proj : * mut root :: ReaProject , qn : f64 , qnMeasureStartOutOptional : * mut f64 , qnMeasureEndOutOptional : * mut f64) -> :: std :: os :: raw :: c_int { match self . pointers . TimeMap_QNToMeasures { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_QNToMeasures)) , Some (f) => f (proj , qn , qnMeasureStartOutOptional , qnMeasureEndOutOptional) , } } pub fn TimeMap_QNToTime (& self , qn : f64) -> f64 { match self . pointers . TimeMap_QNToTime { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_QNToTime)) , Some (f) => f (qn) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_QNToTime_abs (& self , proj : * mut root :: ReaProject , qn : f64) -> f64 { match self . pointers . TimeMap_QNToTime_abs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_QNToTime_abs)) , Some (f) => f (proj , qn) , } } pub fn TimeMap_timeToQN (& self , tpos : f64) -> f64 { match self . pointers . TimeMap_timeToQN { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_timeToQN)) , Some (f) => f (tpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TimeMap_timeToQN_abs (& self , proj : * mut root :: ReaProject , tpos : f64) -> f64 { match self . pointers . TimeMap_timeToQN_abs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TimeMap_timeToQN_abs)) , Some (f) => f (proj , tpos) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ToggleTrackSendUIMute (& self , track : * mut root :: MediaTrack , send_idx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . ToggleTrackSendUIMute { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ToggleTrackSendUIMute)) , Some (f) => f (track , send_idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Track_GetPeakHoldDB (& self , track : * mut root :: MediaTrack , channel : :: std :: os :: raw :: c_int , clear : bool) -> f64 { match self . pointers . Track_GetPeakHoldDB { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Track_GetPeakHoldDB)) , Some (f) => f (track , channel , clear) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Track_GetPeakInfo (& self , track : * mut root :: MediaTrack , channel : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . Track_GetPeakInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Track_GetPeakInfo)) , Some (f) => f (track , channel) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackCtl_SetToolTip (& self , fmt : * const :: std :: os :: raw :: c_char , xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int , topmost : bool) { match self . pointers . TrackCtl_SetToolTip { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackCtl_SetToolTip)) , Some (f) => f (fmt , xpos , ypos , topmost) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_AddByName (& self , track : * mut root :: MediaTrack , fxname : * const :: std :: os :: raw :: c_char , recFX : bool , instantiate : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_AddByName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_AddByName)) , Some (f) => f (track , fxname , recFX , instantiate) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_CopyToTake (& self , src_track : * mut root :: MediaTrack , src_fx : :: std :: os :: raw :: c_int , dest_take : * mut root :: MediaItem_Take , dest_fx : :: std :: os :: raw :: c_int , is_move : bool) { match self . pointers . TrackFX_CopyToTake { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_CopyToTake)) , Some (f) => f (src_track , src_fx , dest_take , dest_fx , is_move) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_CopyToTrack (& self , src_track : * mut root :: MediaTrack , src_fx : :: std :: os :: raw :: c_int , dest_track : * mut root :: MediaTrack , dest_fx : :: std :: os :: raw :: c_int , is_move : bool) { match self . pointers . TrackFX_CopyToTrack { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_CopyToTrack)) , Some (f) => f (src_track , src_fx , dest_track , dest_fx , is_move) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_Delete (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_Delete { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_Delete)) , Some (f) => f (track , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_EndParamEdit (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_EndParamEdit { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_EndParamEdit)) , Some (f) => f (track , fx , param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_FormatParamValue (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64 , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_FormatParamValue { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_FormatParamValue)) , Some (f) => f (track , fx , param , val , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_FormatParamValueNormalized (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_FormatParamValueNormalized { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_FormatParamValueNormalized)) , Some (f) => f (track , fx , param , value , buf , buf_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetByName (& self , track : * mut root :: MediaTrack , fxname : * const :: std :: os :: raw :: c_char , instantiate : bool) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetByName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetByName)) , Some (f) => f (track , fxname , instantiate) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetChainVisible (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetChainVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetChainVisible)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetCount (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetCount)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetEnabled (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetEnabled)) , Some (f) => f (track , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetEQ (& self , track : * mut root :: MediaTrack , instantiate : bool) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetEQ { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetEQ)) , Some (f) => f (track , instantiate) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetEQBandEnabled (& self , track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , bandtype : :: std :: os :: raw :: c_int , bandidx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetEQBandEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetEQBandEnabled)) , Some (f) => f (track , fxidx , bandtype , bandidx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetEQParam (& self , track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , paramidx : :: std :: os :: raw :: c_int , bandtypeOut : * mut :: std :: os :: raw :: c_int , bandidxOut : * mut :: std :: os :: raw :: c_int , paramtypeOut : * mut :: std :: os :: raw :: c_int , normvalOut : * mut f64) -> bool { match self . pointers . TrackFX_GetEQParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetEQParam)) , Some (f) => f (track , fxidx , paramidx , bandtypeOut , bandidxOut , paramtypeOut , normvalOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetFloatingWindow (& self , track : * mut root :: MediaTrack , index : :: std :: os :: raw :: c_int) -> root :: HWND { match self . pointers . TrackFX_GetFloatingWindow { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetFloatingWindow)) , Some (f) => f (track , index) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetFormattedParamValue (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetFormattedParamValue { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetFormattedParamValue)) , Some (f) => f (track , fx , param , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetFXGUID (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int) -> * mut root :: GUID { match self . pointers . TrackFX_GetFXGUID { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetFXGUID)) , Some (f) => f (track , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetFXName (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetFXName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetFXName)) , Some (f) => f (track , fx , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetInstrument (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetInstrument { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetInstrument)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetIOSize (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , inputPinsOut : * mut :: std :: os :: raw :: c_int , outputPinsOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetIOSize { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetIOSize)) , Some (f) => f (track , fx , inputPinsOut , outputPinsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetNamedConfigParm (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetNamedConfigParm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetNamedConfigParm)) , Some (f) => f (track , fx , parmname , bufOutNeedBig , bufOutNeedBig_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetNumParams (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetNumParams { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetNumParams)) , Some (f) => f (track , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetOffline (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetOffline { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetOffline)) , Some (f) => f (track , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetOpen (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetOpen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetOpen)) , Some (f) => f (track , fx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParam (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64) -> f64 { match self . pointers . TrackFX_GetParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParam)) , Some (f) => f (track , fx , param , minvalOut , maxvalOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParameterStepSizes (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , stepOut : * mut f64 , smallstepOut : * mut f64 , largestepOut : * mut f64 , istoggleOut : * mut bool) -> bool { match self . pointers . TrackFX_GetParameterStepSizes { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParameterStepSizes)) , Some (f) => f (track , fx , param , stepOut , smallstepOut , largestepOut , istoggleOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParamEx (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64 , midvalOut : * mut f64) -> f64 { match self . pointers . TrackFX_GetParamEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParamEx)) , Some (f) => f (track , fx , param , minvalOut , maxvalOut , midvalOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParamFromIdent (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , ident_str : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetParamFromIdent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParamFromIdent)) , Some (f) => f (track , fx , ident_str) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParamIdent (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetParamIdent { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParamIdent)) , Some (f) => f (track , fx , param , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParamName (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetParamName { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParamName)) , Some (f) => f (track , fx , param , bufOut , bufOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetParamNormalized (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int) -> f64 { match self . pointers . TrackFX_GetParamNormalized { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetParamNormalized)) , Some (f) => f (track , fx , param) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetPinMappings (& self , tr : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , high32Out : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetPinMappings { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetPinMappings)) , Some (f) => f (tr , fx , isoutput , pin , high32Out) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetPreset (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , presetnameOut : * mut :: std :: os :: raw :: c_char , presetnameOut_sz : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_GetPreset { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetPreset)) , Some (f) => f (track , fx , presetnameOut , presetnameOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetPresetIndex (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , numberOfPresetsOut : * mut :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetPresetIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetPresetIndex)) , Some (f) => f (track , fx , numberOfPresetsOut) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetRecChainVisible (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetRecChainVisible { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetRecChainVisible)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetRecCount (& self , track : * mut root :: MediaTrack) -> :: std :: os :: raw :: c_int { match self . pointers . TrackFX_GetRecCount { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetRecCount)) , Some (f) => f (track) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_GetUserPresetFilename (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , fnOut : * mut :: std :: os :: raw :: c_char , fnOut_sz : :: std :: os :: raw :: c_int) { match self . pointers . TrackFX_GetUserPresetFilename { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_GetUserPresetFilename)) , Some (f) => f (track , fx , fnOut , fnOut_sz) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_NavigatePresets (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , presetmove : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_NavigatePresets { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_NavigatePresets)) , Some (f) => f (track , fx , presetmove) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetEnabled (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , enabled : bool) { match self . pointers . TrackFX_SetEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetEnabled)) , Some (f) => f (track , fx , enabled) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetEQBandEnabled (& self , track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , bandtype : :: std :: os :: raw :: c_int , bandidx : :: std :: os :: raw :: c_int , enable : bool) -> bool { match self . pointers . TrackFX_SetEQBandEnabled { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetEQBandEnabled)) , Some (f) => f (track , fxidx , bandtype , bandidx , enable) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetEQParam (& self , track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , bandtype : :: std :: os :: raw :: c_int , bandidx : :: std :: os :: raw :: c_int , paramtype : :: std :: os :: raw :: c_int , val : f64 , isnorm : bool) -> bool { match self . pointers . TrackFX_SetEQParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetEQParam)) , Some (f) => f (track , fxidx , bandtype , bandidx , paramtype , val , isnorm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetNamedConfigParm (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . TrackFX_SetNamedConfigParm { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetNamedConfigParm)) , Some (f) => f (track , fx , parmname , value) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetOffline (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , offline : bool) { match self . pointers . TrackFX_SetOffline { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetOffline)) , Some (f) => f (track , fx , offline) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetOpen (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , open : bool) { match self . pointers . TrackFX_SetOpen { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetOpen)) , Some (f) => f (track , fx , open) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetParam (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64) -> bool { match self . pointers . TrackFX_SetParam { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetParam)) , Some (f) => f (track , fx , param , val) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetParamNormalized (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64) -> bool { match self . pointers . TrackFX_SetParamNormalized { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetParamNormalized)) , Some (f) => f (track , fx , param , value) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetPinMappings (& self , tr : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , low32bits : :: std :: os :: raw :: c_int , hi32bits : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_SetPinMappings { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetPinMappings)) , Some (f) => f (tr , fx , isoutput , pin , low32bits , hi32bits) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetPreset (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , presetname : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . TrackFX_SetPreset { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetPreset)) , Some (f) => f (track , fx , presetname) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_SetPresetByIndex (& self , track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , idx : :: std :: os :: raw :: c_int) -> bool { match self . pointers . TrackFX_SetPresetByIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_SetPresetByIndex)) , Some (f) => f (track , fx , idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn TrackFX_Show (& self , track : * mut root :: MediaTrack , index : :: std :: os :: raw :: c_int , showFlag : :: std :: os :: raw :: c_int) { match self . pointers . TrackFX_Show { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackFX_Show)) , Some (f) => f (track , index , showFlag) , } } pub fn TrackList_AdjustWindows (& self , isMinor : bool) { match self . pointers . TrackList_AdjustWindows { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackList_AdjustWindows)) , Some (f) => f (isMinor) , } } pub fn TrackList_UpdateAllExternalSurfaces (& self) { match self . pointers . TrackList_UpdateAllExternalSurfaces { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (TrackList_UpdateAllExternalSurfaces)) , Some (f) => f () , } } pub fn Undo_BeginBlock (& self) { match self . pointers . Undo_BeginBlock { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_BeginBlock)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_BeginBlock2 (& self , proj : * mut root :: ReaProject) { match self . pointers . Undo_BeginBlock2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_BeginBlock2)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_CanRedo2 (& self , proj : * mut root :: ReaProject) -> * const :: std :: os :: raw :: c_char { match self . pointers . Undo_CanRedo2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_CanRedo2)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_CanUndo2 (& self , proj : * mut root :: ReaProject) -> * const :: std :: os :: raw :: c_char { match self . pointers . Undo_CanUndo2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_CanUndo2)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_DoRedo2 (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . Undo_DoRedo2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_DoRedo2)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_DoUndo2 (& self , proj : * mut root :: ReaProject) -> :: std :: os :: raw :: c_int { match self . pointers . Undo_DoUndo2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_DoUndo2)) , Some (f) => f (proj) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_EndBlock (& self , descchange : * const :: std :: os :: raw :: c_char , extraflags : :: std :: os :: raw :: c_int) { match self . pointers . Undo_EndBlock { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_EndBlock)) , Some (f) => f (descchange , extraflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_EndBlock2 (& self , proj : * mut root :: ReaProject , descchange : * const :: std :: os :: raw :: c_char , extraflags : :: std :: os :: raw :: c_int) { match self . pointers . Undo_EndBlock2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_EndBlock2)) , Some (f) => f (proj , descchange , extraflags) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_OnStateChange (& self , descchange : * const :: std :: os :: raw :: c_char) { match self . pointers . Undo_OnStateChange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_OnStateChange)) , Some (f) => f (descchange) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_OnStateChange2 (& self , proj : * mut root :: ReaProject , descchange : * const :: std :: os :: raw :: c_char) { match self . pointers . Undo_OnStateChange2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_OnStateChange2)) , Some (f) => f (proj , descchange) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_OnStateChange_Item (& self , proj : * mut root :: ReaProject , name : * const :: std :: os :: raw :: c_char , item : * mut root :: MediaItem) { match self . pointers . Undo_OnStateChange_Item { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_OnStateChange_Item)) , Some (f) => f (proj , name , item) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_OnStateChangeEx (& self , descchange : * const :: std :: os :: raw :: c_char , whichStates : :: std :: os :: raw :: c_int , trackparm : :: std :: os :: raw :: c_int) { match self . pointers . Undo_OnStateChangeEx { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_OnStateChangeEx)) , Some (f) => f (descchange , whichStates , trackparm) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn Undo_OnStateChangeEx2 (& self , proj : * mut root :: ReaProject , descchange : * const :: std :: os :: raw :: c_char , whichStates : :: std :: os :: raw :: c_int , trackparm : :: std :: os :: raw :: c_int) { match self . pointers . Undo_OnStateChangeEx2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (Undo_OnStateChangeEx2)) , Some (f) => f (proj , descchange , whichStates , trackparm) , } } pub fn update_disk_counters (& self , readamt : :: std :: os :: raw :: c_int , writeamt : :: std :: os :: raw :: c_int) { match self . pointers . update_disk_counters { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (update_disk_counters)) , Some (f) => f (readamt , writeamt) , } } pub fn UpdateArrange (& self) { match self . pointers . UpdateArrange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (UpdateArrange)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn UpdateItemInProject (& self , item : * mut root :: MediaItem) { match self . pointers . UpdateItemInProject { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (UpdateItemInProject)) , Some (f) => f (item) , } } pub fn UpdateTimeline (& self) { match self . pointers . UpdateTimeline { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (UpdateTimeline)) , Some (f) => f () , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ValidatePtr (& self , pointer : * mut :: std :: os :: raw :: c_void , ctypename : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . ValidatePtr { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ValidatePtr)) , Some (f) => f (pointer , ctypename) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ValidatePtr2 (& self , proj : * mut root :: ReaProject , pointer : * mut :: std :: os :: raw :: c_void , ctypename : * const :: std :: os :: raw :: c_char) -> bool { match self . pointers . ValidatePtr2 { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ValidatePtr2)) , Some (f) => f (proj , pointer , ctypename) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn ViewPrefs (& self , page : :: std :: os :: raw :: c_int , pageByName : * const :: std :: os :: raw :: c_char) { match self . pointers . ViewPrefs { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (ViewPrefs)) , Some (f) => f (page , pageByName) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn WDL_VirtualWnd_ScaledBlitBG (& self , dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: WDL_VirtualWnd_BGCfg , destx : :: std :: os :: raw :: c_int , desty : :: std :: os :: raw :: c_int , destw : :: std :: os :: raw :: c_int , desth : :: std :: os :: raw :: c_int , clipx : :: std :: os :: raw :: c_int , clipy : :: std :: os :: raw :: c_int , clipw : :: std :: os :: raw :: c_int , cliph : :: std :: os :: raw :: c_int , alpha : f32 , mode : :: std :: os :: raw :: c_int) -> bool { match self . pointers . WDL_VirtualWnd_ScaledBlitBG { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (WDL_VirtualWnd_ScaledBlitBG)) , Some (f) => f (dest , src , destx , desty , destw , desth , clipx , clipy , clipw , cliph , alpha , mode) , } } pub fn GetMidiInput (& self , idx : :: std :: os :: raw :: c_int) -> * mut root :: midi_Input { match self . pointers . GetMidiInput { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMidiInput)) , Some (f) => f (idx) , } } pub fn GetMidiOutput (& self , idx : :: std :: os :: raw :: c_int) -> * mut root :: midi_Output { match self . pointers . GetMidiOutput { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (GetMidiOutput)) , Some (f) => f (idx) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn InitializeCoolSB (& self , hwnd : root :: HWND) -> root :: BOOL { match self . pointers . InitializeCoolSB { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (InitializeCoolSB)) , Some (f) => f (hwnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn UninitializeCoolSB (& self , hwnd : root :: HWND) -> root :: HRESULT { match self . pointers . UninitializeCoolSB { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (UninitializeCoolSB)) , Some (f) => f (hwnd) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_SetMinThumbSize (& self , hwnd : root :: HWND , wBar : root :: UINT , size : root :: UINT) -> root :: BOOL { match self . pointers . CoolSB_SetMinThumbSize { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_SetMinThumbSize)) , Some (f) => f (hwnd , wBar , size) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_GetScrollInfo (& self , hwnd : root :: HWND , fnBar : :: std :: os :: raw :: c_int , lpsi : root :: LPSCROLLINFO) -> root :: BOOL { match self . pointers . CoolSB_GetScrollInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_GetScrollInfo)) , Some (f) => f (hwnd , fnBar , lpsi) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_SetScrollInfo (& self , hwnd : root :: HWND , fnBar : :: std :: os :: raw :: c_int , lpsi : root :: LPSCROLLINFO , fRedraw : root :: BOOL) -> :: std :: os :: raw :: c_int { match self . pointers . CoolSB_SetScrollInfo { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_SetScrollInfo)) , Some (f) => f (hwnd , fnBar , lpsi , fRedraw) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_SetScrollPos (& self , hwnd : root :: HWND , nBar : :: std :: os :: raw :: c_int , nPos : :: std :: os :: raw :: c_int , fRedraw : root :: BOOL) -> :: std :: os :: raw :: c_int { match self . pointers . CoolSB_SetScrollPos { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_SetScrollPos)) , Some (f) => f (hwnd , nBar , nPos , fRedraw) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_SetScrollRange (& self , hwnd : root :: HWND , nBar : :: std :: os :: raw :: c_int , nMinPos : :: std :: os :: raw :: c_int , nMaxPos : :: std :: os :: raw :: c_int , fRedraw : root :: BOOL) -> :: std :: os :: raw :: c_int { match self . pointers . CoolSB_SetScrollRange { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_SetScrollRange)) , Some (f) => f (hwnd , nBar , nMinPos , nMaxPos , fRedraw) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_ShowScrollBar (& self , hwnd : root :: HWND , wBar : :: std :: os :: raw :: c_int , fShow : root :: BOOL) -> root :: BOOL { match self . pointers . CoolSB_ShowScrollBar { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_ShowScrollBar)) , Some (f) => f (hwnd , wBar , fShow) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_SetResizingThumb (& self , hwnd : root :: HWND , active : root :: BOOL) -> root :: BOOL { match self . pointers . CoolSB_SetResizingThumb { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_SetResizingThumb)) , Some (f) => f (hwnd , active) , } } # [doc = r" # Safety"] # [doc = r""] # [doc = r" REAPER can crash if you pass an invalid pointer."] pub unsafe fn CoolSB_SetThemeIndex (& self , hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int) -> root :: BOOL { match self . pointers . CoolSB_SetThemeIndex { None => panic ! ("Attempt to use a function that has not been loaded: {}" , stringify ! (CoolSB_SetThemeIndex)) , Some (f) => f (hwnd , idx) , } } } # [doc = r" Container for the REAPER function pointers."] # [derive (Copy , Clone , Default)] pub struct ReaperFunctionPointers { pub (crate) loaded_count : u32 , pub __mergesort : Option < unsafe extern "C" fn (base : * mut :: std :: os :: raw :: c_void , nmemb : usize , size : usize , cmpfunc : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ,) -> :: std :: os :: raw :: c_int , > , tmpspace : * mut :: std :: os :: raw :: c_void ,) > , pub AddCustomizableMenu : Option < unsafe extern "C" fn (menuidstr : * const :: std :: os :: raw :: c_char , menuname : * const :: std :: os :: raw :: c_char , kbdsecname : * const :: std :: os :: raw :: c_char , addtomainmenu : bool ,) -> bool > , pub AddExtensionsMainMenu : Option < extern "C" fn () -> bool > , pub AddMediaItemToTrack : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack ,) -> * mut root :: MediaItem > , pub AddProjectMarker : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , wantidx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub AddProjectMarker2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , wantidx : :: std :: os :: raw :: c_int , color : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub AddRemoveReaScript : Option < unsafe extern "C" fn (add : bool , sectionID : :: std :: os :: raw :: c_int , scriptfn : * const :: std :: os :: raw :: c_char , commit : bool ,) -> :: std :: os :: raw :: c_int > , pub AddTakeToMediaItem : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> * mut root :: MediaItem_Take > , pub AddTempoTimeSigMarker : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , timepos : f64 , bpm : f64 , timesig_num : :: std :: os :: raw :: c_int , timesig_denom : :: std :: os :: raw :: c_int , lineartempochange : bool ,) -> bool > , pub adjustZoom : Option < extern "C" fn (amt : f64 , forceset : :: std :: os :: raw :: c_int , doupd : bool , centermode : :: std :: os :: raw :: c_int ,) > , pub AnyTrackSolo : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) -> bool > , pub APIExists : Option < unsafe extern "C" fn (function_name : * const :: std :: os :: raw :: c_char ,) -> bool > , pub APITest : Option < extern "C" fn () > , pub ApplyNudge : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , nudgeflag : :: std :: os :: raw :: c_int , nudgewhat : :: std :: os :: raw :: c_int , nudgeunits : :: std :: os :: raw :: c_int , value : f64 , reverse : bool , copies : :: std :: os :: raw :: c_int ,) -> bool > , pub ArmCommand : Option < unsafe extern "C" fn (cmd : :: std :: os :: raw :: c_int , sectionname : * const :: std :: os :: raw :: c_char ,) > , pub Audio_Init : Option < extern "C" fn () > , pub Audio_IsPreBuffer : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub Audio_IsRunning : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub Audio_Quit : Option < extern "C" fn () > , pub Audio_RegHardwareHook : Option < unsafe extern "C" fn (isAdd : bool , reg : * mut root :: audio_hook_register_t ,) -> :: std :: os :: raw :: c_int > , pub AudioAccessorStateChanged : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor ,) -> bool > , pub AudioAccessorUpdate : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor ,) > , pub AudioAccessorValidateState : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor ,) -> bool > , pub BypassFxAllTracks : Option < extern "C" fn (bypass : :: std :: os :: raw :: c_int) > , pub CalcMediaSrcLoudness : Option < unsafe extern "C" fn (mediasource : * mut root :: PCM_source ,) -> :: std :: os :: raw :: c_int > , pub CalculateNormalization : Option < unsafe extern "C" fn (source : * mut root :: PCM_source , normalizeTo : :: std :: os :: raw :: c_int , normalizeTarget : f64 , normalizeStart : f64 , normalizeEnd : f64 ,) -> f64 > , pub CalculatePeaks : Option < unsafe extern "C" fn (srcBlock : * mut root :: PCM_source_transfer_t , pksBlock : * mut root :: PCM_source_peaktransfer_t ,) -> :: std :: os :: raw :: c_int > , pub CalculatePeaksFloatSrcPtr : Option < unsafe extern "C" fn (srcBlock : * mut root :: PCM_source_transfer_t , pksBlock : * mut root :: PCM_source_peaktransfer_t ,) -> :: std :: os :: raw :: c_int > , pub ClearAllRecArmed : Option < extern "C" fn () > , pub ClearConsole : Option < extern "C" fn () > , pub ClearPeakCache : Option < extern "C" fn () > , pub ColorFromNative : Option < unsafe extern "C" fn (col : :: std :: os :: raw :: c_int , rOut : * mut :: std :: os :: raw :: c_int , gOut : * mut :: std :: os :: raw :: c_int , bOut : * mut :: std :: os :: raw :: c_int ,) > , pub ColorToNative : Option < extern "C" fn (r : :: std :: os :: raw :: c_int , g : :: std :: os :: raw :: c_int , b : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub CountActionShortcuts : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub CountAutomationItems : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope ,) -> :: std :: os :: raw :: c_int > , pub CountEnvelopePoints : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope ,) -> :: std :: os :: raw :: c_int > , pub CountEnvelopePointsEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub CountMediaItems : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub CountProjectMarkers : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , num_markersOut : * mut :: std :: os :: raw :: c_int , num_regionsOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub CountSelectedMediaItems : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub CountSelectedTracks : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub CountSelectedTracks2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , wantmaster : bool ,) -> :: std :: os :: raw :: c_int > , pub CountTakeEnvelopes : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> :: std :: os :: raw :: c_int > , pub CountTakes : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> :: std :: os :: raw :: c_int > , pub CountTCPFXParms : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub CountTempoTimeSigMarkers : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub CountTrackEnvelopes : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub CountTrackMediaItems : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub CountTracks : Option < unsafe extern "C" fn (projOptional : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub CreateLocalOscHandler : Option < unsafe extern "C" fn (obj : * mut :: std :: os :: raw :: c_void , callback : * mut :: std :: os :: raw :: c_void ,) -> * mut :: std :: os :: raw :: c_void > , pub CreateMIDIInput : Option < extern "C" fn (dev : :: std :: os :: raw :: c_int ,) -> * mut root :: midi_Input > , pub CreateMIDIOutput : Option < unsafe extern "C" fn (dev : :: std :: os :: raw :: c_int , streamMode : bool , msoffset100 : * mut :: std :: os :: raw :: c_int ,) -> * mut root :: midi_Output > , pub CreateNewMIDIItemInProj : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , starttime : f64 , endtime : f64 , qnInOptional : * const bool ,) -> * mut root :: MediaItem > , pub CreateTakeAudioAccessor : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take) -> * mut root :: reaper_functions :: AudioAccessor > , pub CreateTrackAudioAccessor : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack) -> * mut root :: reaper_functions :: AudioAccessor > , pub CreateTrackSend : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , desttrInOptional : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub CSurf_FlushUndo : Option < extern "C" fn (force : bool) > , pub CSurf_GetTouchState : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , isPan : :: std :: os :: raw :: c_int ,) -> bool > , pub CSurf_GoEnd : Option < extern "C" fn () > , pub CSurf_GoStart : Option < extern "C" fn () > , pub CSurf_NumTracks : Option < extern "C" fn (mcpView : bool) -> :: std :: os :: raw :: c_int > , pub CSurf_OnArrow : Option < extern "C" fn (whichdir : :: std :: os :: raw :: c_int , wantzoom : bool ,) > , pub CSurf_OnFwd : Option < extern "C" fn (seekplay : :: std :: os :: raw :: c_int) > , pub CSurf_OnFXChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , en : :: std :: os :: raw :: c_int ,) -> bool > , pub CSurf_OnInputMonitorChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , monitor : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub CSurf_OnInputMonitorChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , monitor : :: std :: os :: raw :: c_int , allowgang : bool ,) -> :: std :: os :: raw :: c_int > , pub CSurf_OnMuteChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , mute : :: std :: os :: raw :: c_int ,) -> bool > , pub CSurf_OnMuteChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , mute : :: std :: os :: raw :: c_int , allowgang : bool ,) -> bool > , pub CSurf_OnOscControlMessage : Option < unsafe extern "C" fn (msg : * const :: std :: os :: raw :: c_char , arg : * const f32 ,) > , pub CSurf_OnOscControlMessage2 : Option < unsafe extern "C" fn (msg : * const :: std :: os :: raw :: c_char , arg : * const f32 , argstr : * const :: std :: os :: raw :: c_char ,) > , pub CSurf_OnPanChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , pan : f64 , relative : bool ,) -> f64 > , pub CSurf_OnPanChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , pan : f64 , relative : bool , allowGang : bool ,) -> f64 > , pub CSurf_OnPause : Option < extern "C" fn () > , pub CSurf_OnPlay : Option < extern "C" fn () > , pub CSurf_OnPlayRateChange : Option < extern "C" fn (playrate : f64) > , pub CSurf_OnRecArmChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , recarm : :: std :: os :: raw :: c_int ,) -> bool > , pub CSurf_OnRecArmChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , recarm : :: std :: os :: raw :: c_int , allowgang : bool ,) -> bool > , pub CSurf_OnRecord : Option < extern "C" fn () > , pub CSurf_OnRecvPanChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , pan : f64 , relative : bool ,) -> f64 > , pub CSurf_OnRecvVolumeChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , volume : f64 , relative : bool ,) -> f64 > , pub CSurf_OnRew : Option < extern "C" fn (seekplay : :: std :: os :: raw :: c_int) > , pub CSurf_OnRewFwd : Option < extern "C" fn (seekplay : :: std :: os :: raw :: c_int , dir : :: std :: os :: raw :: c_int ,) > , pub CSurf_OnScroll : Option < extern "C" fn (xdir : :: std :: os :: raw :: c_int , ydir : :: std :: os :: raw :: c_int ,) > , pub CSurf_OnSelectedChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , selected : :: std :: os :: raw :: c_int ,) -> bool > , pub CSurf_OnSendPanChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , pan : f64 , relative : bool ,) -> f64 > , pub CSurf_OnSendVolumeChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , volume : f64 , relative : bool ,) -> f64 > , pub CSurf_OnSoloChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , solo : :: std :: os :: raw :: c_int ,) -> bool > , pub CSurf_OnSoloChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , solo : :: std :: os :: raw :: c_int , allowgang : bool ,) -> bool > , pub CSurf_OnStop : Option < extern "C" fn () > , pub CSurf_OnTempoChange : Option < extern "C" fn (bpm : f64) > , pub CSurf_OnTrackSelection : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack) > , pub CSurf_OnVolumeChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , volume : f64 , relative : bool ,) -> f64 > , pub CSurf_OnVolumeChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , volume : f64 , relative : bool , allowGang : bool ,) -> f64 > , pub CSurf_OnWidthChange : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , width : f64 , relative : bool ,) -> f64 > , pub CSurf_OnWidthChangeEx : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , width : f64 , relative : bool , allowGang : bool ,) -> f64 > , pub CSurf_OnZoom : Option < extern "C" fn (xdir : :: std :: os :: raw :: c_int , ydir : :: std :: os :: raw :: c_int ,) > , pub CSurf_ResetAllCachedVolPanStates : Option < extern "C" fn () > , pub CSurf_ScrubAmt : Option < extern "C" fn (amt : f64) > , pub CSurf_SetAutoMode : Option < unsafe extern "C" fn (mode : :: std :: os :: raw :: c_int , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetPlayState : Option < unsafe extern "C" fn (play : bool , pause : bool , rec : bool , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetRepeatState : Option < unsafe extern "C" fn (rep : bool , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetSurfaceMute : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , mute : bool , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetSurfacePan : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , pan : f64 , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetSurfaceRecArm : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , recarm : bool , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetSurfaceSelected : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , selected : bool , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetSurfaceSolo : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , solo : bool , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetSurfaceVolume : Option < unsafe extern "C" fn (trackid : * mut root :: MediaTrack , volume : f64 , ignoresurf : * mut root :: IReaperControlSurface ,) > , pub CSurf_SetTrackListChange : Option < extern "C" fn () > , pub CSurf_TrackFromID : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int , mcpView : bool ,) -> * mut root :: MediaTrack > , pub CSurf_TrackToID : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , mcpView : bool ,) -> :: std :: os :: raw :: c_int > , pub DB2SLIDER : Option < extern "C" fn (x : f64) -> f64 > , pub DeleteActionShortcut : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int , shortcutidx : :: std :: os :: raw :: c_int ,) -> bool > , pub DeleteEnvelopePointEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , ptidx : :: std :: os :: raw :: c_int ,) -> bool > , pub DeleteEnvelopePointRange : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , time_start : f64 , time_end : f64 ,) -> bool > , pub DeleteEnvelopePointRangeEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , time_start : f64 , time_end : f64 ,) -> bool > , pub DeleteExtState : Option < unsafe extern "C" fn (section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , persist : bool ,) > , pub DeleteProjectMarker : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool ,) -> bool > , pub DeleteProjectMarkerByIndex : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnidx : :: std :: os :: raw :: c_int ,) -> bool > , pub DeleteTakeMarker : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int ,) -> bool > , pub DeleteTakeStretchMarkers : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , countInOptional : * const :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub DeleteTempoTimeSigMarker : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , markerindex : :: std :: os :: raw :: c_int ,) -> bool > , pub DeleteTrack : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack) > , pub DeleteTrackMediaItem : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , it : * mut root :: MediaItem ,) -> bool > , pub DestroyAudioAccessor : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor ,) > , pub DestroyLocalOscHandler : Option < unsafe extern "C" fn (local_osc_handler : * mut :: std :: os :: raw :: c_void ,) > , pub DoActionShortcutDialog : Option < unsafe extern "C" fn (hwnd : root :: HWND , section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int , shortcutidx : :: std :: os :: raw :: c_int ,) -> bool > , pub Dock_UpdateDockID : Option < unsafe extern "C" fn (ident_str : * const :: std :: os :: raw :: c_char , whichDock : :: std :: os :: raw :: c_int ,) > , pub DockGetPosition : Option < extern "C" fn (whichDock : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub DockIsChildOfDock : Option < unsafe extern "C" fn (hwnd : root :: HWND , isFloatingDockerOut : * mut bool ,) -> :: std :: os :: raw :: c_int > , pub DockWindowActivate : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub DockWindowAdd : Option < unsafe extern "C" fn (hwnd : root :: HWND , name : * const :: std :: os :: raw :: c_char , pos : :: std :: os :: raw :: c_int , allowShow : bool ,) > , pub DockWindowAddEx : Option < unsafe extern "C" fn (hwnd : root :: HWND , name : * const :: std :: os :: raw :: c_char , identstr : * const :: std :: os :: raw :: c_char , allowShow : bool ,) > , pub DockWindowRefresh : Option < extern "C" fn () > , pub DockWindowRefreshForHWND : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub DockWindowRemove : Option < unsafe extern "C" fn (hwnd : root :: HWND) > , pub DuplicateCustomizableMenu : Option < unsafe extern "C" fn (srcmenu : * mut :: std :: os :: raw :: c_void , destmenu : * mut :: std :: os :: raw :: c_void ,) -> bool > , pub EditTempoTimeSigMarker : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , markerindex : :: std :: os :: raw :: c_int ,) -> bool > , pub EnsureNotCompletelyOffscreen : Option < unsafe extern "C" fn (rInOut : * mut root :: RECT) > , pub EnumerateFiles : Option < unsafe extern "C" fn (path : * const :: std :: os :: raw :: c_char , fileindex : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub EnumerateSubdirectories : Option < unsafe extern "C" fn (path : * const :: std :: os :: raw :: c_char , subdirindex : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub EnumPitchShiftModes : Option < unsafe extern "C" fn (mode : :: std :: os :: raw :: c_int , strOut : * mut * const :: std :: os :: raw :: c_char ,) -> bool > , pub EnumPitchShiftSubModes : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int , submode : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub EnumProjectMarkers : Option < unsafe extern "C" fn (idx : :: std :: os :: raw :: c_int , isrgnOut : * mut bool , posOut : * mut f64 , rgnendOut : * mut f64 , nameOut : * mut * const :: std :: os :: raw :: c_char , markrgnindexnumberOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub EnumProjectMarkers2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , idx : :: std :: os :: raw :: c_int , isrgnOut : * mut bool , posOut : * mut f64 , rgnendOut : * mut f64 , nameOut : * mut * const :: std :: os :: raw :: c_char , markrgnindexnumberOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub EnumProjectMarkers3 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , idx : :: std :: os :: raw :: c_int , isrgnOut : * mut bool , posOut : * mut f64 , rgnendOut : * mut f64 , nameOut : * mut * const :: std :: os :: raw :: c_char , markrgnindexnumberOut : * mut :: std :: os :: raw :: c_int , colorOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub EnumProjects : Option < unsafe extern "C" fn (idx : :: std :: os :: raw :: c_int , projfnOutOptional : * mut :: std :: os :: raw :: c_char , projfnOutOptional_sz : :: std :: os :: raw :: c_int ,) -> * mut root :: ReaProject > , pub EnumProjExtState : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , extname : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , keyOutOptional : * mut :: std :: os :: raw :: c_char , keyOutOptional_sz : :: std :: os :: raw :: c_int , valOutOptional : * mut :: std :: os :: raw :: c_char , valOutOptional_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub EnumRegionRenderMatrix : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , regionindex : :: std :: os :: raw :: c_int , rendertrack : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaTrack > , pub EnumTrackMIDIProgramNames : Option < unsafe extern "C" fn (track : :: std :: os :: raw :: c_int , programNumber : :: std :: os :: raw :: c_int , programName : * mut :: std :: os :: raw :: c_char , programName_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub EnumTrackMIDIProgramNamesEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , programNumber : :: std :: os :: raw :: c_int , programName : * mut :: std :: os :: raw :: c_char , programName_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub Envelope_Evaluate : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , time : f64 , samplerate : f64 , samplesRequested : :: std :: os :: raw :: c_int , valueOut : * mut f64 , dVdSOut : * mut f64 , ddVdSOut : * mut f64 , dddVdSOut : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub Envelope_FormatValue : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , value : f64 , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) > , pub Envelope_GetParentTake : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , indexOut : * mut :: std :: os :: raw :: c_int , index2Out : * mut :: std :: os :: raw :: c_int ,) -> * mut root :: MediaItem_Take > , pub Envelope_GetParentTrack : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , indexOut : * mut :: std :: os :: raw :: c_int , index2Out : * mut :: std :: os :: raw :: c_int ,) -> * mut root :: MediaTrack > , pub Envelope_SortPoints : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope ,) -> bool > , pub Envelope_SortPointsEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int ,) -> bool > , pub ExecProcess : Option < unsafe extern "C" fn (cmdline : * const :: std :: os :: raw :: c_char , timeoutmsec : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub file_exists : Option < unsafe extern "C" fn (path : * const :: std :: os :: raw :: c_char ,) -> bool > , pub FindTempoTimeSigMarker : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , time : f64 ,) -> :: std :: os :: raw :: c_int > , pub format_timestr : Option < unsafe extern "C" fn (tpos : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int ,) > , pub format_timestr_len : Option < unsafe extern "C" fn (tpos : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , offset : f64 , modeoverride : :: std :: os :: raw :: c_int ,) > , pub format_timestr_pos : Option < unsafe extern "C" fn (tpos : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , modeoverride : :: std :: os :: raw :: c_int ,) > , pub FreeHeapPtr : Option < unsafe extern "C" fn (ptr : * mut :: std :: os :: raw :: c_void) > , pub genGuid : Option < unsafe extern "C" fn (g : * mut root :: GUID) > , pub get_config_var : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , szOut : * mut :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_void > , pub get_config_var_string : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub get_ini_file : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub get_midi_config_var : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , szOut : * mut :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_void > , pub GetActionShortcutDesc : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , cmdID : :: std :: os :: raw :: c_int , shortcutidx : :: std :: os :: raw :: c_int , descOut : * mut :: std :: os :: raw :: c_char , descOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetActiveTake : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> * mut root :: MediaItem_Take > , pub GetAllProjectPlayStates : Option < unsafe extern "C" fn (ignoreProject : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub GetAppVersion : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub GetArmedCommand : Option < unsafe extern "C" fn (secOut : * mut :: std :: os :: raw :: c_char , secOut_sz : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetAudioAccessorEndTime : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor ,) -> f64 > , pub GetAudioAccessorHash : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor , hashNeed128 : * mut :: std :: os :: raw :: c_char ,) > , pub GetAudioAccessorSamples : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor , samplerate : :: std :: os :: raw :: c_int , numchannels : :: std :: os :: raw :: c_int , starttime_sec : f64 , numsamplesperchannel : :: std :: os :: raw :: c_int , samplebuffer : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub GetAudioAccessorStartTime : Option < unsafe extern "C" fn (accessor : * mut root :: reaper_functions :: AudioAccessor ,) -> f64 > , pub GetAudioDeviceInfo : Option < unsafe extern "C" fn (attribute : * const :: std :: os :: raw :: c_char , descOut : * mut :: std :: os :: raw :: c_char , descOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetColorTheme : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int , defval : :: std :: os :: raw :: c_int ,) -> root :: INT_PTR > , pub GetColorThemeStruct : Option < unsafe extern "C" fn (szOut : * mut :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_void > , pub GetConfigWantsDock : Option < unsafe extern "C" fn (ident_str : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub GetContextMenu : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int ,) -> root :: HMENU > , pub GetCurrentProjectInLoadSave : Option < extern "C" fn () -> * mut root :: ReaProject > , pub GetCursorContext : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetCursorContext2 : Option < extern "C" fn (want_last_valid : bool ,) -> :: std :: os :: raw :: c_int > , pub GetCursorPosition : Option < extern "C" fn () -> f64 > , pub GetCursorPositionEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) -> f64 > , pub GetDisplayedMediaItemColor : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> :: std :: os :: raw :: c_int > , pub GetDisplayedMediaItemColor2 : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , take : * mut root :: MediaItem_Take ,) -> :: std :: os :: raw :: c_int > , pub GetEnvelopeInfo_Value : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , parmname : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub GetEnvelopeName : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetEnvelopePoint : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , ptidx : :: std :: os :: raw :: c_int , timeOut : * mut f64 , valueOut : * mut f64 , shapeOut : * mut :: std :: os :: raw :: c_int , tensionOut : * mut f64 , selectedOut : * mut bool ,) -> bool > , pub GetEnvelopePointByTime : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , time : f64 ,) -> :: std :: os :: raw :: c_int > , pub GetEnvelopePointByTimeEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , time : f64 ,) -> :: std :: os :: raw :: c_int > , pub GetEnvelopePointEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , ptidx : :: std :: os :: raw :: c_int , timeOut : * mut f64 , valueOut : * mut f64 , shapeOut : * mut :: std :: os :: raw :: c_int , tensionOut : * mut f64 , selectedOut : * mut bool ,) -> bool > , pub GetEnvelopeScalingMode : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope ,) -> :: std :: os :: raw :: c_int > , pub GetEnvelopeStateChunk : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , strNeedBig : * mut :: std :: os :: raw :: c_char , strNeedBig_sz : :: std :: os :: raw :: c_int , isundoOptional : bool ,) -> bool > , pub GetEnvelopeUIState : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope ,) -> :: std :: os :: raw :: c_int > , pub GetExePath : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub GetExtState : Option < unsafe extern "C" fn (section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char ,) -> * const :: std :: os :: raw :: c_char > , pub GetFocusedFX : Option < unsafe extern "C" fn (tracknumberOut : * mut :: std :: os :: raw :: c_int , itemnumberOut : * mut :: std :: os :: raw :: c_int , fxnumberOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetFocusedFX2 : Option < unsafe extern "C" fn (tracknumberOut : * mut :: std :: os :: raw :: c_int , itemnumberOut : * mut :: std :: os :: raw :: c_int , fxnumberOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetFreeDiskSpaceForRecordPath : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , pathidx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetFXEnvelope : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxindex : :: std :: os :: raw :: c_int , parameterindex : :: std :: os :: raw :: c_int , create : bool ,) -> * mut root :: TrackEnvelope > , pub GetGlobalAutomationOverride : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetHZoomLevel : Option < extern "C" fn () -> f64 > , pub GetIconThemePointer : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_void > , pub GetIconThemePointerForDPI : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , dpisc : :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_void > , pub GetIconThemeStruct : Option < unsafe extern "C" fn (szOut : * mut :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_void > , pub GetInputChannelName : Option < extern "C" fn (channelIndex : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub GetInputOutputLatency : Option < unsafe extern "C" fn (inputlatencyOut : * mut :: std :: os :: raw :: c_int , outputLatencyOut : * mut :: std :: os :: raw :: c_int ,) > , pub GetItemEditingTime2 : Option < unsafe extern "C" fn (which_itemOut : * mut * mut root :: PCM_source , flagsOut : * mut :: std :: os :: raw :: c_int ,) -> f64 > , pub GetItemFromPoint : Option < unsafe extern "C" fn (screen_x : :: std :: os :: raw :: c_int , screen_y : :: std :: os :: raw :: c_int , allow_locked : bool , takeOutOptional : * mut * mut root :: MediaItem_Take ,) -> * mut root :: MediaItem > , pub GetItemProjectContext : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> * mut root :: ReaProject > , pub GetItemStateChunk : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , strNeedBig : * mut :: std :: os :: raw :: c_char , strNeedBig_sz : :: std :: os :: raw :: c_int , isundoOptional : bool ,) -> bool > , pub GetLastColorThemeFile : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub GetLastMarkerAndCurRegion : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , time : f64 , markeridxOut : * mut :: std :: os :: raw :: c_int , regionidxOut : * mut :: std :: os :: raw :: c_int ,) > , pub GetLastTouchedFX : Option < unsafe extern "C" fn (tracknumberOut : * mut :: std :: os :: raw :: c_int , fxnumberOut : * mut :: std :: os :: raw :: c_int , paramnumberOut : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub GetLastTouchedTrack : Option < extern "C" fn () -> * mut root :: MediaTrack > , pub GetMainHwnd : Option < extern "C" fn () -> root :: HWND > , pub GetMasterMuteSoloFlags : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetMasterTrack : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> * mut root :: MediaTrack > , pub GetMasterTrackVisibility : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetMaxMidiInputs : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetMaxMidiOutputs : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetMediaFileMetadata : Option < unsafe extern "C" fn (mediaSource : * mut root :: PCM_source , identifier : * const :: std :: os :: raw :: c_char , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetMediaItem : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , itemidx : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaItem > , pub GetMediaItem_Track : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> * mut root :: MediaTrack > , pub GetMediaItemInfo_Value : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub GetMediaItemNumTakes : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> :: std :: os :: raw :: c_int > , pub GetMediaItemTake : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , tk : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaItem_Take > , pub GetMediaItemTake_Item : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> * mut root :: MediaItem > , pub GetMediaItemTake_Peaks : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , peakrate : f64 , starttime : f64 , numchannels : :: std :: os :: raw :: c_int , numsamplesperchannel : :: std :: os :: raw :: c_int , want_extra_type : :: std :: os :: raw :: c_int , buf : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub GetMediaItemTake_Source : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> * mut root :: PCM_source > , pub GetMediaItemTake_Track : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> * mut root :: MediaTrack > , pub GetMediaItemTakeByGUID : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , guid : * const root :: GUID ,) -> * mut root :: MediaItem_Take > , pub GetMediaItemTakeInfo_Value : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub GetMediaItemTrack : Option < unsafe extern "C" fn (item : * mut root :: MediaItem ,) -> * mut root :: MediaTrack > , pub GetMediaSourceFileName : Option < unsafe extern "C" fn (source : * mut root :: PCM_source , filenamebufOut : * mut :: std :: os :: raw :: c_char , filenamebufOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetMediaSourceLength : Option < unsafe extern "C" fn (source : * mut root :: PCM_source , lengthIsQNOut : * mut bool ,) -> f64 > , pub GetMediaSourceNumChannels : Option < unsafe extern "C" fn (source : * mut root :: PCM_source ,) -> :: std :: os :: raw :: c_int > , pub GetMediaSourceParent : Option < unsafe extern "C" fn (src : * mut root :: PCM_source ,) -> * mut root :: PCM_source > , pub GetMediaSourceSampleRate : Option < unsafe extern "C" fn (source : * mut root :: PCM_source ,) -> :: std :: os :: raw :: c_int > , pub GetMediaSourceType : Option < unsafe extern "C" fn (source : * mut root :: PCM_source , typebufOut : * mut :: std :: os :: raw :: c_char , typebufOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetMediaTrackInfo_Value : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub GetMIDIInputName : Option < unsafe extern "C" fn (dev : :: std :: os :: raw :: c_int , nameout : * mut :: std :: os :: raw :: c_char , nameout_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetMIDIOutputName : Option < unsafe extern "C" fn (dev : :: std :: os :: raw :: c_int , nameout : * mut :: std :: os :: raw :: c_char , nameout_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetMixerScroll : Option < extern "C" fn () -> * mut root :: MediaTrack > , pub GetMouseModifier : Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_char , modifier_flag : :: std :: os :: raw :: c_int , actionOut : * mut :: std :: os :: raw :: c_char , actionOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetMousePosition : Option < unsafe extern "C" fn (xOut : * mut :: std :: os :: raw :: c_int , yOut : * mut :: std :: os :: raw :: c_int ,) > , pub GetNumAudioInputs : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetNumAudioOutputs : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetNumMIDIInputs : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetNumMIDIOutputs : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetNumTakeMarkers : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> :: std :: os :: raw :: c_int > , pub GetNumTracks : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetOS : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub GetOutputChannelName : Option < extern "C" fn (channelIndex : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub GetOutputLatency : Option < extern "C" fn () -> f64 > , pub GetParentTrack : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> * mut root :: MediaTrack > , pub GetPeakFileName : Option < unsafe extern "C" fn (fn_ : * const :: std :: os :: raw :: c_char , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetPeakFileNameEx : Option < unsafe extern "C" fn (fn_ : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , forWrite : bool ,) > , pub GetPeakFileNameEx2 : Option < unsafe extern "C" fn (fn_ : * const :: std :: os :: raw :: c_char , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int , forWrite : bool , peaksfileextension : * const :: std :: os :: raw :: c_char ,) > , pub GetPeaksBitmap : Option < unsafe extern "C" fn (pks : * mut root :: PCM_source_peaktransfer_t , maxamp : f64 , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , bmp : * mut root :: reaper_functions :: LICE_IBitmap ,) -> * mut :: std :: os :: raw :: c_void > , pub GetPlayPosition : Option < extern "C" fn () -> f64 > , pub GetPlayPosition2 : Option < extern "C" fn () -> f64 > , pub GetPlayPosition2Ex : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) -> f64 > , pub GetPlayPositionEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) -> f64 > , pub GetPlayState : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub GetPlayStateEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub GetPreferredDiskReadMode : Option < unsafe extern "C" fn (mode : * mut :: std :: os :: raw :: c_int , nb : * mut :: std :: os :: raw :: c_int , bs : * mut :: std :: os :: raw :: c_int ,) > , pub GetPreferredDiskReadModePeak : Option < unsafe extern "C" fn (mode : * mut :: std :: os :: raw :: c_int , nb : * mut :: std :: os :: raw :: c_int , bs : * mut :: std :: os :: raw :: c_int ,) > , pub GetPreferredDiskWriteMode : Option < unsafe extern "C" fn (mode : * mut :: std :: os :: raw :: c_int , nb : * mut :: std :: os :: raw :: c_int , bs : * mut :: std :: os :: raw :: c_int ,) > , pub GetProjectLength : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) -> f64 > , pub GetProjectName : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetProjectPath : Option < unsafe extern "C" fn (bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetProjectPathEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) > , pub GetProjectStateChangeCount : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub GetProjectTimeOffset : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , rndframe : bool ,) -> f64 > , pub GetProjectTimeSignature : Option < unsafe extern "C" fn (bpmOut : * mut f64 , bpiOut : * mut f64) > , pub GetProjectTimeSignature2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , bpmOut : * mut f64 , bpiOut : * mut f64 ,) > , pub GetProjExtState : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , extname : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , valOutNeedBig : * mut :: std :: os :: raw :: c_char , valOutNeedBig_sz : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetResourcePath : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub GetSelectedEnvelope : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> * mut root :: TrackEnvelope > , pub GetSelectedMediaItem : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , selitem : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaItem > , pub GetSelectedTrack : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , seltrackidx : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaTrack > , pub GetSelectedTrack2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , seltrackidx : :: std :: os :: raw :: c_int , wantmaster : bool ,) -> * mut root :: MediaTrack > , pub GetSelectedTrackEnvelope : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> * mut root :: TrackEnvelope > , pub GetSet_ArrangeView2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , isSet : bool , screen_x_start : :: std :: os :: raw :: c_int , screen_x_end : :: std :: os :: raw :: c_int , start_timeInOut : * mut f64 , end_timeInOut : * mut f64 ,) > , pub GetSet_LoopTimeRange : Option < unsafe extern "C" fn (isSet : bool , isLoop : bool , startOut : * mut f64 , endOut : * mut f64 , allowautoseek : bool ,) > , pub GetSet_LoopTimeRange2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , isSet : bool , isLoop : bool , startOut : * mut f64 , endOut : * mut f64 , allowautoseek : bool ,) > , pub GetSetAutomationItemInfo : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , desc : * const :: std :: os :: raw :: c_char , value : f64 , is_set : bool ,) -> f64 > , pub GetSetAutomationItemInfo_String : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , desc : * const :: std :: os :: raw :: c_char , valuestrNeedBig : * mut :: std :: os :: raw :: c_char , is_set : bool ,) -> bool > , pub GetSetEnvelopeInfo_String : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool ,) -> bool > , pub GetSetEnvelopeState : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetSetEnvelopeState2 : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int , isundo : bool ,) -> bool > , pub GetSetItemState : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetSetItemState2 : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int , isundo : bool ,) -> bool > , pub GetSetMediaItemInfo : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void ,) -> * mut :: std :: os :: raw :: c_void > , pub GetSetMediaItemInfo_String : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool ,) -> bool > , pub GetSetMediaItemTakeInfo : Option < unsafe extern "C" fn (tk : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void ,) -> * mut :: std :: os :: raw :: c_void > , pub GetSetMediaItemTakeInfo_String : Option < unsafe extern "C" fn (tk : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool ,) -> bool > , pub GetSetMediaTrackInfo : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void ,) -> * mut :: std :: os :: raw :: c_void > , pub GetSetMediaTrackInfo_String : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool ,) -> bool > , pub GetSetObjectState : Option < unsafe extern "C" fn (obj : * mut :: std :: os :: raw :: c_void , str : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_char > , pub GetSetObjectState2 : Option < unsafe extern "C" fn (obj : * mut :: std :: os :: raw :: c_void , str : * const :: std :: os :: raw :: c_char , isundo : bool ,) -> * mut :: std :: os :: raw :: c_char > , pub GetSetProjectAuthor : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , set : bool , author : * mut :: std :: os :: raw :: c_char , author_sz : :: std :: os :: raw :: c_int ,) > , pub GetSetProjectGrid : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , set : bool , divisionInOutOptional : * mut f64 , swingmodeInOutOptional : * mut :: std :: os :: raw :: c_int , swingamtInOutOptional : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub GetSetProjectInfo : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , desc : * const :: std :: os :: raw :: c_char , value : f64 , is_set : bool ,) -> f64 > , pub GetSetProjectInfo_String : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , desc : * const :: std :: os :: raw :: c_char , valuestrNeedBig : * mut :: std :: os :: raw :: c_char , is_set : bool ,) -> bool > , pub GetSetProjectNotes : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , set : bool , notesNeedBig : * mut :: std :: os :: raw :: c_char , notesNeedBig_sz : :: std :: os :: raw :: c_int ,) > , pub GetSetRepeat : Option < extern "C" fn (val : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetSetRepeatEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , val : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetSetTrackGroupMembership : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , groupname : * const :: std :: os :: raw :: c_char , setmask : :: std :: os :: raw :: c_uint , setvalue : :: std :: os :: raw :: c_uint ,) -> :: std :: os :: raw :: c_uint > , pub GetSetTrackGroupMembershipHigh : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , groupname : * const :: std :: os :: raw :: c_char , setmask : :: std :: os :: raw :: c_uint , setvalue : :: std :: os :: raw :: c_uint ,) -> :: std :: os :: raw :: c_uint > , pub GetSetTrackMIDISupportFile : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , which : :: std :: os :: raw :: c_int , filename : * const :: std :: os :: raw :: c_char ,) -> * const :: std :: os :: raw :: c_char > , pub GetSetTrackSendInfo : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , setNewValue : * mut :: std :: os :: raw :: c_void ,) -> * mut :: std :: os :: raw :: c_void > , pub GetSetTrackSendInfo_String : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , stringNeedBig : * mut :: std :: os :: raw :: c_char , setNewValue : bool ,) -> bool > , pub GetSetTrackState : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetSetTrackState2 : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , str : * mut :: std :: os :: raw :: c_char , str_sz : :: std :: os :: raw :: c_int , isundo : bool ,) -> bool > , pub GetSubProjectFromSource : Option < unsafe extern "C" fn (src : * mut root :: PCM_source ,) -> * mut root :: ReaProject > , pub GetTake : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , takeidx : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaItem_Take > , pub GetTakeEnvelope : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , envidx : :: std :: os :: raw :: c_int ,) -> * mut root :: TrackEnvelope > , pub GetTakeEnvelopeByName : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , envname : * const :: std :: os :: raw :: c_char ,) -> * mut root :: TrackEnvelope > , pub GetTakeMarker : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , nameOut : * mut :: std :: os :: raw :: c_char , nameOut_sz : :: std :: os :: raw :: c_int , colorOutOptional : * mut :: std :: os :: raw :: c_int ,) -> f64 > , pub GetTakeName : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> * const :: std :: os :: raw :: c_char > , pub GetTakeNumStretchMarkers : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> :: std :: os :: raw :: c_int > , pub GetTakeStretchMarker : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , posOut : * mut f64 , srcposOutOptional : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub GetTakeStretchMarkerSlope : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int ,) -> f64 > , pub GetTCPFXParm : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , track : * mut root :: MediaTrack , index : :: std :: os :: raw :: c_int , fxindexOut : * mut :: std :: os :: raw :: c_int , parmidxOut : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub GetTempoMatchPlayRate : Option < unsafe extern "C" fn (source : * mut root :: PCM_source , srcscale : f64 , position : f64 , mult : f64 , rateOut : * mut f64 , targetlenOut : * mut f64 ,) -> bool > , pub GetTempoTimeSigMarker : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , ptidx : :: std :: os :: raw :: c_int , timeposOut : * mut f64 , measureposOut : * mut :: std :: os :: raw :: c_int , beatposOut : * mut f64 , bpmOut : * mut f64 , timesig_numOut : * mut :: std :: os :: raw :: c_int , timesig_denomOut : * mut :: std :: os :: raw :: c_int , lineartempoOut : * mut bool ,) -> bool > , pub GetThemeColor : Option < unsafe extern "C" fn (ini_key : * const :: std :: os :: raw :: c_char , flagsOptional : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetThingFromPoint : Option < unsafe extern "C" fn (screen_x : :: std :: os :: raw :: c_int , screen_y : :: std :: os :: raw :: c_int , infoOut : * mut :: std :: os :: raw :: c_char , infoOut_sz : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaTrack > , pub GetToggleCommandState : Option < extern "C" fn (command_id : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetToggleCommandState2 : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , command_id : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetToggleCommandStateEx : Option < extern "C" fn (section_id : :: std :: os :: raw :: c_int , command_id : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetToggleCommandStateThroughHooks : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , command_id : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetTooltipWindow : Option < extern "C" fn () -> root :: HWND > , pub GetTrack : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , trackidx : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaTrack > , pub GetTrackAutomationMode : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub GetTrackColor : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub GetTrackDepth : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub GetTrackEnvelope : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , envidx : :: std :: os :: raw :: c_int ,) -> * mut root :: TrackEnvelope > , pub GetTrackEnvelopeByChunkName : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , cfgchunkname_or_guid : * const :: std :: os :: raw :: c_char ,) -> * mut root :: TrackEnvelope > , pub GetTrackEnvelopeByName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , envname : * const :: std :: os :: raw :: c_char ,) -> * mut root :: TrackEnvelope > , pub GetTrackFromPoint : Option < unsafe extern "C" fn (screen_x : :: std :: os :: raw :: c_int , screen_y : :: std :: os :: raw :: c_int , infoOutOptional : * mut :: std :: os :: raw :: c_int ,) -> * mut root :: MediaTrack > , pub GetTrackGUID : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack ,) -> * mut root :: GUID > , pub GetTrackInfo : Option < unsafe extern "C" fn (track : root :: INT_PTR , flags : * mut :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub GetTrackMediaItem : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , itemidx : :: std :: os :: raw :: c_int ,) -> * mut root :: MediaItem > , pub GetTrackMIDILyrics : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , flag : :: std :: os :: raw :: c_int , bufOutWantNeedBig : * mut :: std :: os :: raw :: c_char , bufOutWantNeedBig_sz : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub GetTrackMIDINoteName : Option < extern "C" fn (track : :: std :: os :: raw :: c_int , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub GetTrackMIDINoteNameEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub GetTrackMIDINoteRange : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , note_loOut : * mut :: std :: os :: raw :: c_int , note_hiOut : * mut :: std :: os :: raw :: c_int ,) > , pub GetTrackName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetTrackNumMediaItems : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub GetTrackNumSends : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GetTrackReceiveName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetTrackReceiveUIMute : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , muteOut : * mut bool ,) -> bool > , pub GetTrackReceiveUIVolPan : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , recv_index : :: std :: os :: raw :: c_int , volumeOut : * mut f64 , panOut : * mut f64 ,) -> bool > , pub GetTrackSendInfo_Value : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub GetTrackSendName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GetTrackSendUIMute : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , muteOut : * mut bool ,) -> bool > , pub GetTrackSendUIVolPan : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , send_index : :: std :: os :: raw :: c_int , volumeOut : * mut f64 , panOut : * mut f64 ,) -> bool > , pub GetTrackState : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , flagsOut : * mut :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub GetTrackStateChunk : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , strNeedBig : * mut :: std :: os :: raw :: c_char , strNeedBig_sz : :: std :: os :: raw :: c_int , isundoOptional : bool ,) -> bool > , pub GetTrackUIMute : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , muteOut : * mut bool ,) -> bool > , pub GetTrackUIPan : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , pan1Out : * mut f64 , pan2Out : * mut f64 , panmodeOut : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub GetTrackUIVolPan : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , volumeOut : * mut f64 , panOut : * mut f64 ,) -> bool > , pub GetUnderrunTime : Option < unsafe extern "C" fn (audio_xrunOut : * mut :: std :: os :: raw :: c_uint , media_xrunOut : * mut :: std :: os :: raw :: c_uint , curtimeOut : * mut :: std :: os :: raw :: c_uint ,) > , pub GetUserFileNameForRead : Option < unsafe extern "C" fn (filenameNeed4096 : * mut :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char , defext : * const :: std :: os :: raw :: c_char ,) -> bool > , pub GetUserInputs : Option < unsafe extern "C" fn (title : * const :: std :: os :: raw :: c_char , num_inputs : :: std :: os :: raw :: c_int , captions_csv : * const :: std :: os :: raw :: c_char , retvals_csv : * mut :: std :: os :: raw :: c_char , retvals_csv_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub GoToMarker : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , marker_index : :: std :: os :: raw :: c_int , use_timeline_order : bool ,) > , pub GoToRegion : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , region_index : :: std :: os :: raw :: c_int , use_timeline_order : bool ,) > , pub GR_SelectColor : Option < unsafe extern "C" fn (hwnd : root :: HWND , colorOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub GSC_mainwnd : Option < extern "C" fn (t : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub guidToString : Option < unsafe extern "C" fn (g : * const root :: GUID , destNeed64 : * mut :: std :: os :: raw :: c_char ,) > , pub HasExtState : Option < unsafe extern "C" fn (section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char ,) -> bool > , pub HasTrackMIDIPrograms : Option < extern "C" fn (track : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub HasTrackMIDIProgramsEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , track : * mut root :: MediaTrack ,) -> * const :: std :: os :: raw :: c_char > , pub Help_Set : Option < unsafe extern "C" fn (helpstring : * const :: std :: os :: raw :: c_char , is_temporary_help : bool ,) > , pub HiresPeaksFromSource : Option < unsafe extern "C" fn (src : * mut root :: PCM_source , block : * mut root :: PCM_source_peaktransfer_t ,) > , pub image_resolve_fn : Option < unsafe extern "C" fn (in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int ,) > , pub InsertAutomationItem : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , pool_id : :: std :: os :: raw :: c_int , position : f64 , length : f64 ,) -> :: std :: os :: raw :: c_int > , pub InsertEnvelopePoint : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , time : f64 , value : f64 , shape : :: std :: os :: raw :: c_int , tension : f64 , selected : bool , noSortInOptional : * mut bool ,) -> bool > , pub InsertEnvelopePointEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , time : f64 , value : f64 , shape : :: std :: os :: raw :: c_int , tension : f64 , selected : bool , noSortInOptional : * mut bool ,) -> bool > , pub InsertMedia : Option < unsafe extern "C" fn (file : * const :: std :: os :: raw :: c_char , mode : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub InsertMediaSection : Option < unsafe extern "C" fn (file : * const :: std :: os :: raw :: c_char , mode : :: std :: os :: raw :: c_int , startpct : f64 , endpct : f64 , pitchshift : f64 ,) -> :: std :: os :: raw :: c_int > , pub InsertTrackAtIndex : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int , wantDefaults : bool ,) > , pub IsInRealTimeAudio : Option < extern "C" fn () -> :: std :: os :: raw :: c_int > , pub IsItemTakeActiveForPlayback : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , take : * mut root :: MediaItem_Take ,) -> bool > , pub IsMediaExtension : Option < unsafe extern "C" fn (ext : * const :: std :: os :: raw :: c_char , wantOthers : bool ,) -> bool > , pub IsMediaItemSelected : Option < unsafe extern "C" fn (item : * mut root :: MediaItem) -> bool > , pub IsProjectDirty : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub IsREAPER : Option < extern "C" fn () -> bool > , pub IsTrackSelected : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack) -> bool > , pub IsTrackVisible : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , mixer : bool ,) -> bool > , pub joystick_create : Option < unsafe extern "C" fn (guid : * const root :: GUID) -> * mut root :: reaper_functions :: joystick_device > , pub joystick_destroy : Option < unsafe extern "C" fn (device : * mut root :: reaper_functions :: joystick_device ,) > , pub joystick_enum : Option < unsafe extern "C" fn (index : :: std :: os :: raw :: c_int , namestrOutOptional : * mut * const :: std :: os :: raw :: c_char ,) -> * const :: std :: os :: raw :: c_char > , pub joystick_getaxis : Option < unsafe extern "C" fn (dev : * mut root :: reaper_functions :: joystick_device , axis : :: std :: os :: raw :: c_int ,) -> f64 > , pub joystick_getbuttonmask : Option < unsafe extern "C" fn (dev : * mut root :: reaper_functions :: joystick_device ,) -> :: std :: os :: raw :: c_uint > , pub joystick_getinfo : Option < unsafe extern "C" fn (dev : * mut root :: reaper_functions :: joystick_device , axesOutOptional : * mut :: std :: os :: raw :: c_int , povsOutOptional : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub joystick_getpov : Option < unsafe extern "C" fn (dev : * mut root :: reaper_functions :: joystick_device , pov : :: std :: os :: raw :: c_int ,) -> f64 > , pub joystick_update : Option < unsafe extern "C" fn (dev : * mut root :: reaper_functions :: joystick_device ,) -> bool > , pub kbd_enumerateActions : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , idx : :: std :: os :: raw :: c_int , nameOut : * mut * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub kbd_formatKeyName : Option < unsafe extern "C" fn (ac : * mut root :: ACCEL , s : * mut :: std :: os :: raw :: c_char ,) > , pub kbd_getCommandName : Option < unsafe extern "C" fn (cmd : :: std :: os :: raw :: c_int , s : * mut :: std :: os :: raw :: c_char , section : * mut root :: KbdSectionInfo ,) > , pub kbd_getTextFromCmd : Option < unsafe extern "C" fn (cmd : :: std :: os :: raw :: c_int , section : * mut root :: KbdSectionInfo ,) -> * const :: std :: os :: raw :: c_char > , pub KBD_OnMainActionEx : Option < unsafe extern "C" fn (cmd : :: std :: os :: raw :: c_int , val : :: std :: os :: raw :: c_int , valhw : :: std :: os :: raw :: c_int , relmode : :: std :: os :: raw :: c_int , hwnd : root :: HWND , proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub kbd_OnMidiEvent : Option < unsafe extern "C" fn (evt : * mut root :: MIDI_event_t , dev_index : :: std :: os :: raw :: c_int ,) > , pub kbd_OnMidiList : Option < unsafe extern "C" fn (list : * mut root :: MIDI_eventlist , dev_index : :: std :: os :: raw :: c_int ,) > , pub kbd_ProcessActionsMenu : Option < unsafe extern "C" fn (menu : root :: HMENU , section : * mut root :: KbdSectionInfo ,) > , pub kbd_processMidiEventActionEx : Option < unsafe extern "C" fn (evt : * mut root :: MIDI_event_t , section : * mut root :: KbdSectionInfo , hwndCtx : root :: HWND ,) -> bool > , pub kbd_reprocessMenu : Option < unsafe extern "C" fn (menu : root :: HMENU , section : * mut root :: KbdSectionInfo ,) > , pub kbd_RunCommandThroughHooks : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , actionCommandID : * const :: std :: os :: raw :: c_int , val : * const :: std :: os :: raw :: c_int , valhw : * const :: std :: os :: raw :: c_int , relmode : * const :: std :: os :: raw :: c_int , hwnd : root :: HWND ,) -> bool > , pub kbd_translateAccelerator : Option < unsafe extern "C" fn (hwnd : root :: HWND , msg : * mut root :: MSG , section : * mut root :: KbdSectionInfo ,) -> :: std :: os :: raw :: c_int > , pub kbd_translateMouse : Option < unsafe extern "C" fn (winmsg : * mut :: std :: os :: raw :: c_void , midimsg : * mut :: std :: os :: raw :: c_uchar ,) -> bool > , pub LICE__Destroy : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) > , pub LICE__DestroyFont : Option < unsafe extern "C" fn (font : * mut root :: reaper_functions :: LICE_IFont ,) > , pub LICE__DrawText : Option < unsafe extern "C" fn (font : * mut root :: reaper_functions :: LICE_IFont , bm : * mut root :: reaper_functions :: LICE_IBitmap , str : * const :: std :: os :: raw :: c_char , strcnt : :: std :: os :: raw :: c_int , rect : * mut root :: RECT , dtFlags : root :: UINT ,) -> :: std :: os :: raw :: c_int > , pub LICE__GetBits : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) -> * mut :: std :: os :: raw :: c_void > , pub LICE__GetDC : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) -> root :: HDC > , pub LICE__GetHeight : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) -> :: std :: os :: raw :: c_int > , pub LICE__GetRowSpan : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) -> :: std :: os :: raw :: c_int > , pub LICE__GetWidth : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) -> :: std :: os :: raw :: c_int > , pub LICE__IsFlipped : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap ,) -> bool > , pub LICE__resize : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int ,) -> bool > , pub LICE__SetBkColor : Option < unsafe extern "C" fn (font : * mut root :: reaper_functions :: LICE_IFont , color : root :: reaper_functions :: LICE_pixel ,) -> root :: reaper_functions :: LICE_pixel > , pub LICE__SetFromHFont : Option < unsafe extern "C" fn (font : * mut root :: reaper_functions :: LICE_IFont , hfont : root :: HFONT , flags : :: std :: os :: raw :: c_int ,) > , pub LICE__SetTextColor : Option < unsafe extern "C" fn (font : * mut root :: reaper_functions :: LICE_IFont , color : root :: reaper_functions :: LICE_pixel ,) -> root :: reaper_functions :: LICE_pixel > , pub LICE__SetTextCombineMode : Option < unsafe extern "C" fn (ifont : * mut root :: reaper_functions :: LICE_IFont , mode : :: std :: os :: raw :: c_int , alpha : f32 ,) > , pub LICE_Arc : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , cx : f32 , cy : f32 , r : f32 , minAngle : f32 , maxAngle : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool ,) > , pub LICE_Blit : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , srcx : :: std :: os :: raw :: c_int , srcy : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_Blur : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , srcx : :: std :: os :: raw :: c_int , srcy : :: std :: os :: raw :: c_int , srcw : :: std :: os :: raw :: c_int , srch : :: std :: os :: raw :: c_int ,) > , pub LICE_BorderedRect : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , bgcolor : root :: reaper_functions :: LICE_pixel , fgcolor : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_Circle : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , cx : f32 , cy : f32 , r : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool ,) > , pub LICE_Clear : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , color : root :: reaper_functions :: LICE_pixel ,) > , pub LICE_ClearRect : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , mask : root :: reaper_functions :: LICE_pixel , orbits : root :: reaper_functions :: LICE_pixel ,) > , pub LICE_ClipLine : Option < unsafe extern "C" fn (pX1Out : * mut :: std :: os :: raw :: c_int , pY1Out : * mut :: std :: os :: raw :: c_int , pX2Out : * mut :: std :: os :: raw :: c_int , pY2Out : * mut :: std :: os :: raw :: c_int , xLo : :: std :: os :: raw :: c_int , yLo : :: std :: os :: raw :: c_int , xHi : :: std :: os :: raw :: c_int , yHi : :: std :: os :: raw :: c_int ,) -> bool > , pub LICE_Copy : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap ,) > , pub LICE_CreateBitmap : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int) -> * mut root :: reaper_functions :: LICE_IBitmap > , pub LICE_CreateFont : Option < extern "C" fn () -> * mut root :: reaper_functions :: LICE_IFont > , pub LICE_DrawCBezier : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , xstart : f64 , ystart : f64 , xctl1 : f64 , yctl1 : f64 , xctl2 : f64 , yctl2 : f64 , xend : f64 , yend : f64 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool , tol : f64 ,) > , pub LICE_DrawChar : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , c : :: std :: os :: raw :: c_char , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_DrawGlyph : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alphas : * mut root :: reaper_functions :: LICE_pixel_chan , glyph_w : :: std :: os :: raw :: c_int , glyph_h : :: std :: os :: raw :: c_int , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_DrawRect : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_DrawText : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , string : * const :: std :: os :: raw :: c_char , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_FillCBezier : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , xstart : f64 , ystart : f64 , xctl1 : f64 , yctl1 : f64 , xctl2 : f64 , yctl2 : f64 , xend : f64 , yend : f64 , yfill : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool , tol : f64 ,) > , pub LICE_FillCircle : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , cx : f32 , cy : f32 , r : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool ,) > , pub LICE_FillConvexPolygon : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : * mut :: std :: os :: raw :: c_int , y : * mut :: std :: os :: raw :: c_int , npoints : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_FillRect : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_FillTrapezoid : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x1a : :: std :: os :: raw :: c_int , x1b : :: std :: os :: raw :: c_int , y1 : :: std :: os :: raw :: c_int , x2a : :: std :: os :: raw :: c_int , x2b : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_FillTriangle : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : :: std :: os :: raw :: c_int , y1 : :: std :: os :: raw :: c_int , x2 : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , x3 : :: std :: os :: raw :: c_int , y3 : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_GetPixel : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int ,) -> root :: reaper_functions :: LICE_pixel > , pub LICE_GradRect : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , dstw : :: std :: os :: raw :: c_int , dsth : :: std :: os :: raw :: c_int , ir : f32 , ig : f32 , ib : f32 , ia : f32 , drdx : f32 , dgdx : f32 , dbdx : f32 , dadx : f32 , drdy : f32 , dgdy : f32 , dbdy : f32 , dady : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_Line : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : f32 , y1 : f32 , x2 : f32 , y2 : f32 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool ,) > , pub LICE_LineInt : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : :: std :: os :: raw :: c_int , y1 : :: std :: os :: raw :: c_int , x2 : :: std :: os :: raw :: c_int , y2 : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool ,) > , pub LICE_LoadPNG : Option < unsafe extern "C" fn (filename : * const :: std :: os :: raw :: c_char , bmp : * mut root :: reaper_functions :: LICE_IBitmap) -> * mut root :: reaper_functions :: LICE_IBitmap > , pub LICE_LoadPNGFromResource : Option < unsafe extern "C" fn (hInst : root :: HINSTANCE , resid : * const :: std :: os :: raw :: c_char , bmp : * mut root :: reaper_functions :: LICE_IBitmap) -> * mut root :: reaper_functions :: LICE_IBitmap > , pub LICE_MeasureText : Option < unsafe extern "C" fn (string : * const :: std :: os :: raw :: c_char , w : * mut :: std :: os :: raw :: c_int , h : * mut :: std :: os :: raw :: c_int ,) > , pub LICE_MultiplyAddRect : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , w : :: std :: os :: raw :: c_int , h : :: std :: os :: raw :: c_int , rsc : f32 , gsc : f32 , bsc : f32 , asc : f32 , radd : f32 , gadd : f32 , badd : f32 , aadd : f32 ,) > , pub LICE_PutPixel : Option < unsafe extern "C" fn (bm : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_RotatedBlit : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , dstw : :: std :: os :: raw :: c_int , dsth : :: std :: os :: raw :: c_int , srcx : f32 , srcy : f32 , srcw : f32 , srch : f32 , angle : f32 , cliptosourcerect : bool , alpha : f32 , mode : :: std :: os :: raw :: c_int , rotxcent : f32 , rotycent : f32 ,) > , pub LICE_RoundRect : Option < unsafe extern "C" fn (drawbm : * mut root :: reaper_functions :: LICE_IBitmap , xpos : f32 , ypos : f32 , w : f32 , h : f32 , cornerradius : :: std :: os :: raw :: c_int , col : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , aa : bool ,) > , pub LICE_ScaledBlit : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: LICE_IBitmap , dstx : :: std :: os :: raw :: c_int , dsty : :: std :: os :: raw :: c_int , dstw : :: std :: os :: raw :: c_int , dsth : :: std :: os :: raw :: c_int , srcx : f32 , srcy : f32 , srcw : f32 , srch : f32 , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) > , pub LICE_SimpleFill : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , newcolor : root :: reaper_functions :: LICE_pixel , comparemask : root :: reaper_functions :: LICE_pixel , keepmask : root :: reaper_functions :: LICE_pixel ,) > , pub LICE_ThickFLine : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , x1 : f64 , y1 : f64 , x2 : f64 , y2 : f64 , color : root :: reaper_functions :: LICE_pixel , alpha : f32 , mode : :: std :: os :: raw :: c_int , wid : :: std :: os :: raw :: c_int ,) > , pub LocalizeString : Option < unsafe extern "C" fn (src_string : * const :: std :: os :: raw :: c_char , section : * const :: std :: os :: raw :: c_char , flagsOptional : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub Loop_OnArrow : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , direction : :: std :: os :: raw :: c_int ,) -> bool > , pub Main_OnCommand : Option < extern "C" fn (command : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int ,) > , pub Main_OnCommandEx : Option < unsafe extern "C" fn (command : :: std :: os :: raw :: c_int , flag : :: std :: os :: raw :: c_int , proj : * mut root :: ReaProject ,) > , pub Main_openProject : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char) > , pub Main_SaveProject : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , forceSaveAsInOptional : bool ,) > , pub Main_SaveProjectEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , filename : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int ,) > , pub Main_UpdateLoopInfo : Option < extern "C" fn (ignoremask : :: std :: os :: raw :: c_int) > , pub MarkProjectDirty : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) > , pub MarkTrackItemsDirty : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , item : * mut root :: MediaItem ,) > , pub Master_GetPlayRate : Option < unsafe extern "C" fn (project : * mut root :: ReaProject) -> f64 > , pub Master_GetPlayRateAtTime : Option < unsafe extern "C" fn (time_s : f64 , proj : * mut root :: ReaProject ,) -> f64 > , pub Master_GetTempo : Option < extern "C" fn () -> f64 > , pub Master_NormalizePlayRate : Option < extern "C" fn (playrate : f64 , isnormalized : bool) -> f64 > , pub Master_NormalizeTempo : Option < extern "C" fn (bpm : f64 , isnormalized : bool) -> f64 > , pub MB : Option < unsafe extern "C" fn (msg : * const :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MediaItemDescendsFromTrack : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub MIDI_CountEvts : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , notecntOut : * mut :: std :: os :: raw :: c_int , ccevtcntOut : * mut :: std :: os :: raw :: c_int , textsyxevtcntOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MIDI_DeleteCC : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_DeleteEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_DeleteNote : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_DeleteTextSysexEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , textsyxevtidx : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_DisableSort : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take) > , pub MIDI_EnumSelCC : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MIDI_EnumSelEvts : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MIDI_EnumSelNotes : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MIDI_EnumSelTextSysexEvts : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , textsyxidx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MIDI_eventlist_Create : Option < extern "C" fn () -> * mut root :: MIDI_eventlist > , pub MIDI_eventlist_Destroy : Option < unsafe extern "C" fn (evtlist : * mut root :: MIDI_eventlist) > , pub MIDI_GetAllEvts : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetCC : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , selectedOut : * mut bool , mutedOut : * mut bool , ppqposOut : * mut f64 , chanmsgOut : * mut :: std :: os :: raw :: c_int , chanOut : * mut :: std :: os :: raw :: c_int , msg2Out : * mut :: std :: os :: raw :: c_int , msg3Out : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetCCShape : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , shapeOut : * mut :: std :: os :: raw :: c_int , beztensionOut : * mut f64 ,) -> bool > , pub MIDI_GetEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int , selectedOut : * mut bool , mutedOut : * mut bool , ppqposOut : * mut f64 , msgOut : * mut :: std :: os :: raw :: c_char , msgOut_sz : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetGrid : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , swingOutOptional : * mut f64 , noteLenOutOptional : * mut f64 ,) -> f64 > , pub MIDI_GetHash : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , notesonly : bool , hashOut : * mut :: std :: os :: raw :: c_char , hashOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetNote : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int , selectedOut : * mut bool , mutedOut : * mut bool , startppqposOut : * mut f64 , endppqposOut : * mut f64 , chanOut : * mut :: std :: os :: raw :: c_int , pitchOut : * mut :: std :: os :: raw :: c_int , velOut : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetPPQPos_EndOfMeasure : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ppqpos : f64 ,) -> f64 > , pub MIDI_GetPPQPos_StartOfMeasure : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ppqpos : f64 ,) -> f64 > , pub MIDI_GetPPQPosFromProjQN : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , projqn : f64 ,) -> f64 > , pub MIDI_GetPPQPosFromProjTime : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , projtime : f64 ,) -> f64 > , pub MIDI_GetProjQNFromPPQPos : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ppqpos : f64 ,) -> f64 > , pub MIDI_GetProjTimeFromPPQPos : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ppqpos : f64 ,) -> f64 > , pub MIDI_GetRecentInputEvent : Option < unsafe extern "C" fn (idx : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : * mut :: std :: os :: raw :: c_int , tsOut : * mut :: std :: os :: raw :: c_int , devIdxOut : * mut :: std :: os :: raw :: c_int , projPosOut : * mut f64 , projLoopCntOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub MIDI_GetScale : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , rootOut : * mut :: std :: os :: raw :: c_int , scaleOut : * mut :: std :: os :: raw :: c_int , nameOut : * mut :: std :: os :: raw :: c_char , nameOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetTextSysexEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , textsyxevtidx : :: std :: os :: raw :: c_int , selectedOutOptional : * mut bool , mutedOutOptional : * mut bool , ppqposOutOptional : * mut f64 , typeOutOptional : * mut :: std :: os :: raw :: c_int , msgOptional : * mut :: std :: os :: raw :: c_char , msgOptional_sz : * mut :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_GetTrackHash : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , notesonly : bool , hashOut : * mut :: std :: os :: raw :: c_char , hashOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub midi_init : Option < extern "C" fn (force_reinit_input : :: std :: os :: raw :: c_int , force_reinit_output : :: std :: os :: raw :: c_int ,) > , pub MIDI_InsertCC : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , selected : bool , muted : bool , ppqpos : f64 , chanmsg : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int , msg2 : :: std :: os :: raw :: c_int , msg3 : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_InsertEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , selected : bool , muted : bool , ppqpos : f64 , bytestr : * const :: std :: os :: raw :: c_char , bytestr_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_InsertNote : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , selected : bool , muted : bool , startppqpos : f64 , endppqpos : f64 , chan : :: std :: os :: raw :: c_int , pitch : :: std :: os :: raw :: c_int , vel : :: std :: os :: raw :: c_int , noSortInOptional : * const bool ,) -> bool > , pub MIDI_InsertTextSysexEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , selected : bool , muted : bool , ppqpos : f64 , type_ : :: std :: os :: raw :: c_int , bytestr : * const :: std :: os :: raw :: c_char , bytestr_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub midi_reinit : Option < extern "C" fn () > , pub MIDI_SelectAll : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , select : bool ,) > , pub MIDI_SetAllEvts : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , buf : * const :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDI_SetCC : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , ppqposInOptional : * const f64 , chanmsgInOptional : * const :: std :: os :: raw :: c_int , chanInOptional : * const :: std :: os :: raw :: c_int , msg2InOptional : * const :: std :: os :: raw :: c_int , msg3InOptional : * const :: std :: os :: raw :: c_int , noSortInOptional : * const bool ,) -> bool > , pub MIDI_SetCCShape : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , ccidx : :: std :: os :: raw :: c_int , shape : :: std :: os :: raw :: c_int , beztension : f64 , noSortInOptional : * const bool ,) -> bool > , pub MIDI_SetEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , evtidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , ppqposInOptional : * const f64 , msgOptional : * const :: std :: os :: raw :: c_char , msgOptional_sz : :: std :: os :: raw :: c_int , noSortInOptional : * const bool ,) -> bool > , pub MIDI_SetItemExtents : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , startQN : f64 , endQN : f64 ,) -> bool > , pub MIDI_SetNote : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , noteidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , startppqposInOptional : * const f64 , endppqposInOptional : * const f64 , chanInOptional : * const :: std :: os :: raw :: c_int , pitchInOptional : * const :: std :: os :: raw :: c_int , velInOptional : * const :: std :: os :: raw :: c_int , noSortInOptional : * const bool ,) -> bool > , pub MIDI_SetTextSysexEvt : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , textsyxevtidx : :: std :: os :: raw :: c_int , selectedInOptional : * const bool , mutedInOptional : * const bool , ppqposInOptional : * const f64 , typeInOptional : * const :: std :: os :: raw :: c_int , msgOptional : * const :: std :: os :: raw :: c_char , msgOptional_sz : :: std :: os :: raw :: c_int , noSortInOptional : * const bool ,) -> bool > , pub MIDI_Sort : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take) > , pub MIDIEditor_EnumTakes : Option < unsafe extern "C" fn (midieditor : root :: HWND , takeindex : :: std :: os :: raw :: c_int , editable_only : bool ,) -> * mut root :: MediaItem_Take > , pub MIDIEditor_GetActive : Option < extern "C" fn () -> root :: HWND > , pub MIDIEditor_GetMode : Option < unsafe extern "C" fn (midieditor : root :: HWND ,) -> :: std :: os :: raw :: c_int > , pub MIDIEditor_GetSetting_int : Option < unsafe extern "C" fn (midieditor : root :: HWND , setting_desc : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub MIDIEditor_GetSetting_str : Option < unsafe extern "C" fn (midieditor : root :: HWND , setting_desc : * const :: std :: os :: raw :: c_char , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDIEditor_GetTake : Option < unsafe extern "C" fn (midieditor : root :: HWND ,) -> * mut root :: MediaItem_Take > , pub MIDIEditor_LastFocused_OnCommand : Option < extern "C" fn (command_id : :: std :: os :: raw :: c_int , islistviewcommand : bool ,) -> bool > , pub MIDIEditor_OnCommand : Option < unsafe extern "C" fn (midieditor : root :: HWND , command_id : :: std :: os :: raw :: c_int ,) -> bool > , pub MIDIEditor_SetSetting_int : Option < unsafe extern "C" fn (midieditor : root :: HWND , setting_desc : * const :: std :: os :: raw :: c_char , setting : :: std :: os :: raw :: c_int ,) -> bool > , pub mkpanstr : Option < unsafe extern "C" fn (strNeed64 : * mut :: std :: os :: raw :: c_char , pan : f64 ,) > , pub mkvolpanstr : Option < unsafe extern "C" fn (strNeed64 : * mut :: std :: os :: raw :: c_char , vol : f64 , pan : f64 ,) > , pub mkvolstr : Option < unsafe extern "C" fn (strNeed64 : * mut :: std :: os :: raw :: c_char , vol : f64 ,) > , pub MoveEditCursor : Option < extern "C" fn (adjamt : f64 , dosel : bool) > , pub MoveMediaItemToTrack : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , desttr : * mut root :: MediaTrack ,) -> bool > , pub MuteAllTracks : Option < extern "C" fn (mute : bool) > , pub my_getViewport : Option < unsafe extern "C" fn (r : * mut root :: RECT , sr : * const root :: RECT , wantWorkArea : bool ,) > , pub NamedCommandLookup : Option < unsafe extern "C" fn (command_name : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub OnPauseButton : Option < extern "C" fn () > , pub OnPauseButtonEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) > , pub OnPlayButton : Option < extern "C" fn () > , pub OnPlayButtonEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) > , pub OnStopButton : Option < extern "C" fn () > , pub OnStopButtonEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) > , pub OpenColorThemeFile : Option < unsafe extern "C" fn (fn_ : * const :: std :: os :: raw :: c_char ,) -> bool > , pub OpenMediaExplorer : Option < unsafe extern "C" fn (mediafn : * const :: std :: os :: raw :: c_char , play : bool ,) -> root :: HWND > , pub OscLocalMessageToHost : Option < unsafe extern "C" fn (message : * const :: std :: os :: raw :: c_char , valueInOptional : * const f64 ,) > , pub parse_timestr : Option < unsafe extern "C" fn (buf : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub parse_timestr_len : Option < unsafe extern "C" fn (buf : * const :: std :: os :: raw :: c_char , offset : f64 , modeoverride : :: std :: os :: raw :: c_int ,) -> f64 > , pub parse_timestr_pos : Option < unsafe extern "C" fn (buf : * const :: std :: os :: raw :: c_char , modeoverride : :: std :: os :: raw :: c_int ,) -> f64 > , pub parsepanstr : Option < unsafe extern "C" fn (str : * const :: std :: os :: raw :: c_char ,) -> f64 > , pub PCM_Sink_Create : Option < unsafe extern "C" fn (filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int , srate : :: std :: os :: raw :: c_int , buildpeaks : bool ,) -> * mut root :: PCM_sink > , pub PCM_Sink_CreateEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int , srate : :: std :: os :: raw :: c_int , buildpeaks : bool ,) -> * mut root :: PCM_sink > , pub PCM_Sink_CreateMIDIFile : Option < unsafe extern "C" fn (filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , bpm : f64 , div : :: std :: os :: raw :: c_int ,) -> * mut root :: PCM_sink > , pub PCM_Sink_CreateMIDIFileEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , filename : * const :: std :: os :: raw :: c_char , cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , bpm : f64 , div : :: std :: os :: raw :: c_int ,) -> * mut root :: PCM_sink > , pub PCM_Sink_Enum : Option < unsafe extern "C" fn (idx : :: std :: os :: raw :: c_int , descstrOut : * mut * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_uint > , pub PCM_Sink_GetExtension : Option < unsafe extern "C" fn (data : * const :: std :: os :: raw :: c_char , data_sz : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub PCM_Sink_ShowConfig : Option < unsafe extern "C" fn (cfg : * const :: std :: os :: raw :: c_char , cfg_sz : :: std :: os :: raw :: c_int , hwndParent : root :: HWND ,) -> root :: HWND > , pub PCM_Source_BuildPeaks : Option < unsafe extern "C" fn (src : * mut root :: PCM_source , mode : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub PCM_Source_CreateFromFile : Option < unsafe extern "C" fn (filename : * const :: std :: os :: raw :: c_char ,) -> * mut root :: PCM_source > , pub PCM_Source_CreateFromFileEx : Option < unsafe extern "C" fn (filename : * const :: std :: os :: raw :: c_char , forcenoMidiImp : bool ,) -> * mut root :: PCM_source > , pub PCM_Source_CreateFromSimple : Option < unsafe extern "C" fn (dec : * mut root :: ISimpleMediaDecoder , fn_ : * const :: std :: os :: raw :: c_char ,) -> * mut root :: PCM_source > , pub PCM_Source_CreateFromType : Option < unsafe extern "C" fn (sourcetype : * const :: std :: os :: raw :: c_char ,) -> * mut root :: PCM_source > , pub PCM_Source_Destroy : Option < unsafe extern "C" fn (src : * mut root :: PCM_source) > , pub PCM_Source_GetPeaks : Option < unsafe extern "C" fn (src : * mut root :: PCM_source , peakrate : f64 , starttime : f64 , numchannels : :: std :: os :: raw :: c_int , numsamplesperchannel : :: std :: os :: raw :: c_int , want_extra_type : :: std :: os :: raw :: c_int , buf : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub PCM_Source_GetSectionInfo : Option < unsafe extern "C" fn (src : * mut root :: PCM_source , offsOut : * mut f64 , lenOut : * mut f64 , revOut : * mut bool ,) -> bool > , pub PeakBuild_Create : Option < unsafe extern "C" fn (src : * mut root :: PCM_source , fn_ : * const :: std :: os :: raw :: c_char , srate : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int ,) -> * mut root :: REAPER_PeakBuild_Interface > , pub PeakBuild_CreateEx : Option < unsafe extern "C" fn (src : * mut root :: PCM_source , fn_ : * const :: std :: os :: raw :: c_char , srate : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> * mut root :: REAPER_PeakBuild_Interface > , pub PeakGet_Create : Option < unsafe extern "C" fn (fn_ : * const :: std :: os :: raw :: c_char , srate : :: std :: os :: raw :: c_int , nch : :: std :: os :: raw :: c_int ,) -> * mut root :: REAPER_PeakGet_Interface > , pub PitchShiftSubModeMenu : Option < unsafe extern "C" fn (hwnd : root :: HWND , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , mode : :: std :: os :: raw :: c_int , submode_sel : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub PlayPreview : Option < unsafe extern "C" fn (preview : * mut root :: preview_register_t ,) -> :: std :: os :: raw :: c_int > , pub PlayPreviewEx : Option < unsafe extern "C" fn (preview : * mut root :: preview_register_t , bufflags : :: std :: os :: raw :: c_int , measure_align : f64 ,) -> :: std :: os :: raw :: c_int > , pub PlayTrackPreview : Option < unsafe extern "C" fn (preview : * mut root :: preview_register_t ,) -> :: std :: os :: raw :: c_int > , pub PlayTrackPreview2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , preview : * mut root :: preview_register_t ,) -> :: std :: os :: raw :: c_int > , pub PlayTrackPreview2Ex : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , preview : * mut root :: preview_register_t , flags : :: std :: os :: raw :: c_int , measure_align : f64 ,) -> :: std :: os :: raw :: c_int > , pub plugin_getapi : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_void > , pub plugin_getFilterList : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub plugin_getImportableProjectFilterList : Option < extern "C" fn () -> * const :: std :: os :: raw :: c_char > , pub plugin_register : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , infostruct : * mut :: std :: os :: raw :: c_void ,) -> :: std :: os :: raw :: c_int > , pub PluginWantsAlwaysRunFx : Option < extern "C" fn (amt : :: std :: os :: raw :: c_int) > , pub PreventUIRefresh : Option < extern "C" fn (prevent_count : :: std :: os :: raw :: c_int) > , pub projectconfig_var_addr : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , idx : :: std :: os :: raw :: c_int ,) -> * mut :: std :: os :: raw :: c_void > , pub projectconfig_var_getoffs : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , szOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub PromptForAction : Option < extern "C" fn (session_mode : :: std :: os :: raw :: c_int , init_id : :: std :: os :: raw :: c_int , section_id : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub realloc_cmd_clear : Option < extern "C" fn (tok : :: std :: os :: raw :: c_int) > , pub realloc_cmd_ptr : Option < unsafe extern "C" fn (ptr : * mut * mut :: std :: os :: raw :: c_char , ptr_size : * mut :: std :: os :: raw :: c_int , new_size : :: std :: os :: raw :: c_int ,) -> bool > , pub realloc_cmd_register_buf : Option < unsafe extern "C" fn (ptr : * mut * mut :: std :: os :: raw :: c_char , ptr_size : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub ReaperGetPitchShiftAPI : Option < extern "C" fn (version : :: std :: os :: raw :: c_int ,) -> * mut root :: IReaperPitchShift > , pub ReaScriptError : Option < unsafe extern "C" fn (errmsg : * const :: std :: os :: raw :: c_char) > , pub RecursiveCreateDirectory : Option < unsafe extern "C" fn (path : * const :: std :: os :: raw :: c_char , ignored : usize ,) -> :: std :: os :: raw :: c_int > , pub reduce_open_files : Option < extern "C" fn (flags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub RefreshToolbar : Option < extern "C" fn (command_id : :: std :: os :: raw :: c_int) > , pub RefreshToolbar2 : Option < extern "C" fn (section_id : :: std :: os :: raw :: c_int , command_id : :: std :: os :: raw :: c_int ,) > , pub relative_fn : Option < unsafe extern "C" fn (in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int ,) > , pub RemoveTrackSend : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int ,) -> bool > , pub RenderFileSection : Option < unsafe extern "C" fn (source_filename : * const :: std :: os :: raw :: c_char , target_filename : * const :: std :: os :: raw :: c_char , start_percent : f64 , end_percent : f64 , playrate : f64 ,) -> bool > , pub ReorderSelectedTracks : Option < extern "C" fn (beforeTrackIdx : :: std :: os :: raw :: c_int , makePrevFolder : :: std :: os :: raw :: c_int ,) -> bool > , pub Resample_EnumModes : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub Resampler_Create : Option < extern "C" fn () -> * mut root :: REAPER_Resample_Interface > , pub resolve_fn : Option < unsafe extern "C" fn (in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int ,) > , pub resolve_fn2 : Option < unsafe extern "C" fn (in_ : * const :: std :: os :: raw :: c_char , out : * mut :: std :: os :: raw :: c_char , out_sz : :: std :: os :: raw :: c_int , checkSubDirOptional : * const :: std :: os :: raw :: c_char ,) > , pub ResolveRenderPattern : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , path : * const :: std :: os :: raw :: c_char , pattern : * const :: std :: os :: raw :: c_char , targets : * mut :: std :: os :: raw :: c_char , targets_sz : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub ReverseNamedCommandLookup : Option < extern "C" fn (command_id : :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub ScaleFromEnvelopeMode : Option < extern "C" fn (scaling_mode : :: std :: os :: raw :: c_int , val : f64 ,) -> f64 > , pub ScaleToEnvelopeMode : Option < extern "C" fn (scaling_mode : :: std :: os :: raw :: c_int , val : f64 ,) -> f64 > , pub screenset_register : Option < unsafe extern "C" fn (id : * mut :: std :: os :: raw :: c_char , callbackFunc : * mut :: std :: os :: raw :: c_void , param : * mut :: std :: os :: raw :: c_void ,) > , pub screenset_registerNew : Option < unsafe extern "C" fn (id : * mut :: std :: os :: raw :: c_char , callbackFunc : root :: screensetNewCallbackFunc , param : * mut :: std :: os :: raw :: c_void ,) > , pub screenset_unregister : Option < unsafe extern "C" fn (id : * mut :: std :: os :: raw :: c_char) > , pub screenset_unregisterByParam : Option < unsafe extern "C" fn (param : * mut :: std :: os :: raw :: c_void) > , pub screenset_updateLastFocus : Option < unsafe extern "C" fn (prevWin : root :: HWND) > , pub SectionFromUniqueID : Option < extern "C" fn (uniqueID : :: std :: os :: raw :: c_int ,) -> * mut root :: KbdSectionInfo > , pub SelectAllMediaItems : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , selected : bool ,) > , pub SelectProjectInstance : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) > , pub SendLocalOscMessage : Option < unsafe extern "C" fn (local_osc_handler : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , msglen : :: std :: os :: raw :: c_int ,) > , pub SetActiveTake : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take) > , pub SetAutomationMode : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int , onlySel : bool ,) > , pub SetCurrentBPM : Option < unsafe extern "C" fn (__proj : * mut root :: ReaProject , bpm : f64 , wantUndo : bool ,) > , pub SetCursorContext : Option < unsafe extern "C" fn (mode : :: std :: os :: raw :: c_int , envInOptional : * mut root :: TrackEnvelope ,) > , pub SetEditCurPos : Option < extern "C" fn (time : f64 , moveview : bool , seekplay : bool ,) > , pub SetEditCurPos2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , time : f64 , moveview : bool , seekplay : bool ,) > , pub SetEnvelopePoint : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , ptidx : :: std :: os :: raw :: c_int , timeInOptional : * mut f64 , valueInOptional : * mut f64 , shapeInOptional : * mut :: std :: os :: raw :: c_int , tensionInOptional : * mut f64 , selectedInOptional : * mut bool , noSortInOptional : * mut bool ,) -> bool > , pub SetEnvelopePointEx : Option < unsafe extern "C" fn (envelope : * mut root :: TrackEnvelope , autoitem_idx : :: std :: os :: raw :: c_int , ptidx : :: std :: os :: raw :: c_int , timeInOptional : * mut f64 , valueInOptional : * mut f64 , shapeInOptional : * mut :: std :: os :: raw :: c_int , tensionInOptional : * mut f64 , selectedInOptional : * mut bool , noSortInOptional : * mut bool ,) -> bool > , pub SetEnvelopeStateChunk : Option < unsafe extern "C" fn (env : * mut root :: TrackEnvelope , str : * const :: std :: os :: raw :: c_char , isundoOptional : bool ,) -> bool > , pub SetExtState : Option < unsafe extern "C" fn (section : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char , persist : bool ,) > , pub SetGlobalAutomationOverride : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int) > , pub SetItemStateChunk : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , str : * const :: std :: os :: raw :: c_char , isundoOptional : bool ,) -> bool > , pub SetMasterTrackVisibility : Option < extern "C" fn (flag : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetMediaItemInfo_Value : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64 ,) -> bool > , pub SetMediaItemLength : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , length : f64 , refreshUI : bool ,) -> bool > , pub SetMediaItemPosition : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , position : f64 , refreshUI : bool ,) -> bool > , pub SetMediaItemSelected : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , selected : bool ,) > , pub SetMediaItemTake_Source : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , source : * mut root :: PCM_source ,) -> bool > , pub SetMediaItemTakeInfo_Value : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64 ,) -> bool > , pub SetMediaTrackInfo_Value : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64 ,) -> bool > , pub SetMIDIEditorGrid : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , division : f64 ,) > , pub SetMixerScroll : Option < unsafe extern "C" fn (leftmosttrack : * mut root :: MediaTrack ,) -> * mut root :: MediaTrack > , pub SetMouseModifier : Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_char , modifier_flag : :: std :: os :: raw :: c_int , action : * const :: std :: os :: raw :: c_char ,) > , pub SetOnlyTrackSelected : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack) > , pub SetProjectGrid : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , division : f64 ,) > , pub SetProjectMarker : Option < unsafe extern "C" fn (markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char ,) -> bool > , pub SetProjectMarker2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char ,) -> bool > , pub SetProjectMarker3 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int ,) -> bool > , pub SetProjectMarker4 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnindexnumber : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> bool > , pub SetProjectMarkerByIndex : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnidx : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , IDnumber : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int ,) -> bool > , pub SetProjectMarkerByIndex2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , markrgnidx : :: std :: os :: raw :: c_int , isrgn : bool , pos : f64 , rgnend : f64 , IDnumber : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_int ,) -> bool > , pub SetProjExtState : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , extname : * const :: std :: os :: raw :: c_char , key : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub SetRegionRenderMatrix : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , regionindex : :: std :: os :: raw :: c_int , track : * mut root :: MediaTrack , flag : :: std :: os :: raw :: c_int ,) > , pub SetRenderLastError : Option < unsafe extern "C" fn (errorstr : * const :: std :: os :: raw :: c_char) > , pub SetTakeMarker : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , nameIn : * const :: std :: os :: raw :: c_char , srcposInOptional : * mut f64 , colorInOptional : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTakeStretchMarker : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , pos : f64 , srcposInOptional : * const f64 ,) -> :: std :: os :: raw :: c_int > , pub SetTakeStretchMarkerSlope : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , idx : :: std :: os :: raw :: c_int , slope : f64 ,) -> bool > , pub SetTempoTimeSigMarker : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , ptidx : :: std :: os :: raw :: c_int , timepos : f64 , measurepos : :: std :: os :: raw :: c_int , beatpos : f64 , bpm : f64 , timesig_num : :: std :: os :: raw :: c_int , timesig_denom : :: std :: os :: raw :: c_int , lineartempo : bool ,) -> bool > , pub SetThemeColor : Option < unsafe extern "C" fn (ini_key : * const :: std :: os :: raw :: c_char , color : :: std :: os :: raw :: c_int , flagsOptional : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetToggleCommandState : Option < extern "C" fn (section_id : :: std :: os :: raw :: c_int , command_id : :: std :: os :: raw :: c_int , state : :: std :: os :: raw :: c_int ,) -> bool > , pub SetTrackAutomationMode : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , mode : :: std :: os :: raw :: c_int ,) > , pub SetTrackColor : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , color : :: std :: os :: raw :: c_int ,) > , pub SetTrackMIDILyrics : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , flag : :: std :: os :: raw :: c_int , str : * const :: std :: os :: raw :: c_char ,) -> bool > , pub SetTrackMIDINoteName : Option < unsafe extern "C" fn (track : :: std :: os :: raw :: c_int , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char ,) -> bool > , pub SetTrackMIDINoteNameEx : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , track : * mut root :: MediaTrack , pitch : :: std :: os :: raw :: c_int , chan : :: std :: os :: raw :: c_int , name : * const :: std :: os :: raw :: c_char ,) -> bool > , pub SetTrackSelected : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , selected : bool ,) > , pub SetTrackSendInfo_Value : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , category : :: std :: os :: raw :: c_int , sendidx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , newvalue : f64 ,) -> bool > , pub SetTrackSendUIPan : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , send_idx : :: std :: os :: raw :: c_int , pan : f64 , isend : :: std :: os :: raw :: c_int ,) -> bool > , pub SetTrackSendUIVol : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , send_idx : :: std :: os :: raw :: c_int , vol : f64 , isend : :: std :: os :: raw :: c_int ,) -> bool > , pub SetTrackStateChunk : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , str : * const :: std :: os :: raw :: c_char , isundoOptional : bool ,) -> bool > , pub SetTrackUIInputMonitor : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , monitor : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTrackUIMute : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , mute : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTrackUIPan : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , pan : f64 , relative : bool , done : bool , igngroupflags : :: std :: os :: raw :: c_int ,) -> f64 > , pub SetTrackUIPolarity : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , polarity : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTrackUIRecArm : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , recarm : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTrackUISolo : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , solo : :: std :: os :: raw :: c_int , igngroupflags : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub SetTrackUIVolume : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , volume : f64 , relative : bool , done : bool , igngroupflags : :: std :: os :: raw :: c_int ,) -> f64 > , pub SetTrackUIWidth : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , width : f64 , relative : bool , done : bool , igngroupflags : :: std :: os :: raw :: c_int ,) -> f64 > , pub ShowActionList : Option < unsafe extern "C" fn (section : * mut root :: KbdSectionInfo , callerWnd : root :: HWND ,) > , pub ShowConsoleMsg : Option < unsafe extern "C" fn (msg : * const :: std :: os :: raw :: c_char) > , pub ShowMessageBox : Option < unsafe extern "C" fn (msg : * const :: std :: os :: raw :: c_char , title : * const :: std :: os :: raw :: c_char , type_ : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub ShowPopupMenu : Option < unsafe extern "C" fn (name : * const :: std :: os :: raw :: c_char , x : :: std :: os :: raw :: c_int , y : :: std :: os :: raw :: c_int , hwndParentOptional : root :: HWND , ctxOptional : * mut :: std :: os :: raw :: c_void , ctx2Optional : :: std :: os :: raw :: c_int , ctx3Optional : :: std :: os :: raw :: c_int ,) > , pub SLIDER2DB : Option < extern "C" fn (y : f64) -> f64 > , pub SnapToGrid : Option < unsafe extern "C" fn (project : * mut root :: ReaProject , time_pos : f64 ,) -> f64 > , pub SoloAllTracks : Option < extern "C" fn (solo : :: std :: os :: raw :: c_int) > , pub Splash_GetWnd : Option < extern "C" fn () -> root :: HWND > , pub SplitMediaItem : Option < unsafe extern "C" fn (item : * mut root :: MediaItem , position : f64 ,) -> * mut root :: MediaItem > , pub StopPreview : Option < unsafe extern "C" fn (preview : * mut root :: preview_register_t ,) -> :: std :: os :: raw :: c_int > , pub StopTrackPreview : Option < unsafe extern "C" fn (preview : * mut root :: preview_register_t ,) -> :: std :: os :: raw :: c_int > , pub StopTrackPreview2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , preview : * mut root :: preview_register_t ,) -> :: std :: os :: raw :: c_int > , pub stringToGuid : Option < unsafe extern "C" fn (str : * const :: std :: os :: raw :: c_char , g : * mut root :: GUID ,) > , pub StuffMIDIMessage : Option < extern "C" fn (mode : :: std :: os :: raw :: c_int , msg1 : :: std :: os :: raw :: c_int , msg2 : :: std :: os :: raw :: c_int , msg3 : :: std :: os :: raw :: c_int ,) > , pub TakeFX_AddByName : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fxname : * const :: std :: os :: raw :: c_char , instantiate : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_CopyToTake : Option < unsafe extern "C" fn (src_take : * mut root :: MediaItem_Take , src_fx : :: std :: os :: raw :: c_int , dest_take : * mut root :: MediaItem_Take , dest_fx : :: std :: os :: raw :: c_int , is_move : bool ,) > , pub TakeFX_CopyToTrack : Option < unsafe extern "C" fn (src_take : * mut root :: MediaItem_Take , src_fx : :: std :: os :: raw :: c_int , dest_track : * mut root :: MediaTrack , dest_fx : :: std :: os :: raw :: c_int , is_move : bool ,) > , pub TakeFX_Delete : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_EndParamEdit : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_FormatParamValue : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64 , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_FormatParamValueNormalized : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetChainVisible : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetCount : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetEnabled : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetEnvelope : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fxindex : :: std :: os :: raw :: c_int , parameterindex : :: std :: os :: raw :: c_int , create : bool ,) -> * mut root :: TrackEnvelope > , pub TakeFX_GetFloatingWindow : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , index : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub TakeFX_GetFormattedParamValue : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetFXGUID : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int ,) -> * mut root :: GUID > , pub TakeFX_GetFXName : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetIOSize : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , inputPinsOut : * mut :: std :: os :: raw :: c_int , outputPinsOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetNamedConfigParm : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetNumParams : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetOffline : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetOpen : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetParam : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64 ,) -> f64 > , pub TakeFX_GetParameterStepSizes : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , stepOut : * mut f64 , smallstepOut : * mut f64 , largestepOut : * mut f64 , istoggleOut : * mut bool ,) -> bool > , pub TakeFX_GetParamEx : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64 , midvalOut : * mut f64 ,) -> f64 > , pub TakeFX_GetParamFromIdent : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , ident_str : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetParamIdent : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetParamName : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetParamNormalized : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int ,) -> f64 > , pub TakeFX_GetPinMappings : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , high32Out : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetPreset : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , presetnameOut : * mut :: std :: os :: raw :: c_char , presetnameOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_GetPresetIndex : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , numberOfPresetsOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TakeFX_GetUserPresetFilename : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , fnOut : * mut :: std :: os :: raw :: c_char , fnOut_sz : :: std :: os :: raw :: c_int ,) > , pub TakeFX_NavigatePresets : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , presetmove : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_SetEnabled : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , enabled : bool ,) > , pub TakeFX_SetNamedConfigParm : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char ,) -> bool > , pub TakeFX_SetOffline : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , offline : bool ,) > , pub TakeFX_SetOpen : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , open : bool ,) > , pub TakeFX_SetParam : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64 ,) -> bool > , pub TakeFX_SetParamNormalized : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64 ,) -> bool > , pub TakeFX_SetPinMappings : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , low32bits : :: std :: os :: raw :: c_int , hi32bits : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_SetPreset : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , presetname : * const :: std :: os :: raw :: c_char ,) -> bool > , pub TakeFX_SetPresetByIndex : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , fx : :: std :: os :: raw :: c_int , idx : :: std :: os :: raw :: c_int ,) -> bool > , pub TakeFX_Show : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take , index : :: std :: os :: raw :: c_int , showFlag : :: std :: os :: raw :: c_int ,) > , pub TakeIsMIDI : Option < unsafe extern "C" fn (take : * mut root :: MediaItem_Take) -> bool > , pub ThemeLayout_GetLayout : Option < unsafe extern "C" fn (section : * const :: std :: os :: raw :: c_char , idx : :: std :: os :: raw :: c_int , nameOut : * mut :: std :: os :: raw :: c_char , nameOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub ThemeLayout_GetParameter : Option < unsafe extern "C" fn (wp : :: std :: os :: raw :: c_int , descOutOptional : * mut * const :: std :: os :: raw :: c_char , valueOutOptional : * mut :: std :: os :: raw :: c_int , defValueOutOptional : * mut :: std :: os :: raw :: c_int , minValueOutOptional : * mut :: std :: os :: raw :: c_int , maxValueOutOptional : * mut :: std :: os :: raw :: c_int ,) -> * const :: std :: os :: raw :: c_char > , pub ThemeLayout_RefreshAll : Option < extern "C" fn () > , pub ThemeLayout_SetLayout : Option < unsafe extern "C" fn (section : * const :: std :: os :: raw :: c_char , layout : * const :: std :: os :: raw :: c_char ,) -> bool > , pub ThemeLayout_SetParameter : Option < extern "C" fn (wp : :: std :: os :: raw :: c_int , value : :: std :: os :: raw :: c_int , persist : bool ,) -> bool > , pub time_precise : Option < extern "C" fn () -> f64 > , pub TimeMap2_beatsToTime : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , tpos : f64 , measuresInOptional : * const :: std :: os :: raw :: c_int ,) -> f64 > , pub TimeMap2_GetDividedBpmAtTime : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , time : f64 ,) -> f64 > , pub TimeMap2_GetNextChangeTime : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , time : f64 ,) -> f64 > , pub TimeMap2_QNToTime : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , qn : f64 ,) -> f64 > , pub TimeMap2_timeToBeats : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , tpos : f64 , measuresOutOptional : * mut :: std :: os :: raw :: c_int , cmlOutOptional : * mut :: std :: os :: raw :: c_int , fullbeatsOutOptional : * mut f64 , cdenomOutOptional : * mut :: std :: os :: raw :: c_int ,) -> f64 > , pub TimeMap2_timeToQN : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , tpos : f64 ,) -> f64 > , pub TimeMap_curFrameRate : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , dropFrameOut : * mut bool ,) -> f64 > , pub TimeMap_GetDividedBpmAtTime : Option < extern "C" fn (time : f64) -> f64 > , pub TimeMap_GetMeasureInfo : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , measure : :: std :: os :: raw :: c_int , qn_startOut : * mut f64 , qn_endOut : * mut f64 , timesig_numOut : * mut :: std :: os :: raw :: c_int , timesig_denomOut : * mut :: std :: os :: raw :: c_int , tempoOut : * mut f64 ,) -> f64 > , pub TimeMap_GetMetronomePattern : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , time : f64 , pattern : * mut :: std :: os :: raw :: c_char , pattern_sz : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TimeMap_GetTimeSigAtTime : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , time : f64 , timesig_numOut : * mut :: std :: os :: raw :: c_int , timesig_denomOut : * mut :: std :: os :: raw :: c_int , tempoOut : * mut f64 ,) > , pub TimeMap_QNToMeasures : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , qn : f64 , qnMeasureStartOutOptional : * mut f64 , qnMeasureEndOutOptional : * mut f64 ,) -> :: std :: os :: raw :: c_int > , pub TimeMap_QNToTime : Option < extern "C" fn (qn : f64) -> f64 > , pub TimeMap_QNToTime_abs : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , qn : f64 ,) -> f64 > , pub TimeMap_timeToQN : Option < extern "C" fn (tpos : f64) -> f64 > , pub TimeMap_timeToQN_abs : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , tpos : f64 ,) -> f64 > , pub ToggleTrackSendUIMute : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , send_idx : :: std :: os :: raw :: c_int ,) -> bool > , pub Track_GetPeakHoldDB : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , channel : :: std :: os :: raw :: c_int , clear : bool ,) -> f64 > , pub Track_GetPeakInfo : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , channel : :: std :: os :: raw :: c_int ,) -> f64 > , pub TrackCtl_SetToolTip : Option < unsafe extern "C" fn (fmt : * const :: std :: os :: raw :: c_char , xpos : :: std :: os :: raw :: c_int , ypos : :: std :: os :: raw :: c_int , topmost : bool ,) > , pub TrackFX_AddByName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxname : * const :: std :: os :: raw :: c_char , recFX : bool , instantiate : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_CopyToTake : Option < unsafe extern "C" fn (src_track : * mut root :: MediaTrack , src_fx : :: std :: os :: raw :: c_int , dest_take : * mut root :: MediaItem_Take , dest_fx : :: std :: os :: raw :: c_int , is_move : bool ,) > , pub TrackFX_CopyToTrack : Option < unsafe extern "C" fn (src_track : * mut root :: MediaTrack , src_fx : :: std :: os :: raw :: c_int , dest_track : * mut root :: MediaTrack , dest_fx : :: std :: os :: raw :: c_int , is_move : bool ,) > , pub TrackFX_Delete : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_EndParamEdit : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_FormatParamValue : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64 , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_FormatParamValueNormalized : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64 , buf : * mut :: std :: os :: raw :: c_char , buf_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetByName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxname : * const :: std :: os :: raw :: c_char , instantiate : bool ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetChainVisible : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetCount : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetEnabled : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetEQ : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , instantiate : bool ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetEQBandEnabled : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , bandtype : :: std :: os :: raw :: c_int , bandidx : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetEQParam : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , paramidx : :: std :: os :: raw :: c_int , bandtypeOut : * mut :: std :: os :: raw :: c_int , bandidxOut : * mut :: std :: os :: raw :: c_int , paramtypeOut : * mut :: std :: os :: raw :: c_int , normvalOut : * mut f64 ,) -> bool > , pub TrackFX_GetFloatingWindow : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , index : :: std :: os :: raw :: c_int ,) -> root :: HWND > , pub TrackFX_GetFormattedParamValue : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetFXGUID : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int ,) -> * mut root :: GUID > , pub TrackFX_GetFXName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetInstrument : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetIOSize : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , inputPinsOut : * mut :: std :: os :: raw :: c_int , outputPinsOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetNamedConfigParm : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , bufOutNeedBig : * mut :: std :: os :: raw :: c_char , bufOutNeedBig_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetNumParams : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetOffline : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetOpen : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetParam : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64 ,) -> f64 > , pub TrackFX_GetParameterStepSizes : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , stepOut : * mut f64 , smallstepOut : * mut f64 , largestepOut : * mut f64 , istoggleOut : * mut bool ,) -> bool > , pub TrackFX_GetParamEx : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , minvalOut : * mut f64 , maxvalOut : * mut f64 , midvalOut : * mut f64 ,) -> f64 > , pub TrackFX_GetParamFromIdent : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , ident_str : * const :: std :: os :: raw :: c_char ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetParamIdent : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetParamName : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , bufOut : * mut :: std :: os :: raw :: c_char , bufOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetParamNormalized : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int ,) -> f64 > , pub TrackFX_GetPinMappings : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , high32Out : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetPreset : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , presetnameOut : * mut :: std :: os :: raw :: c_char , presetnameOut_sz : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_GetPresetIndex : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , numberOfPresetsOut : * mut :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetRecChainVisible : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetRecCount : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack ,) -> :: std :: os :: raw :: c_int > , pub TrackFX_GetUserPresetFilename : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , fnOut : * mut :: std :: os :: raw :: c_char , fnOut_sz : :: std :: os :: raw :: c_int ,) > , pub TrackFX_NavigatePresets : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , presetmove : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_SetEnabled : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , enabled : bool ,) > , pub TrackFX_SetEQBandEnabled : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , bandtype : :: std :: os :: raw :: c_int , bandidx : :: std :: os :: raw :: c_int , enable : bool ,) -> bool > , pub TrackFX_SetEQParam : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fxidx : :: std :: os :: raw :: c_int , bandtype : :: std :: os :: raw :: c_int , bandidx : :: std :: os :: raw :: c_int , paramtype : :: std :: os :: raw :: c_int , val : f64 , isnorm : bool ,) -> bool > , pub TrackFX_SetNamedConfigParm : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , parmname : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char ,) -> bool > , pub TrackFX_SetOffline : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , offline : bool ,) > , pub TrackFX_SetOpen : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , open : bool ,) > , pub TrackFX_SetParam : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , val : f64 ,) -> bool > , pub TrackFX_SetParamNormalized : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , param : :: std :: os :: raw :: c_int , value : f64 ,) -> bool > , pub TrackFX_SetPinMappings : Option < unsafe extern "C" fn (tr : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , isoutput : :: std :: os :: raw :: c_int , pin : :: std :: os :: raw :: c_int , low32bits : :: std :: os :: raw :: c_int , hi32bits : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_SetPreset : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , presetname : * const :: std :: os :: raw :: c_char ,) -> bool > , pub TrackFX_SetPresetByIndex : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , fx : :: std :: os :: raw :: c_int , idx : :: std :: os :: raw :: c_int ,) -> bool > , pub TrackFX_Show : Option < unsafe extern "C" fn (track : * mut root :: MediaTrack , index : :: std :: os :: raw :: c_int , showFlag : :: std :: os :: raw :: c_int ,) > , pub TrackList_AdjustWindows : Option < extern "C" fn (isMinor : bool) > , pub TrackList_UpdateAllExternalSurfaces : Option < extern "C" fn () > , pub Undo_BeginBlock : Option < extern "C" fn () > , pub Undo_BeginBlock2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject) > , pub Undo_CanRedo2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> * const :: std :: os :: raw :: c_char > , pub Undo_CanUndo2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> * const :: std :: os :: raw :: c_char > , pub Undo_DoRedo2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub Undo_DoUndo2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject ,) -> :: std :: os :: raw :: c_int > , pub Undo_EndBlock : Option < unsafe extern "C" fn (descchange : * const :: std :: os :: raw :: c_char , extraflags : :: std :: os :: raw :: c_int ,) > , pub Undo_EndBlock2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , descchange : * const :: std :: os :: raw :: c_char , extraflags : :: std :: os :: raw :: c_int ,) > , pub Undo_OnStateChange : Option < unsafe extern "C" fn (descchange : * const :: std :: os :: raw :: c_char ,) > , pub Undo_OnStateChange2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , descchange : * const :: std :: os :: raw :: c_char ,) > , pub Undo_OnStateChange_Item : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , name : * const :: std :: os :: raw :: c_char , item : * mut root :: MediaItem ,) > , pub Undo_OnStateChangeEx : Option < unsafe extern "C" fn (descchange : * const :: std :: os :: raw :: c_char , whichStates : :: std :: os :: raw :: c_int , trackparm : :: std :: os :: raw :: c_int ,) > , pub Undo_OnStateChangeEx2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , descchange : * const :: std :: os :: raw :: c_char , whichStates : :: std :: os :: raw :: c_int , trackparm : :: std :: os :: raw :: c_int ,) > , pub update_disk_counters : Option < extern "C" fn (readamt : :: std :: os :: raw :: c_int , writeamt : :: std :: os :: raw :: c_int ,) > , pub UpdateArrange : Option < extern "C" fn () > , pub UpdateItemInProject : Option < unsafe extern "C" fn (item : * mut root :: MediaItem) > , pub UpdateTimeline : Option < extern "C" fn () > , pub ValidatePtr : Option < unsafe extern "C" fn (pointer : * mut :: std :: os :: raw :: c_void , ctypename : * const :: std :: os :: raw :: c_char ,) -> bool > , pub ValidatePtr2 : Option < unsafe extern "C" fn (proj : * mut root :: ReaProject , pointer : * mut :: std :: os :: raw :: c_void , ctypename : * const :: std :: os :: raw :: c_char ,) -> bool > , pub ViewPrefs : Option < unsafe extern "C" fn (page : :: std :: os :: raw :: c_int , pageByName : * const :: std :: os :: raw :: c_char ,) > , pub WDL_VirtualWnd_ScaledBlitBG : Option < unsafe extern "C" fn (dest : * mut root :: reaper_functions :: LICE_IBitmap , src : * mut root :: reaper_functions :: WDL_VirtualWnd_BGCfg , destx : :: std :: os :: raw :: c_int , desty : :: std :: os :: raw :: c_int , destw : :: std :: os :: raw :: c_int , desth : :: std :: os :: raw :: c_int , clipx : :: std :: os :: raw :: c_int , clipy : :: std :: os :: raw :: c_int , clipw : :: std :: os :: raw :: c_int , cliph : :: std :: os :: raw :: c_int , alpha : f32 , mode : :: std :: os :: raw :: c_int ,) -> bool > , pub GetMidiInput : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int ,) -> * mut root :: midi_Input > , pub GetMidiOutput : Option < extern "C" fn (idx : :: std :: os :: raw :: c_int ,) -> * mut root :: midi_Output > , pub InitializeCoolSB : Option < unsafe extern "system" fn (hwnd : root :: HWND) -> root :: BOOL > , pub UninitializeCoolSB : Option < unsafe extern "system" fn (hwnd : root :: HWND) -> root :: HRESULT > , pub CoolSB_SetMinThumbSize : Option < unsafe extern "system" fn (hwnd : root :: HWND , wBar : root :: UINT , size : root :: UINT ,) -> root :: BOOL > , pub CoolSB_GetScrollInfo : Option < unsafe extern "system" fn (hwnd : root :: HWND , fnBar : :: std :: os :: raw :: c_int , lpsi : root :: LPSCROLLINFO ,) -> root :: BOOL > , pub CoolSB_SetScrollInfo : Option < unsafe extern "system" fn (hwnd : root :: HWND , fnBar : :: std :: os :: raw :: c_int , lpsi : root :: LPSCROLLINFO , fRedraw : root :: BOOL ,) -> :: std :: os :: raw :: c_int > , pub CoolSB_SetScrollPos : Option < unsafe extern "system" fn (hwnd : root :: HWND , nBar : :: std :: os :: raw :: c_int , nPos : :: std :: os :: raw :: c_int , fRedraw : root :: BOOL ,) -> :: std :: os :: raw :: c_int > , pub CoolSB_SetScrollRange : Option < unsafe extern "system" fn (hwnd : root :: HWND , nBar : :: std :: os :: raw :: c_int , nMinPos : :: std :: os :: raw :: c_int , nMaxPos : :: std :: os :: raw :: c_int , fRedraw : root :: BOOL ,) -> :: std :: os :: raw :: c_int > , pub CoolSB_ShowScrollBar : Option < unsafe extern "system" fn (hwnd : root :: HWND , wBar : :: std :: os :: raw :: c_int , fShow : root :: BOOL ,) -> root :: BOOL > , pub CoolSB_SetResizingThumb : Option < unsafe extern "system" fn (hwnd : root :: HWND , active : root :: BOOL ,) -> root :: BOOL > , pub CoolSB_SetThemeIndex : Option < unsafe extern "system" fn (hwnd : root :: HWND , idx : :: std :: os :: raw :: c_int ,) -> root :: BOOL > , } impl ReaperFunctionPointers { pub (crate) const TOTAL_COUNT : u32 = 848u32 ; }